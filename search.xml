<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>软件测试复习笔记-Black-Box Testing</title>
    <url>/2020/10/14/software-testing-notes-2/</url>
    <content><![CDATA[<blockquote>
<p>Black-box testing –testing based on a specification</p>
</blockquote>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-2-1.png" alt></p>
<h2 id="Advantages-of-Black-box-Testing"><a href="#Advantages-of-Black-box-Testing" class="headerlink" title="Advantages of Black-box Testing"></a>Advantages of Black-box Testing</h2><blockquote>
<p>You don’t need to know how it is implemented</p>
</blockquote>
<ul>
<li>You can plan tests earlier</li>
<li>You can write tests earlier</li>
<li>You do not need to be the person who implements the code</li>
<li>When the implementation changes, the tests should still work</li>
</ul>
<h2 id="Different-techniques-for-Black-box-Testing"><a href="#Different-techniques-for-Black-box-Testing" class="headerlink" title="Different techniques for Black-box Testing"></a>Different techniques for Black-box Testing</h2><ul>
<li>Equivalence Partitioning</li>
<li>Boundary Value Analysis</li>
<li>Decision Tables</li>
<li>Cause-Effect Graphing</li>
<li>Error guessing</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| Gauss型求积公式</title>
    <url>/2020/10/11/mathAnalysis-6-5/</url>
    <content><![CDATA[<h1 id="Gauss型求积公式"><a href="#Gauss型求积公式" class="headerlink" title="Gauss型求积公式"></a>Gauss型求积公式</h1><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul>
<li>区间$[a,b]$上权函数为$\rho(x)$的具有n个节点的求积公式的代数精度不超过$2n-1$.</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul>
<li><p>对于给定区间$[a,b]$及权函数$\rho(x)$,由$Schemite$正交化过程构造正交多项式$p_0(x),p_1(x),…,p_n(x)$;</p>
</li>
<li><p>求出$p_n(x)$的$n$个零点,即$Gauss$点</p>
</li>
<li><p>计算求积系数$A_i=\int_a^bl_i(x)\rho(x)dx,i=1,2,…,n$.</p>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul>
<li>求计算积分$f_{-1}^1x^2f(x)dx的两点Gauss公式$</li>
</ul>
<script type="math/tex; mode=display">
1.首先进行Schemite正交化\\</script><script type="math/tex; mode=display">
p_0(x) = 1\\
p_1(x) = x - \frac{(x,p_0(x))}{(p_0(x),p_0(x))}p_0(x)=x\\</script><script type="math/tex; mode=display">
p_2(x) = x^2-\frac{(x^2,p_0(x))}{(p_0(x),p_0(x))}p_0(x) - \frac{(x^2,p_1(x))}{(p_1(x),p_1(x))}p_1(x)=x^2-\frac{3}{5}\\</script><script type="math/tex; mode=display">
2.令p_2(x) = 0,求出Gauss点\\</script><script type="math/tex; mode=display">
x_1=-\sqrt{\frac{3}{5}},x_2=\sqrt{\frac{3}{5}}\\</script><script type="math/tex; mode=display">
3.计算求积系数A_k \\</script><script type="math/tex; mode=display">
A_1 = \int_{-1}^1x^2\frac{x-x_2}{x_1-x_2}dx=\frac{1}{3}\\
A_2 = \int_{-1}^1x^2\frac{x-x_1}{x_2-x_1}dx=\frac{1}{3}</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 复化求积公式</title>
    <url>/2020/10/11/mathAnalysis-6-4/</url>
    <content><![CDATA[<h1 id="复化求积公式"><a href="#复化求积公式" class="headerlink" title="复化求积公式"></a>复化求积公式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>和分段插值多项式的原理类似</li>
</ul>
<h2 id="复化梯形公式"><a href="#复化梯形公式" class="headerlink" title="复化梯形公式"></a>复化梯形公式</h2><script type="math/tex; mode=display">
\int_a^bf(x)dx \approx \frac{h}{2}[f(a) + 2\sum_{k=1}^{n-1}f(x_k)+f(b)] = T_n \\
R[f]=I-T_n\le \frac{(b-a)^3}{12n^2}M_2</script><h2 id="复化Simpson公式"><a href="#复化Simpson公式" class="headerlink" title="复化Simpson公式"></a>复化Simpson公式</h2><script type="math/tex; mode=display">
\int_a^bf(x)dx\approx \frac{h}{6}[f(a)+4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(b)]\\
|I-S_n|\le \frac{(b-a)^5}{2880n^4}M_4</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 插值型数值求积公式</title>
    <url>/2020/10/11/mathAnalysis-6-3/</url>
    <content><![CDATA[<h1 id="插值型数值求积公式"><a href="#插值型数值求积公式" class="headerlink" title="插值型数值求积公式"></a>插值型数值求积公式</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><script type="math/tex; mode=display">
\int_a^bf(x)dx\approx\int_a^bL_n(x)dx=\sum_{k=0}^n[\int_a^bl_k(x)dx]f(x_k)\\
A_k=\int_a^bl_k(x)dx\\
R[f] = \frac{1}{(n+1)!}\int_a^bf^{n+1}(\xi_x)\omega_{n+1}(x)dx</script><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul>
<li>求积公式至少具有n次代数精度的充分必要条件是其是插值型求积公式</li>
</ul>
<h2 id="Newton-Cotes-求积公式"><a href="#Newton-Cotes-求积公式" class="headerlink" title="Newton-Cotes 求积公式"></a>Newton-Cotes 求积公式</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><script type="math/tex; mode=display">
\int_a^bf(x)dx\approx(b-a)\sum_{k=0}^nC_k^{(n)}f(a+kh)</script><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><ul>
<li>当n为偶数时，Newton-Cotes求积公式至少具有n+1次代数精度。</li>
</ul>
<h3 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h3><h4 id="梯形公式"><a href="#梯形公式" class="headerlink" title="梯形公式"></a>梯形公式</h4><script type="math/tex; mode=display">
\int_a^bf(x)dx=\frac{(b-a)}{2}(f(a)+f(b))\\
R[f] \le \frac{M_2}{12}(b-a)^3</script><h4 id="Simpson公式-具有三次代数精度"><a href="#Simpson公式-具有三次代数精度" class="headerlink" title="Simpson公式(具有三次代数精度)"></a>Simpson公式(具有三次代数精度)</h4><script type="math/tex; mode=display">
\int_a^bf(x)dx=\frac{(b-a)}{6}(f(a)+4f(\frac{a+b}{2})+f(b)) \\
R[f] \le \frac{M_4}{2880}(b-a)^5</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 数值积分的代数精度</title>
    <url>/2020/10/11/mathAnalysis-6-2/</url>
    <content><![CDATA[<h1 id="数值积分的代数精度"><a href="#数值积分的代数精度" class="headerlink" title="数值积分的代数精度"></a>数值积分的代数精度</h1><h2 id="代数精度的定义"><a href="#代数精度的定义" class="headerlink" title="代数精度的定义"></a>代数精度的定义</h2><ul>
<li><p>若求积公式 $\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)$对于$f(x)=x^j(j=0,1,2…m)$都精确成立，但对$f(x)=x^{m+1}$不精确成立，则称该求积公式有$m$次的代数精度。</p>
</li>
<li><p>如果一个求积公式的代数精度为$m$，则该求积公式对于任何次数不超过$m$的函数都是精确成立的。</p>
</li>
<li><p>一般来说，代数精度越高，求积公式的精度也越高。</p>
</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li><p>已知一个求积公式，和一些离散的节点，让你求求积公式的代数精度：</p>
<p>这类题，有几个未知数就列几个方程求解即可，同时还要带入更高阶的多项式函数来验证求积公式是否具有更高阶的代数精度。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 数值积分的基本概念</title>
    <url>/2020/10/11/mathAnalysis-6-1/</url>
    <content><![CDATA[<h1 id="数值积分的基本概念"><a href="#数值积分的基本概念" class="headerlink" title="数值积分的基本概念"></a>数值积分的基本概念</h1><ul>
<li><p>牛顿-莱布尼兹公式</p>
<p>  $\int_b^af(x)dx=F(b)-F(a)$</p>
</li>
<li><p>定积分的定义</p>
<p>  $I=\int_a^bf(x)dx=lim_{\Delta x\rightarrow0}\sum_{i=0}^nf(x_i)\Delta x_i$</p>
</li>
<li><p>求积公式的一般形式</p>
<p>  $\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k).A_k为求积系数，x_k为求积节点$</p>
</li>
<li><p>积分中值定理</p>
<p>  在$[a,b]$内存在一点$\xi$,有$\int_a^bf(x)dx=(b-a)f(\xi)$成立</p>
</li>
<li><p>由积分中值定理可得三个数值积分公式</p>
<p>  左矩形公式：$f_a^bf(x)dx=(b-a)f(a)$</p>
<p>  中矩形公式：$f_a^bf(x)dx=(b-a)f(\frac{b+a}{2})$</p>
<p>  右矩形公式：$f_a^bf(x)dx=(b-a)f(b)$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-Unit Testing</title>
    <url>/2020/10/11/software-testing-notes-4/</url>
    <content><![CDATA[<h2 id="What-is-Unit-Testing"><a href="#What-is-Unit-Testing" class="headerlink" title="What is Unit Testing?"></a>What is Unit Testing?</h2><h3 id="Software-Units"><a href="#Software-Units" class="headerlink" title="Software Units:"></a>Software Units:</h3><p>A unit is the smallest unit of the design in a software project</p>
<ul>
<li>In Java, a unit is a class or a method</li>
<li>In C, a unit is a function or .h/.c files</li>
</ul>
<h3 id="Unit-Testing"><a href="#Unit-Testing" class="headerlink" title="Unit Testing:"></a>Unit Testing:</h3><p>A process to check that each unit is working correctly, according to the requirements and design</p>
<ul>
<li>Test each unit independently of other units</li>
<li>We can use tools to help us, e.g. JUnit, but the tools aren’t required.</li>
</ul>
<h2 id="Something-should-be-concerned-when-doing-unit-testing"><a href="#Something-should-be-concerned-when-doing-unit-testing" class="headerlink" title="Something should be concerned when doing unit testing"></a>Something should be concerned when doing unit testing</h2><ul>
<li>Focus on single SUT at a time</li>
<li>Don’t test multiple units at once</li>
</ul>
<h2 id="Purpose-of-Unit-Testing"><a href="#Purpose-of-Unit-Testing" class="headerlink" title="Purpose of Unit Testing"></a>Purpose of Unit Testing</h2><ul>
<li>Validate whether code is consistent with the design and requirements.</li>
<li>Discover the errors between requirements , design and implementation.<ul>
<li>Error of omission(what is required, but not implemented)</li>
<li>Error of commission (an incorrect implementation)</li>
</ul>
</li>
</ul>
<h2 id="Aims-of-Unit-Tests"><a href="#Aims-of-Unit-Tests" class="headerlink" title="Aims of Unit Tests"></a>Aims of Unit Tests</h2><ul>
<li><strong>Aim:</strong> ensure that module was implemented correctly</li>
<li><strong>Input: </strong>detailed specification</li>
<li><strong>Process: </strong>design and implement tests and analyse results</li>
<li><strong>Personnal: </strong>Developers and Testers</li>
<li><strong>Test Approaches: </strong>black-box and white-box methods</li>
<li><strong>Evaluation: </strong>determine if the tests reveal errors</li>
</ul>
<h2 id="Some-benefits-of-Unit-Testing"><a href="#Some-benefits-of-Unit-Testing" class="headerlink" title="Some benefits of Unit Testing"></a>Some benefits of Unit Testing</h2><ul>
<li>The goal of unit testing is to isolate each part of the program and show that the individual parts are correct.</li>
<li>A unit test provides a strict, written contract that the piece of code must satisfy.</li>
<li>Easier to find issues when a test fails.</li>
<li>Unit tests find problems early in the development cycle. Reduce the costs.</li>
<li>Run the tests many times during development –easier to help with regression issues.</li>
</ul>
<h2 id="Aspects-of-unit-tests"><a href="#Aspects-of-unit-tests" class="headerlink" title="Aspects of unit tests"></a>Aspects of unit tests</h2><ul>
<li>Unit interface (need to be tested)</li>
<li>Functional tests - black box</li>
<li>Structural tests - white box</li>
<li>Error handling</li>
<li>Incorrect input</li>
</ul>
<h2 id="Unit-Testing-with-a-Framework"><a href="#Unit-Testing-with-a-Framework" class="headerlink" title="Unit Testing with a Framework"></a>Unit Testing with a Framework</h2><h3 id="Desirable-features-of-a-unit-test-framework"><a href="#Desirable-features-of-a-unit-test-framework" class="headerlink" title="Desirable features of a unit test framework"></a>Desirable features of a unit test framework</h3><ul>
<li>easy to write</li>
<li>easy to learn to write</li>
<li>quick to execute</li>
<li>easy to execute</li>
<li>isolated</li>
<li>composable</li>
</ul>
<h3 id="Test-Fixtures-Setup-Teardown"><a href="#Test-Fixtures-Setup-Teardown" class="headerlink" title="Test Fixtures: Setup - Teardown"></a>Test Fixtures: Setup - Teardown</h3><ul>
<li>Setup (might use common setup, e.g. @Before)</li>
<li>Exercise- call methods on the SUT</li>
<li>Verify(Assertions…)</li>
<li>Teardown (optional, e.g. @AfterEach, @AfterAll)</li>
</ul>
<h2 id="Traditional-unit-testing-strategies"><a href="#Traditional-unit-testing-strategies" class="headerlink" title="Traditional unit testing strategies"></a>Traditional unit testing strategies</h2><h3 id="Top-down-unit-testing-strategy"><a href="#Top-down-unit-testing-strategy" class="headerlink" title="Top-down unit testing strategy"></a>Top-down unit testing strategy</h3><ul>
<li>Test the top level first. Create test-doubles for units called by the top-level. Create driver for top-level. Then, use the tested unit as the driver for next level.</li>
</ul>
<h3 id="Bottom-up-unit-testing-strategy"><a href="#Bottom-up-unit-testing-strategy" class="headerlink" title="Bottom-up unit testing strategy"></a>Bottom-up unit testing strategy</h3><ul>
<li>Test the bottom modules first. Create a driver module for it. When tested, move to next module up, creating a new driver. The tested lower-level module can be used instead of a stub.</li>
</ul>
<h3 id="Isolation-testing"><a href="#Isolation-testing" class="headerlink" title="Isolation testing"></a>Isolation testing</h3><ul>
<li>Do not consider the relationship between modules. Design test doubles and driver for every unit.</li>
</ul>
<h2 id="Test-Doubles"><a href="#Test-Doubles" class="headerlink" title="Test Doubles"></a>Test Doubles</h2><h3 id="Why-we-need-use-test-doubles"><a href="#Why-we-need-use-test-doubles" class="headerlink" title="Why we need use test doubles?"></a>Why we need use test doubles?</h3><p>There are times in testing when we need to use <strong>test doubles,</strong>  which are units that are used to replace a real part of the system for test purposes. Some examples:</p>
<ul>
<li>Databases</li>
<li>Code that is not ready yet</li>
<li>External hardware</li>
<li>Components that do not return values</li>
</ul>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-4-1.png" alt="testing workflow"></p>
<h3 id="Types-pf-Test-Double"><a href="#Types-pf-Test-Double" class="headerlink" title="Types pf Test Double"></a>Types pf Test Double</h3><ul>
<li>Dummy Object</li>
<li>Test Stub</li>
<li>Mock Object</li>
<li>Fake Object</li>
</ul>
<h3 id="Dummy-Object"><a href="#Dummy-Object" class="headerlink" title="Dummy Object"></a>Dummy Object</h3><ul>
<li>An SUT requires a data value as a part of test<ul>
<li>It does not matter what value is actually in the data value, it just needs to exist</li>
</ul>
</li>
<li>In some situations, the value nullmight be used. It depends on what the SUT will do with the value.<ul>
<li>e.g. service.getOne(new QueryWrapper()); // it just need a wraaper</li>
</ul>
</li>
</ul>
<h3 id="Test-Stub"><a href="#Test-Stub" class="headerlink" title="Test Stub"></a>Test Stub</h3><ul>
<li>it just need a value (a correct value, error value, log value)</li>
<li>e.g. Data logging software</li>
</ul>
<h3 id="Mock-Object"><a href="#Mock-Object" class="headerlink" title="Mock Object"></a>Mock Object</h3><ul>
<li>A Mock Object is setup with information about what calls it should expect. It might also be setup with details of the data it should expect.</li>
<li>Mock Objects are testing the behaviourof the interaction between the SUT and DOC</li>
<li>A number of values in one unit testing(interaction)</li>
</ul>
<h3 id="Fake-Object"><a href="#Fake-Object" class="headerlink" title="Fake Object"></a>Fake Object</h3><ul>
<li>An object that replaces the functionality of the DOC</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-White-Box Testing</title>
    <url>/2020/10/11/software-testing-notes-3/</url>
    <content><![CDATA[<blockquote>
<p>White-box testing –testing based on the logic in a program</p>
</blockquote>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-3-1.png" alt></p>
<h2 id="Some-descriptions-about-White-box-Testing"><a href="#Some-descriptions-about-White-box-Testing" class="headerlink" title="Some descriptions about White-box Testing"></a>Some descriptions about White-box Testing</h2><ul>
<li>White-box is based on the implementation</li>
<li>For high confidence, e.g. in safety critical software, need to look at the code and make sure every possibility is covered(<strong>Not all software</strong>)</li>
<li>Still worth doing black-box testing then look at EXTRA tests based on white-box approaches</li>
</ul>
<h2 id="White-box-Testing-types"><a href="#White-box-Testing-types" class="headerlink" title="White-box Testing types"></a>White-box Testing types</h2><ul>
<li>Static Analysis</li>
<li>Dynamic Testing with path coverage of code</li>
</ul>
<h2 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h2><ul>
<li>Discussed during the Software Lifecycle course</li>
<li>Code Inspection(代码检查)</li>
<li>The analysis cannot be automated</li>
<li>BUT, code inspections are an effective way to detect potential problems</li>
</ul>
<h2 id="Dynamic-Testing-Path-Coverage"><a href="#Dynamic-Testing-Path-Coverage" class="headerlink" title="Dynamic Testing: Path Coverage"></a>Dynamic Testing: Path Coverage</h2><ul>
<li>Write tests so that every path through the program is tested</li>
<li>The tests can be automated and repeated</li>
</ul>
<h2 id="Baic-principles-of-path-coverage"><a href="#Baic-principles-of-path-coverage" class="headerlink" title="Baic principles of path coverage"></a>Baic principles of path coverage</h2><ul>
<li>All independent path must be traversed at least once</li>
<li>All conditions(e.g. if statements) are tested for the true and false outcome</li>
<li>Review whether the test cover the internal data structure used</li>
<li>Test that loops work for their operational range(Not All)</li>
</ul>
<blockquote>
<p>e.g. if (name == null || name.equals(“”))</p>
<p>You need create two test cases for this if statement</p>
</blockquote>
<h2 id="Path-coverage-with-IDEA"><a href="#Path-coverage-with-IDEA" class="headerlink" title="Path coverage with IDEA"></a>Path coverage with IDEA</h2><h3 id="Step-1-Create-a-normal-class-with-some-methods"><a href="#Step-1-Create-a-normal-class-with-some-methods" class="headerlink" title="Step 1: Create a normal class with some methods"></a>Step 1: Create a normal class with some methods</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-2.png" alt></p>
<h3 id="Step-2-Using-Alt-Enter-to-create-a-test-class-with-this-normal-class"><a href="#Step-2-Using-Alt-Enter-to-create-a-test-class-with-this-normal-class" class="headerlink" title="Step 2:  Using Alt + Enter to create a test class with this normal class"></a>Step 2:  Using Alt + Enter to create a test class with this normal class</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-3.png" alt></p>
<h3 id="Step-3-Write-some-codes-to-test-path-coverage"><a href="#Step-3-Write-some-codes-to-test-path-coverage" class="headerlink" title="Step 3:  Write some codes to test path coverage"></a>Step 3:  Write some codes to test path coverage</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-4.png" alt></p>
<h3 id="Step-4-Run-with-code-coverage"><a href="#Step-4-Run-with-code-coverage" class="headerlink" title="Step 4: Run with code coverage"></a>Step 4: Run with code coverage</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-5.png" alt></p>
<blockquote>
<p>One useful tip: You could draw a decision tree to find how many test cases you need create when you analyse combination of if statements!</p>
</blockquote>
<h2 id="How-to-calculate-Cyclomatic-Complexity"><a href="#How-to-calculate-Cyclomatic-Complexity" class="headerlink" title="How to calculate Cyclomatic Complexity"></a>How to calculate Cyclomatic Complexity</h2><ul>
<li>Draw a Control flow graph already</li>
<li>cc = Numbers of Edges - Numbers of  Node + 2</li>
<li>or cc = Number of condition clause + 1</li>
</ul>
<h2 id="Basis-Path"><a href="#Basis-Path" class="headerlink" title="Basis Path"></a>Basis Path</h2><ul>
<li>Independent path through the code</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-introduction</title>
    <url>/2020/10/11/softeware-testing-notes-1/</url>
    <content><![CDATA[<h2 id="Errors-Faults-and-Failures"><a href="#Errors-Faults-and-Failures" class="headerlink" title="Errors, Faults and Failures"></a>Errors, Faults and Failures</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-1-1.png" alt></p>
<ul>
<li>Error - A problem that is introduced into a system during development.</li>
<li>Faults - A result of error.(maybe something is missing, or incorrect execution)</li>
<li>Failures - The result when a fault executes.</li>
<li>Incidents - The symptoms(症状) that indicates that there is a fault.</li>
</ul>
<h2 id="Some-correct-descriptions-of-Test-Cases"><a href="#Some-correct-descriptions-of-Test-Cases" class="headerlink" title="Some correct descriptions of Test Cases"></a>Some correct descriptions of Test Cases</h2><ul>
<li>A test case is requires a description of the inputs to a system.</li>
<li>A test case is requires a description of the outputs from a system.</li>
<li>Each test case should be identifiable, e.g. assigned a Test ID.</li>
</ul>
<h2 id="Some-topics-which-are-considered-‘good-enough’-for-Testing"><a href="#Some-topics-which-are-considered-‘good-enough’-for-Testing" class="headerlink" title="Some topics which are considered ‘good enough’ for Testing"></a>Some topics which are considered ‘good enough’ for Testing</h2><ul>
<li>Test early and test often</li>
<li>Integrate development and testing lifecycles</li>
<li>Formalize the testing methodology</li>
<li>Develop a comprehensive test plan</li>
<li>Use static and dynamic testing</li>
<li>Balancing time, money and quality</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>做算法题的小技巧</title>
    <url>/2020/10/10/algorithm-1/</url>
    <content><![CDATA[<blockquote>
<p>在写算法题的过程中总结的一些经验和技巧，</p>
<p>希望有一天leet coin可以5000+！</p>
</blockquote>
<h2 id="java输入输出问题"><a href="#java输入输出问题" class="headerlink" title="java输入输出问题"></a>java输入输出问题</h2><h3 id="BufferedReader和Scanner"><a href="#BufferedReader和Scanner" class="headerlink" title="BufferedReader和Scanner"></a>BufferedReader和Scanner</h3><ul>
<li><p>首先明确一点BufferedReader的读取速度是要快于Scanner的，因为BufferedReader有缓冲区，默认大小为8kb，足够算法题的输入使用。</p>
</li>
<li><p>BufferedReader的缺点就是只能读入字符，如果要读取数字需要进行转换，readLine()根据enter键读取下一个输入。</p>
</li>
<li><p>Scanner的优点就是可以读入数字和字符，不需要转换(nextInt() | nextLine() | nextLong() …)，next()根据enter、空格、Tab键读取下一个输入。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入：hello world</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.print(br.readLine()); <span class="comment">// print&gt; hello world</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(in.next()); <span class="comment">// print&gt; hello</span></span><br><span class="line">System.out.print(in.nextLine()); <span class="comment">// print&gt; hello world</span></span><br></pre></td></tr></table></figure>
<h3 id="BufferedWriter和System-out"><a href="#BufferedWriter和System-out" class="headerlink" title="BufferedWriter和System.out"></a>BufferedWriter和System.out</h3><ul>
<li>和BufferedReader一样，BufferedWriter也是缓冲流，将字符先写入缓冲区，调用flush方法之后，将字符输出。</li>
<li>System.out是标准的字符输出流，可以直接将字符输出，并自动flush</li>
<li>BufferedWriter比System.out的写速度要快<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出hello world</span></span><br><span class="line">System.out.print(<span class="string">"hello world"</span>); <span class="comment">// &gt;&gt; hello world</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">bw.write(<span class="string">"hello world"</span>); <span class="comment">// &gt;&gt; </span></span><br><span class="line">bw.flush(); <span class="comment">// &gt;&gt; hello world</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>BufferedWriter.write(int c) 输出乱码问题解决方案：</p>
<p>API中对于BufferedWriter的write(int c)解释为“Writes a single character”，所以其实写入的数据类型为char，内存长度只有2个字节，而且是以Unicode编码，所以会出现乱码。</p>
<p>故需要先将int强转为Integer, 再wirte(c.toString())即可。</p>
</blockquote>
<h3 id="写算法题的输入输出范例"><a href="#写算法题的输入输出范例" class="headerlink" title="写算法题的输入输出范例"></a>写算法题的输入输出范例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        String input = br.readLine();</span><br><span class="line">        String output = operate(input); <span class="comment">//operate看作是解决算法问题的方法</span></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        bw.write(output);</span><br><span class="line">        </span><br><span class="line">        bw.flush(); <span class="comment">//必须刷新缓冲区，否则无法打印结果</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果输出是浮点数，且要保留精度，或者格式化输出，还是使用System.out.printf;</p>
<p>可以使用bw.newLine()输出一个换行符。</p>
</blockquote>
<h2 id="算法小技巧"><a href="#算法小技巧" class="headerlink" title="算法小技巧"></a>算法小技巧</h2><h3 id="求最大公约数-辗转相除法"><a href="#求最大公约数-辗转相除法" class="headerlink" title="求最大公约数(辗转相除法)"></a>求最大公约数(辗转相除法)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = n, b = m; <span class="comment">//n和m是实际问题中的两个整数</span></span><br><span class="line"><span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> r = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a; <span class="comment">//此时a就是n,m的最大公约数</span></span><br></pre></td></tr></table></figure>
<h3 id="求最小公倍数"><a href="#求最小公倍数" class="headerlink" title="求最小公倍数"></a>求最小公倍数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a和b的最小公倍数 = a*b / a和b的最大公约数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||最小二乘法</title>
    <url>/2020/10/09/mathAnalysis-5-4/</url>
    <content><![CDATA[<h1 id="最小二乘法-多项式拟合曲线"><a href="#最小二乘法-多项式拟合曲线" class="headerlink" title="最小二乘法(多项式拟合曲线)"></a>最小二乘法(多项式拟合曲线)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在函数类$\Phi=span [\phi_0(x),\phi_1(x),\cdots,\phi_n(x)]$中找到一个函数,使得拟合函数和原函数的误差向量的二范数达到最小.</p>
<h2 id="多项式拟合函数-1-x-x-2-cdots-x-n"><a href="#多项式拟合函数-1-x-x-2-cdots-x-n" class="headerlink" title="多项式拟合函数($1,x,x^2,\cdots,x^n$)"></a>多项式拟合函数($1,x,x^2,\cdots,x^n$)</h2><script type="math/tex; mode=display">
\phi(x)=a_0\phi_0(x)+a_1\phi_1(x)+\cdots+a_n\phi_n(x)</script><p>只需要求出系数$a_0,a_1,\cdots,a_n$即可求出拟合曲线</p>
<h2 id="正则方程组"><a href="#正则方程组" class="headerlink" title="正则方程组"></a>正则方程组</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201009/image-20200611221402561.png" alt="image-20200611221402561"></p>
<p>$(\phi_0,\phi_1)=\rho\phi_0\phi_1$</p>
<h2 id="构造最小二乘法的一些思路"><a href="#构造最小二乘法的一些思路" class="headerlink" title="构造最小二乘法的一些思路"></a>构造最小二乘法的一些思路</h2><ul>
<li>如果离散节点构成的函数图像不是多项式函数,而是指数函数,可以采用取对数的方式来化成多项式函数求值!</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||牛顿插值多项式</title>
    <url>/2020/10/09/mathAnalysis-5-3/</url>
    <content><![CDATA[<h1 id="牛顿插值多项式"><a href="#牛顿插值多项式" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h1><h2 id="差商"><a href="#差商" class="headerlink" title="差商"></a>差商</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>一阶差商：$f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}$</li>
<li>二阶差商：$f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}$</li>
<li>k阶差商以此类推</li>
</ul>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>$f[x_0,x_1,\cdots,x_k]=\sum_{j=0}^k\frac{1}{\omega’_{k+1}(x_j)}f(x_j)$</li>
<li>差商对节点具有对称性</li>
<li>n次多项式$f(x)$的k阶差商$f[x_0,x_1,\cdots,x_{k-1},x]$,当$k\le n$时，是一个关于x的n-k次多项式，当$k&gt;n$时，恒等于0.</li>
<li>若$f(x)$具有k阶连续导数，则：$f[x_0,x_1,\cdots,x_k]=\frac{f^{(k)}(\xi)}{k!}$</li>
</ol>
<h2 id="牛顿插值多项式-1"><a href="#牛顿插值多项式-1" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>$N_n(x)=f(x_0)+f[x_0,x_1]\omega_1(x)+f[x_0,x_1,x_2]\omega_2(x)+\cdots+f[x_0,x_1,\cdots,x_n]\omega_n(x)$</p>
<h3 id="余项"><a href="#余项" class="headerlink" title="余项"></a>余项</h3><p>$R_n(x)=f[x,x_0,x_1,\cdots,x_n]\omega_{n+1}(x)=\frac{f^{(n+1)}(\zeta)}{(n+1)!}\omega_{n+1}(x)$</p>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||分段插值多项式</title>
    <url>/2020/10/09/mathAnalysis-5-2/</url>
    <content><![CDATA[<h1 id="分段插值多项式"><a href="#分段插值多项式" class="headerlink" title="分段插值多项式"></a>分段插值多项式</h1><h2 id="Runge现象"><a href="#Runge现象" class="headerlink" title="Runge现象"></a>Runge现象</h2><ul>
<li>高次的插值函数的近似效果越差,以致完全失真,这个现象称为Runge现象.(高次插值数值不稳定)</li>
</ul>
<h2 id="分段线性插值"><a href="#分段线性插值" class="headerlink" title="分段线性插值"></a>分段线性插值</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><script type="math/tex; mode=display">
S_1(x)=\frac{x_i-x}{h_i}y_{i-1}+\frac{x-x_{i-1}}{h_i}y_i, x \in [x_{i-1},x_i]</script><h3 id="插值余项"><a href="#插值余项" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">
f(x)-S_1(x)=\frac{f''(\xi)}{2!}(x-x_{i-1})(x-x_i)\le\frac{M_2}{8}h^2</script><h2 id="分段二次插值"><a href="#分段二次插值" class="headerlink" title="分段二次插值"></a>分段二次插值</h2><h3 id="插值余项-1"><a href="#插值余项-1" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">
f(x)-S_2(x)=\frac{f'''(\xi)}{3!}(x-x_{i-1})(x-x_{i-\frac{1}{2}})(x-x_i)\le \frac{M_3}{72\sqrt3}h^3</script><h2 id="分段Hermite插值"><a href="#分段Hermite插值" class="headerlink" title="分段Hermite插值"></a>分段Hermite插值</h2><h3 id="插值余项-2"><a href="#插值余项-2" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">
f(x)-H_3(x)=\frac{f^{(4)}(\xi)}{4!}(x-x_{i-1})^2(x-x_i)^2\le \frac{M_4}{384}h^2(h^4?)</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||插值的定义</title>
    <url>/2020/10/09/mathAnalysis-5-1/</url>
    <content><![CDATA[<h1 id="插值的定义"><a href="#插值的定义" class="headerlink" title="插值的定义"></a>插值的定义</h1><h2 id="插值条件"><a href="#插值条件" class="headerlink" title="插值条件"></a>插值条件</h2><ul>
<li><p>设函数$f(x)$在区间$[a,b]$上连续，给定$n+1$个节点，$a\le x_0&lt;x_1…&lt;x_n\le b$。</p>
</li>
<li><p>已知$f(x_k)=y_k(k=0,1,…n)$,在函数类P中寻找一函数$\phi(x)$作为$f(x)$的近似表达式，使满足：</p>
<p>$\phi(x_k)=f(x_k)=y_k,k=0,1,…,n$</p>
<p>注：$\phi(x)$为插值函数，函数类P为多项式函数类</p>
</li>
</ul>
<h2 id="插值定理"><a href="#插值定理" class="headerlink" title="插值定理"></a>插值定理</h2><ul>
<li>如果$n+1$个节点互不相等，则存在唯一的一个插值函数$p_n(x)$。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第四章||牛顿迭代法</title>
    <url>/2020/10/09/mathAnalysis-4-3/</url>
    <content><![CDATA[<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><h2 id="Newton-迭代格式"><a href="#Newton-迭代格式" class="headerlink" title="Newton 迭代格式"></a>Newton 迭代格式</h2><ul>
<li>迭代格式（切线法）：$x_{k+1}=x_k-\frac{f(x_k)}{f^{‘}(x_k)}$</li>
<li>$\phi’(x)=\frac{f(x)f’’(x)}{(f’(x))^2}$</li>
</ul>
<h2 id="Newton-迭代法的收敛性"><a href="#Newton-迭代法的收敛性" class="headerlink" title="Newton 迭代法的收敛性"></a>Newton 迭代法的收敛性</h2><ul>
<li><p><strong>收敛阶：</strong>Newton 迭代法对于单根$\alpha$至少是平方阶收敛，Newton 迭代法对初值$x_0$的选取较为严格。</p>
</li>
<li><p><strong>定理：</strong>$\lim_{k\to\infty}\frac{x_{k+1}-\alpha}{(x_k-\alpha)^2}=\frac{f^{‘’}(\alpha)}{2f^{‘}(\alpha)}$</p>
</li>
</ul>
<h2 id="Newton-迭代法的变形"><a href="#Newton-迭代法的变形" class="headerlink" title="Newton 迭代法的变形"></a>Newton 迭代法的变形</h2><h3 id="简化-Newton-迭代法（线性收敛）"><a href="#简化-Newton-迭代法（线性收敛）" class="headerlink" title="简化 Newton 迭代法（线性收敛）"></a>简化 Newton 迭代法（线性收敛）</h3><ul>
<li>迭代格式：$x_{k+1}=x_k-\frac{f(x_k)}{M}\ ,k=0,1,2,\cdots$</li>
<li>$M通常取f^{‘}(x_o)$</li>
</ul>
<h3 id="割线法（该迭代法的收敛阶介于1和2之间）"><a href="#割线法（该迭代法的收敛阶介于1和2之间）" class="headerlink" title="割线法（该迭代法的收敛阶介于1和2之间）"></a>割线法（该迭代法的收敛阶介于1和2之间）</h3><ul>
<li>用<strong>函数$f(x)$的差商</strong>近似 Newton 迭代格式中的导数$f’（x）,即$</li>
<li>$f’(x)\approx\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$</li>
<li>Newton 迭代法可以修改为：$x_{k+1}=x_k-\frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1}),\ k=1,2,3,\cdots$</li>
</ul>
<h3 id="求方程重根的-Newton-迭代法（往往具有平方阶收敛）"><a href="#求方程重根的-Newton-迭代法（往往具有平方阶收敛）" class="headerlink" title="求方程重根的 Newton 迭代法（往往具有平方阶收敛）"></a>求方程重根的 Newton 迭代法（往往具有平方阶收敛）</h3><ul>
<li><strong>带参数m的迭代格式：</strong>$x_{k+1}=x_k-m\frac{f(x_k)}{f’(x_k)},\ k=0,1,2,\cdots$</li>
<li><strong>不带参数m的迭代格式：</strong>$x_{k+1}=x_k-\frac{u(x_k)}{u’(x_k)},\ k=0,1,2,\cdots \ ;u(x)=\frac{f(x)}{f’(x)}$</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第四章||二分法</title>
    <url>/2020/10/09/mathAnalysis-4-1/</url>
    <content><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li><p><strong>定义：</strong>设$[a,b]$为方程$f(x)=0$的有根区间。所谓二分法就是<strong>对有根区间</strong>$[a,b]$<strong>逐次分半</strong>，使得有根区间长度逐次缩小，从而得到根的近似值。</p>
</li>
<li><p><strong>步骤：</strong></p>
<script type="math/tex; mode=display">
①记a_0=a,\ b=b_0,\ 计算\ x_1=\frac{a+b}{2} \\</script><script type="math/tex; mode=display">
②若f(a_0)f(x_1)<0,\ 取\ a_1=a_0,\ b_1=x_1; \\</script><script type="math/tex; mode=display">
③若f(a_0)f(x_1)>0,\ 取\ a_1=x_1,\ b_1=b_0; \\</script><script type="math/tex; mode=display">
④则得到新的有根区间\ [a_1,b_1],\ 其区间长度恰好是\ [a_0,b_0]\ 长度的一半; \\</script><script type="math/tex; mode=display">
⑤重复上述操作，直至根的近似值达到精度要求结束二分法。</script></li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第四章||简单迭代法</title>
    <url>/2020/10/09/mathAnalysis-4-2/</url>
    <content><![CDATA[<h1 id="简单迭代法"><a href="#简单迭代法" class="headerlink" title="简单迭代法"></a>简单迭代法</h1><h2 id="简单迭代法的一般形式"><a href="#简单迭代法的一般形式" class="headerlink" title="简单迭代法的一般形式"></a>简单迭代法的一般形式</h2><ul>
<li><strong>迭代格式：</strong>$x_{k+1}=\phi(x_k),\ \phi(x)称为迭代函数$</li>
</ul>
<h2 id="简单迭代法的收敛条件"><a href="#简单迭代法的收敛条件" class="headerlink" title="简单迭代法的收敛条件"></a>简单迭代法的收敛条件</h2><ul>
<li><p>收敛定理：</p>
<p>① 假设迭代函数$\phi(x)$在区间$[a,b]$上可导，且满足条件：</p>
<p>② $a\le \phi(x) \le b,\ x\in[a,b]$</p>
<p>③ 存在正数$L &lt; 1,$使对任意 $x \in [a,b]$ 有 $|\phi^{‘}(x)|\le L &lt; 1$</p>
</li>
</ul>
<h2 id="简单迭代法的收敛阶"><a href="#简单迭代法的收敛阶" class="headerlink" title="简单迭代法的收敛阶"></a>简单迭代法的收敛阶</h2><ul>
<li><strong>一般格式：</strong>$\lim_{k\to \infty} \tfrac{|e_{k+1}|}{|e_k|^p}=C$</li>
<li>$p$为<strong>收敛阶</strong>，$C$为<strong>渐近误差常数</strong>。</li>
<li><strong>收敛阶的求法：</strong>$\phi^{‘}(\alpha)=\phi^{‘’}(\alpha)=\cdots=\phi^{(p-1)}(\alpha)=0,\ \phi^{(P)}(\alpha)\neq0,\ p\ge2$,则迭代法<strong>p阶收敛</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法常用模板</title>
    <url>/2020/10/06/algorithmTemplate-1/</url>
    <content><![CDATA[<ul>
<li>常用排序、二分、高精度、前缀和、差分、位运算、双指针、离散化、区间合并<a id="more"></a>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left-<span class="number">1</span>, j=right+<span class="number">1</span>, x=arr[(left+right)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(arr[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(arr[j] &gt; x);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    quickSort(arr, left, j);</span><br><span class="line">    quickSort(arr, j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left == right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(arr, left, mid);</span><br><span class="line">    mergeSort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//temp数组用于临时存放left到right的有序数列</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[k++] = arr[i++]; </span><br><span class="line">        <span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数依次放到temp数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right) temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    <span class="keyword">for</span>(i=left, j=<span class="number">0</span>; i &lt;= right; i++, j++) arr[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i]; <span class="comment">//找出第i小的元素，并放到数组的下标i中</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;min)&#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">       	<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">//将元素i插入到有序数列0,1,2...i-1中</span></span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]; j--)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找-两种情况"><a href="#二分查找-两种情况" class="headerlink" title="二分查找(两种情况)"></a>二分查找(两种情况)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) right = mid; <span class="comment">//满足区间在左半边</span></span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) left = mid; <span class="comment">//满足区间在右半边</span></span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：浮点数二分可以用于开n次方，也不用判断边界条件</span></span><br></pre></td></tr></table></figure>
<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">add</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A + B 数字均为逆序存储，例：12345被存储为54321</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//假设A&gt;B</span></span><br><span class="line">    <span class="keyword">if</span>(A.size() &lt; B.size())</span><br><span class="line">        <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果就是t%10的余数</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后一次加法如果还有进位就把t加到结果中</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">sub</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">  	<span class="comment">//假设A&gt;B,C = A - B</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t = A.get(i) - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t -= B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果有两种情况，一种是需要借位，一种是不需要</span></span><br><span class="line">        C.add((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算借位</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果可能为000123的情况，所以要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.get(C.size()-<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mul</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//A为高精度，b为低精度，C = Axb</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i)*b;</span><br><span class="line">        <span class="comment">//第i位的结果t % 10</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断最后一次计算是否有进位</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果b为0，计算结果可能为00000，故需要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> r; <span class="comment">//余数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">div</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A / b</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=A.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span>+A.get(i);</span><br><span class="line">       	<span class="comment">//第i位结果</span></span><br><span class="line">        C.add(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序存储</span></span><br><span class="line">    Collections.reverse(C);</span><br><span class="line">    <span class="comment">//结果可能为011，去除前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>]+a[<span class="number">2</span>]+...+a[i];</span><br><span class="line">a[l]~a[r]的和=S[r] - S[l-<span class="number">1</span>]; <span class="comment">//a[0] = 0; S[0] = 0</span></span><br></pre></td></tr></table></figure>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S[i][j]为第i行j列左上部分所有元素的和</span><br><span class="line">求左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的和：</span><br><span class="line">A = S[x2][y2] - S[x1-<span class="number">1</span>][y2] - S[x2][y1-<span class="number">1</span>] + S[x1-<span class="number">1</span>][y1-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">已知a[], b[],b[]为a[]的差分数组，即a[i] = b[<span class="number">0</span>]+b[<span class="number">1</span>]+...+b[i];</span><br><span class="line">给下标区间为[l,r]的a[]都加上常数c &lt;=&gt; b[l] += c, b[r+<span class="number">1</span>] -= c;</span><br></pre></td></tr></table></figure>
<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的每一个元素加上c(先构造差分矩阵再插入)</span><br><span class="line">&lt;=&gt; </span><br><span class="line">b[x1][y1] += c,</span><br><span class="line">b[x1][y2+<span class="number">1</span>] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y1] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求n的第k位数字（n为二进制表示形式）</span></span><br><span class="line">n &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//返回n的最后一位1（n为二进制表示形式）</span></span><br><span class="line">lowbit(n) <span class="keyword">return</span> n &amp; -n;</span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="comment">// check(i, j) 表示根据题意设定的维护双指针的条件</span></span><br><span class="line">    <span class="keyword">while</span>(check(i, j)) j++;</span><br><span class="line">    <span class="comment">// 根据题意具体的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常见的问题有两类：<ul>
<li>对于一个序列，用两个指针维护一段区间</li>
<li>对于两个序列，维护某种次序，比如归并排序中合并两个子序列</li>
</ul>
</li>
</ul>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; alls; <span class="comment">//存储所有待离散化的值（已去重）</span></span><br><span class="line">List&lt;Integer&gt; allList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">allList.addAll(alls);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(allList, (a1, a2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (Integer)a1 - (Integer)a2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果要使用前缀和，返回值+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=allList.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(allList.get(mid) &gt;= x) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span>; <span class="comment">//映射到1,2,...,n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先将区间序列按照左端点排好序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = a;</span><br><span class="line">        <span class="keyword">this</span>.second = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设list已经排好序,list.size() &gt;= 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Pair&gt; <span class="title">merge</span><span class="params">(List&lt;Pair&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Pair&gt; res = <span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line">    <span class="comment">//先将第一个区间加到res中</span></span><br><span class="line">    res.add(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//判断两个区间是否有交集</span></span><br><span class="line">        <span class="keyword">if</span>(res.get(res.size()-<span class="number">1</span>).second &lt; list.get(i).first)&#123;</span><br><span class="line">            <span class="comment">//没有，直接加</span></span><br><span class="line">            res.add(list.get(i));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有，判断区间左端点是谁</span></span><br><span class="line">            <span class="keyword">int</span> second = res.get(res.size()-<span class="number">1</span>).second;</span><br><span class="line">            <span class="keyword">int</span> nSecond = list.get(i).second;</span><br><span class="line">            res.get(res.size()-<span class="number">1</span>).second = (second &gt; nSecond) ? second : nSecond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>二分查找</tag>
        <tag>高精度</tag>
        <tag>前缀和与差分</tag>
        <tag>位运算</tag>
        <tag>双指针</tag>
        <tag>离散化</tag>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;三种迭代法的矩阵表示形式</title>
    <url>/2020/10/05/mathAnalysis-3-4/</url>
    <content><![CDATA[<h1 id="三种迭代法的矩阵表示形式（-Ax-b-）"><a href="#三种迭代法的矩阵表示形式（-Ax-b-）" class="headerlink" title="三种迭代法的矩阵表示形式（$Ax= b$）"></a>三种迭代法的矩阵表示形式（$Ax= b$）</h1><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">
假设A=D-L-U,D为对角矩阵， \\</script><script type="math/tex; mode=display">
-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">
(D-L-U)x = b \\
\Rightarrow Dx = (L+U)x+b \\</script><script type="math/tex; mode=display">
\Rightarrow x = D^{-1}(L+U)x+D^{-1}b \\
\Rightarrow x^{(k+1)} = D^{-1}(L+U)x^{k}+D^{-1}b</script><a id="more"></a>
<ul>
<li><strong>迭代矩阵：</strong>$B=D^{-1}(L+U)$</li>
</ul>
<h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><script type="math/tex; mode=display">
假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">
-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">
(D-L-U)x = b \\
\Rightarrow Dx = Lx + Ux + b \\</script><script type="math/tex; mode=display">
\Rightarrow Dx^{(k+1)} = Lx^{(k+1)}+Ux^k+b \\
\Rightarrow (D-L)x^{(k+1)} = Ux^k+b \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = (D-L)^{-1}Ux^k+(D-L)^{-1}b</script><ul>
<li><strong>迭代矩阵：</strong>$G=(D-L)^{-1}U$</li>
</ul>
<h2 id="SOR迭代法"><a href="#SOR迭代法" class="headerlink" title="SOR迭代法"></a>SOR迭代法</h2><script type="math/tex; mode=display">
假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">
L为缺少对角线元素的下三角矩阵，U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">
(D-L-U)x = b\\</script><script type="math/tex; mode=display">
\Rightarrow x = x +[b-(D-L-U)x] \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = x^{k} + D^{-1}[b-(D-L-U)x^{k}],J迭代格式 \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = x^k + D^{-1}[b+(U-D)x^k+Lx^{(k+1)}],G-S迭代格式 \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = x^k + \omega D^{-1}[b+(U-D)x^k+Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">
\Rightarrow Dx^{(k+1)} = Dx^k+[\omega b+ \omega(U-D)x^k+\omega Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">
\Rightarrow (D-\omega L)x^{(k+1)} = [D(1-\omega)+\omega U]x^k + \omega b \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]x^k + \omega(D-\omega L)^{-1}b</script><ul>
<li><strong>迭代矩阵：</strong>$L_{\omega} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]$</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;SOR迭代法</title>
    <url>/2020/10/05/mathAnalysis-3-3/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul>
<li>Jacobi迭代法的实质是用当前的迭代值加上一个修正量来得到一个新的迭代值，结合J迭代法和GS迭代法以及修正量的思想引入<strong>SOR迭代法</strong>。<a id="more"></a>
</li>
</ul>
<h2 id="SOR迭代法的表达式"><a href="#SOR迭代法的表达式" class="headerlink" title="SOR迭代法的表达式"></a>SOR迭代法的表达式</h2><ul>
<li><p>$x^{(k+1)}_i=x_i^{(k)}+\frac{\omega}{a_{ii}}(b_i - \sum^{i-1}_{j=1}a_{ij}x_j^{(k+1)}-\sum^n_{j=i}a_{ij}x_j^{(k)})$</p>
<p>$i=1,2,\cdots,n,\quad k=0,1,\cdots$</p>
</li>
<li><p>$\omega$称作<strong>松弛因子</strong>，当$\omega &lt; 1$时，此迭代称为<strong>欠松弛迭代</strong>，$\omega&gt;1$时，称为<strong>超松弛迭代</strong>。</p>
</li>
</ul>
<h2 id="SOR迭代法的判定定理"><a href="#SOR迭代法的判定定理" class="headerlink" title="SOR迭代法的判定定理"></a>SOR迭代法的判定定理</h2><ul>
<li><strong>定理一</strong>：SOR方法收敛的<strong>充分必要条件</strong>是 $\rho(M_\omega)&lt;1$；收敛的<strong>充分</strong>条件为 $||M_\omega||&lt;1$。（$M_\omega$为迭代矩阵）</li>
<li><strong>定理二</strong>：SOR方法收敛的<strong>必要条件</strong>是：$0&lt;\omega&lt;2$。</li>
<li><strong>定理三</strong>：设系数矩阵$A$是对称正定的，且 $0&lt;\omega&lt;2$，则SOR方法收敛。</li>
<li><strong>定理四</strong>：当系数矩阵$A$是$\alpha-$严格对角占优矩阵，且 $0&lt;w \le1$，SOR方法收敛。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;Jacobi迭代法和Gauss-Seidel迭代法</title>
    <url>/2020/10/05/mathAnalysis-3-2/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>以该线性方程组为例，介绍几种线性方程组的数值解法</li>
<li><script type="math/tex; mode=display">\left\{  \begin{array}{c}    a_{11}x_1+a_{12}x_2+a_{13}x_3=b_1 \\     a_{21}x_1+a_{22}x_2+a_{23}x_3=b_2 \\     a_{31}x_1+a_{32}x_2+a_{33}x_3=b_3 \end{array} \right.</script></li>
</ul>
<a id="more"></a>
<h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">
\left\{
\begin{array}{c}
x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\
x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k)}-a_{23}x_3^{(k)}) \\
x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k)}-a_{32}x_3^{(k)})
\end{array}
\right.</script><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><ul>
<li>由Jacobi迭代公式我们可知，在计算$x_2^{(k+1)}$时，此时$x_1^{(k+1)}$已经计算出；在计算$x_3^{(k+1)}$时，$x_1^{(k+1)},x_2^{(k+1)}$也已经计算出。为了充分利用这些数据便有了Gauss-Seidel迭代法：</li>
</ul>
<script type="math/tex; mode=display">
\left\{
\begin{array}{c}
x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\
x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k+1)}-a_{23}x_3^{(k)}) \\
x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k+1)}-a_{32}x_3^{(k+1)})
\end{array}
\right.</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;迭代法的收敛性</title>
    <url>/2020/10/05/mathAnalysis-3-1/</url>
    <content><![CDATA[<h2 id="迭代法的一般形式"><a href="#迭代法的一般形式" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h2><h3 id="线性方程组的等价形式"><a href="#线性方程组的等价形式" class="headerlink" title="线性方程组的等价形式"></a>线性方程组的等价形式</h3><ul>
<li>$Ax=b \Leftrightarrow x = Mx+g$<ul>
<li>$M$成为迭代矩阵，$g$为某一向量<a id="more"></a>
</li>
</ul>
</li>
</ul>
<h3 id="迭代法的一般形式-1"><a href="#迭代法的一般形式-1" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h3><ul>
<li>$x^{(k+1)}=Mx^{(k)}+g$</li>
</ul>
<h2 id="迭代法收敛的判定定理"><a href="#迭代法收敛的判定定理" class="headerlink" title="迭代法收敛的判定定理"></a>迭代法收敛的判定定理</h2><ul>
<li><strong>定理一</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分必要条件</strong>是迭代矩阵$M$的谱半径 $\rho(M)&lt;1$。</li>
<li><strong>定理二</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分条件</strong>是 $||M||&lt;1$。</li>
<li><strong>补充：</strong>当迭代方法的迭代矩阵谱半径$\rho(M)&lt;1$时，谱半径越小，迭代方法的收敛速度越快。</li>
</ul>
<h2 id="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"><a href="#Jacobi迭代法和Gauss-Seidel迭代法的收敛性" class="headerlink" title="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"></a>Jacobi迭代法和Gauss-Seidel迭代法的收敛性</h2><h3 id="严格对角占优矩阵"><a href="#严格对角占优矩阵" class="headerlink" title="严格对角占优矩阵"></a>严格对角占优矩阵</h3><script type="math/tex; mode=display">
设n阶A=(a_{ij})，如果A的元素满足:</script><script type="math/tex; mode=display">
\sum^n_{j=1 \\ 
j\neq i}|a_{ij}| < |a_{ii}|,\ i=1,2,\cdots,n \\
则称A是严格对角占优矩阵</script><h3 id="判定定理"><a href="#判定定理" class="headerlink" title="判定定理"></a>判定定理</h3><ul>
<li><p><strong>定理一</strong>：设$A$是严格对角占优矩阵，则解方程组$Ax=b$的$J$迭代法和$GS$迭代法均收敛。</p>
</li>
<li><p><strong>定理二</strong>：设$A$是对称正定矩阵，则解方程组$Ax=b$的$GS$迭代法是收敛的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;线性方程组的固有性态</title>
    <url>/2020/10/05/mathAnalysis-2-6/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>由于原始数据微小变化而导致解严重失真的方程组称为<strong>病态方程组</strong>，相应的系数矩阵称为<strong>病态矩阵</strong>。</li>
<li>使用<strong>条件数</strong>来判定线性方程组是否<strong>病态</strong>。<a id="more"></a>
</li>
</ul>
<h2 id="条件数"><a href="#条件数" class="headerlink" title="条件数"></a>条件数</h2><ul>
<li>$Cond(A)=||A||\  ||A^{-1}||$</li>
<li>经常使用的条件数: $Cond_p(A)=||A||_p \  ||A^{-1}||_p,\  p=1,2,\infty$</li>
<li>当$A$为<strong>对称矩阵</strong>时, 可有</li>
</ul>
<script type="math/tex; mode=display">
Cond_2(A)=\frac{|\lambda|_{max}}{|\lambda|_{min}}</script><ul>
<li>通常用<strong>条件数过大</strong>来判定方程组是病态方程组</li>
</ul>
<h2 id="逆矩阵的求法"><a href="#逆矩阵的求法" class="headerlink" title="逆矩阵的求法"></a>逆矩阵的求法</h2><ul>
<li>$(A,E) \Rightarrow 经过初等行变换得 (E, A^{-1})$</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;范数</title>
    <url>/2020/10/05/mathAnalysis-2-5/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul>
<li>为了对线性方程组的性态和其数值解进行分析，故引入范数来表示。<a id="more"></a>
</li>
</ul>
<h2 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>假设$||\cdot||$为向量空间$R^n$的实值函数，且满足以下三个条件：</li>
<li><strong>非负性：</strong>对于任何向量$x\in R^n$，$||x||\ge 0$，且$||x||=0$当且仅当$x=0$</li>
<li><strong>齐次性：</strong>对于任何实数$\alpha$和向量$x\in R^n$，$||\alpha x||=|\alpha|||x||$</li>
<li><strong>三角不等式：</strong>对于任何向量$x,y\in R^n$，$||x+y||\le||x||+||y||$</li>
</ul>
<p>则称$||\cdot||$为向量空间$R^n$上的范数，$||x||$为向量$x$的范数</p>
<h3 id="常用的三个向量范数"><a href="#常用的三个向量范数" class="headerlink" title="常用的三个向量范数"></a>常用的三个向量范数</h3><ul>
<li>向量1-范数：$||x||_1=\sum^n_{i=1}|x_i|$</li>
<li>向量2-范数：$||x||_2=(\sum^n_{i=1}x_i^2)^{\frac{1}{2}}$(向量的模)</li>
<li>向量$\infty$-范数：$||x||_\infty=max_{1\le i\le n}|x_i|$</li>
</ul>
<h3 id="范数的等价性以及常用的等价公式"><a href="#范数的等价性以及常用的等价公式" class="headerlink" title="范数的等价性以及常用的等价公式"></a>范数的等价性以及常用的等价公式</h3><ul>
<li><p><strong>范数的等价性：</strong>对于$R^n$空间上的任意两个范数$||\cdot||_\alpha$和$||\cdot||_\beta$，存在正常数$m,M$，使得：</p>
<p>$m||x||_\beta \le ||x||_\alpha \le M||x||_\beta, \forall x \in R^n$</p>
</li>
<li><p><strong>常用的等价公式：</strong></p>
<p>$||x||_\infty \le ||x||_1 \le n||x||_\infty$</p>
<p>$||x||_\infty \le ||x||_2 \le \sqrt n||x||_\infty$</p>
<p>$||x||_2 \le ||x||_1 \le \sqrt n||x||_2$</p>
</li>
</ul>
<h2 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>与向量范数定义类似，除去向量范数满足的三个条件以外，还要满足第四个条件：</li>
<li>$||AB|| \le ||A||||B||$</li>
<li>满足四个条件则称$||A||$为$A$的范数</li>
</ul>
<h3 id="四个常用的矩阵范数"><a href="#四个常用的矩阵范数" class="headerlink" title="四个常用的矩阵范数"></a>四个常用的矩阵范数</h3><ul>
<li>矩阵的1-范数（列范数）：$||A||_1=max_{1\le j\le n}\sum_{i=1}^n|a_{ij}|$</li>
<li>矩阵的2-范数（谱范数）：$||A||_2=(A^TA的最大特征值)^{\frac{1}{2}}$</li>
<li>矩阵的$\infty$-范数（行范数）：$||A||_\infty=max_{1\le i \le n}\sum_{j=1}^n|a_{ij}|$</li>
<li>矩阵的F-范数：$||A||_F=(\sum_{i,j=1}^n|a_{ij}|^2)^{\frac{1}{2}}$</li>
</ul>
<p>识记：1是竖着的所以一范数是列范数，$\infty$范数是横着的所以是行范数。</p>
<h3 id="矩阵相容范数的判定"><a href="#矩阵相容范数的判定" class="headerlink" title="矩阵相容范数的判定"></a>矩阵相容范数的判定</h3><ul>
<li>$||Ax||\le ||A||\  ||x||,\  \forall x \in R^n$</li>
</ul>
<h3 id="谱半径"><a href="#谱半径" class="headerlink" title="谱半径"></a>谱半径</h3><ul>
<li>$\rho(A)=max_{1\le i \le n}|\lambda|$</li>
</ul>
<h3 id="特征值-lambda-的求法"><a href="#特征值-lambda-的求法" class="headerlink" title="特征值$\lambda$的求法"></a>特征值$\lambda$的求法</h3><ul>
<li>计算行列式: $|\lambda E - A| = 0$</li>
<li>特征值得和等于矩阵主对角线元素之和</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;追赶法</title>
    <url>/2020/10/05/mathAnalysis-2-4/</url>
    <content><![CDATA[<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul>
<li>追赶法是求三对角线性方程组的三角分解法。<a id="more"></a>
</li>
</ul>
<h2 id="矩阵：-A-TM"><a href="#矩阵：-A-TM" class="headerlink" title="矩阵：$A=TM$"></a>矩阵：$A=TM$</h2><script type="math/tex; mode=display">
A=\left[
\begin{matrix}
a_1 & c_1 \\
d_2 & a_2    & c_2 \\
    & \ddots & \ddots & \ddots \\
    &        & d_{n-1}& a_{n-1} & c_{n-1} \\
    &        &        & d_n     & a_n      \\
\end{matrix}
\right]</script><h2 id="三对角矩阵-A-的各阶顺序主子式不为零的充要条件"><a href="#三对角矩阵-A-的各阶顺序主子式不为零的充要条件" class="headerlink" title="三对角矩阵$A$的各阶顺序主子式不为零的充要条件"></a>三对角矩阵$A$的各阶顺序主子式不为零的充要条件</h2><ul>
<li>$|a_1|&gt;|c_1|;|a_n|&gt;|d_n|;$</li>
<li>$|a_i|\ge |c_i|+|d_i|,c_id_i\neq0,i=2,3,…n-1$</li>
</ul>
<h2 id="追赶法的具体步骤"><a href="#追赶法的具体步骤" class="headerlink" title="追赶法的具体步骤"></a>追赶法的具体步骤</h2><ul>
<li>先求第一行，再求第二行，依次类推</li>
<li>每一行都是从左到右开始求解</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;平方根法</title>
    <url>/2020/10/05/mathAnyalsis-2-3/</url>
    <content><![CDATA[<h2 id="引入：对称正定矩阵"><a href="#引入：对称正定矩阵" class="headerlink" title="引入：对称正定矩阵"></a>引入：对称正定矩阵</h2><ul>
<li>矩阵各元素的各元素沿主对角线对称</li>
<li>矩阵的所有特征值均大于零</li>
</ul>
<a id="more"></a>
<h2 id="平方根法的使用条件"><a href="#平方根法的使用条件" class="headerlink" title="平方根法的使用条件"></a>平方根法的使用条件</h2><ul>
<li>$A$为对称正定矩阵，且$U_{kk}&gt;0$。</li>
</ul>
<h2 id="平方根法的步骤"><a href="#平方根法的步骤" class="headerlink" title="平方根法的步骤"></a>平方根法的步骤</h2><ul>
<li>$A=UU^T$,只需要计算$U$即可。</li>
<li>计算顺序：计算下三角矩阵$U$的第一列、第二列……依此类推。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;直接三角分解法</title>
    <url>/2020/10/05/mathAnalysis-2-2/</url>
    <content><![CDATA[<h2 id="定义（顺序Gauss消去法的矩阵形式）"><a href="#定义（顺序Gauss消去法的矩阵形式）" class="headerlink" title="定义（顺序Gauss消去法的矩阵形式）"></a>定义（顺序Gauss消去法的矩阵形式）</h2><ul>
<li>将系数矩阵$A$分解成$A=LU$（单位下三角矩阵$L$和上三角矩阵$U$）</li>
</ul>
<script type="math/tex; mode=display">
Ax=b\Rightarrow
\begin{cases}
Ux=y \\
Ly=b
\end{cases}</script><a id="more"></a>
<ul>
<li>充要条件$A$的各阶顺序主子式不为零</li>
</ul>
<h2 id="获取-L-矩阵和-U-矩阵的方法"><a href="#获取-L-矩阵和-U-矩阵的方法" class="headerlink" title="获取$L$矩阵和$U$矩阵的方法"></a>获取$L$矩阵和$U$矩阵的方法</h2><ul>
<li>先求$U$矩阵的第一行，再求$L$矩阵的第一列，以此类推。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;顺序Gauss消去法</title>
    <url>/2020/03/11/mathAnalysis-2-1/</url>
    <content><![CDATA[<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>将线性方程组的增广矩阵，只通过行变换，将增广矩阵化简成一个上三角矩阵。再从增广矩阵的最后一行开始依次回代，求出解向量。<a id="more"></a>
</li>
</ul>
<h2 id="算法成立的充要条件"><a href="#算法成立的充要条件" class="headerlink" title="算法成立的充要条件"></a>算法成立的充要条件</h2><ul>
<li>主元素不为零$\Leftrightarrow$系数矩阵的各阶主子式都不为零</li>
<li>主元素：顺序Gauss消去法中的$a_{kk}^{(k)},(k=1,2,…n)$。</li>
</ul>
<h2 id="列主元Gauss消去法"><a href="#列主元Gauss消去法" class="headerlink" title="列主元Gauss消去法"></a>列主元Gauss消去法</h2><ul>
<li>在顺序Gauss消去法的基础上，在每一步消元之前，在主元所在的列选取绝对值最大的元素作为主元素。</li>
<li>充要条件：$|A|\neq0$ </li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第一章&gt;&gt;误差分析</title>
    <url>/2020/03/11/mathAnalysis-1-1/</url>
    <content><![CDATA[<h2 id="误差的来源与分类"><a href="#误差的来源与分类" class="headerlink" title="误差的来源与分类"></a>误差的来源与分类</h2><ul>
<li>观测误差</li>
<li>模型误差</li>
<li>截断误差：近似计算出现的误差<a id="more"></a></li>
<li>舍入误差：由于计算级只能进行有限位的运算而产生的误差</li>
<li>绝对误差:  $e=x^{*}-x$ 其中e为绝对误差<br>如果$\epsilon$满足：<br>  $|e|\leq\epsilon$, 则$\epsilon$为$x$的绝对误差限</li>
<li>相对误差：<br>  $e_r = \frac{x^* - x}{x} = \frac{e}{x}$, $e_r$为相对误差</li>
<li>相对误差限：<br>  $\epsilon_r=\frac{\epsilon}{|x|}$, $\epsilon_r$为相对误差限，同时$|e_r|\le\epsilon_r$</li>
</ul>
<h2 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a>有效数字</h2><ul>
<li>有效数字与绝对误差限的关系：<script type="math/tex; mode=display">
|x^*-x|\leq\frac{1}{2}\times10^{m-n},其中n为有效数字的位数。</script><script type="math/tex; mode=display">
m为x^*化为标准浮点数形式下的10m次幂。</script>注：精确值的有效数字有无穷多位！</li>
<li><p>有效数字和相对误差限的关系(其中$a_1$为$x$化为标准浮点数下小数点后第一个非零的数)：</p>
<ul>
<li><p>已知有效位数$n$:<br>  $\epsilon_r\le\frac{1}{2a_1}\times10^{-n+1}$</p>
</li>
<li><p>已知$x$的相对误差限:<br>  $\epsilon_r\le\frac{1}{2(a_1+1)}\times10^{-n+1}$</p>
</li>
</ul>
</li>
</ul>
<h2 id="数值计算中的若干原则"><a href="#数值计算中的若干原则" class="headerlink" title="数值计算中的若干原则"></a>数值计算中的若干原则</h2><ul>
<li>避免两个相近的数相减（使用其他算法，公式？乘除？）<script type="math/tex; mode=display">
假设z=x-y,z^*=x^*-y^*,那么：</script><script type="math/tex; mode=display">
e_r(z)=|\frac{x}{x-y}||e_r(x)|+|\frac{y}{x-y}||e_r(x)|</script><script type="math/tex; mode=display">
从该式中我们可以看出z的相对误差会特别大</script></li>
<li><p>防止“大数”吃掉小数（改变运算顺序？）</p>
</li>
<li><p>绝对值太小的数不宜做除数</p>
<script type="math/tex; mode=display">
  假设z=x \div y,z^* = x^* \div y^*,那么：</script><script type="math/tex; mode=display">
  e(z)=|z^*-z|=|\frac{y(x^*-x)+x(y-y^*)}{yy*}|\approx \frac{|y||e(x)|+|x||e(y)|}{y^2}​</script><p>  则如果$y$的绝对值太小，那么$z$的绝对误差较大</p>
</li>
<li><p>注意简化计算程序，减少计算次数（舍入误差的积累和计算的时间）</p>
</li>
<li><p>选用数值稳定性好的算法</p>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol>
<li><p>将下列表达式进行等价变形，使其数值计算结果较为精确。</p>
<p>(1) $\frac{1}{1-2x}-\frac{1+x}{1-x},|x|&lt;&lt;1$</p>
<p>解：$原式=\frac{2x^2}{(1-2x)(1-x)}$</p>
<p>(2)$\frac{1-e^x}{x},|x|&lt;&lt;1$</p>
<p>解：由$e^x$在x=0处的泰勒展开式可得：</p>
<p>$e^x= 1+x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2+R_n(x)$</p>
<p>所以</p>
<p>$\frac{1-e^x}{x}=\frac{x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2}{x}=1+\frac{1}{2!}x+\frac{1}{3!}x^2+…+\frac{1}{n!}x^{n-1}$</p>
</li>
<li><p>假设$f=(\sqrt{2}-1)^6,\sqrt{2}$取1.4，下列哪种计算方式的精确度最高。</p>
<p>(1)$\frac{1}{(\sqrt{2}+1)^6}\Rightarrow f(x)=\frac{1}{x^6}$</p>
<p>(2)$(3-2\sqrt2)^3 \Rightarrow f(x)=x^3$</p>
<p>(3)$\frac{1}{(3-2\sqrt2)^3} \Rightarrow f(x)=\frac{1}{x^3}$</p>
<p>(4)$99-70\sqrt2 \Rightarrow f(x)=99-70x$</p>
<p>解：使用函数的条件数$cond=|\frac{f^{‘}(x)x}{f(x)}|$</p>
<p>将$x=1.4$带入其中，可得(3)式的精确度最高。</p>
<p>注：条件数低为良态，条件数高为病态。   </p>
<h2 id="补充：-x-1x-2-的绝对误差限"><a href="#补充：-x-1x-2-的绝对误差限" class="headerlink" title="补充：$x_1x_2$的绝对误差限"></a>补充：$x_1x_2$的绝对误差限</h2></li>
</ol>
<p>$x_1\approx x_1,x_2\approx x_2$</p>
<script type="math/tex; mode=display">
|x_1x_2-x_1^*x_2^*|=|x_1x_2-x_1x_2^*+x_1x_2^*-x_1^*x_2^*|</script><script type="math/tex; mode=display">
\le|x_1||x_2-x_2^*|+|x_2^*||x_1-x_1^*|</script><script type="math/tex; mode=display">
    =|x_1||e(x_2)|+|x_2||e(x_1)|</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
</search>
