<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>做算法题的小技巧</title>
      <link href="/2020/10/10/algorithm-1/"/>
      <url>/2020/10/10/algorithm-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在写算法题的过程中总结的一些经验和技巧，</p><p>希望有一天leet coin可以5000+！</p></blockquote><h2 id="java输入输出问题"><a href="#java输入输出问题" class="headerlink" title="java输入输出问题"></a>java输入输出问题</h2><h3 id="BufferedReader和Scanner"><a href="#BufferedReader和Scanner" class="headerlink" title="BufferedReader和Scanner"></a>BufferedReader和Scanner</h3><ul><li><p>首先明确一点BufferedReader的读取速度是要快于Scanner的，因为BufferedReader有缓冲区，默认大小为8kb，足够算法题的输入使用。</p></li><li><p>BufferedReader的缺点就是只能读入字符，如果要读取数字需要进行转换，readLine()根据enter键读取下一个输入。</p></li><li><p>Scanner的优点就是可以读入数字和字符，不需要转换(nextInt() | nextLine() | nextLong() …)，next()根据enter、空格、Tab键读取下一个输入。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入：hello world</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.print(br.readLine()); <span class="comment">// print&gt; hello world</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(in.next()); <span class="comment">// print&gt; hello</span></span><br><span class="line">System.out.print(in.nextLine()); <span class="comment">// print&gt; hello world</span></span><br></pre></td></tr></table></figure><h3 id="BufferedWriter和System-out"><a href="#BufferedWriter和System-out" class="headerlink" title="BufferedWriter和System.out"></a>BufferedWriter和System.out</h3><ul><li>和BufferedReader一样，BufferedWriter也是缓冲流，将字符先写入缓冲区，调用flush方法之后，将字符输出。</li><li>System.out是标准的字符输出流，可以直接将字符输出，并自动flush</li><li>BufferedWriter比System.out的写速度要快<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出hello world</span></span><br><span class="line">System.out.print(<span class="string">"hello world"</span>); <span class="comment">// &gt;&gt; hello world</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">bw.write(<span class="string">"hello world"</span>); <span class="comment">// &gt;&gt; </span></span><br><span class="line">bw.flush(); <span class="comment">// &gt;&gt; hello world</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>BufferedWriter.write(int c) 输出乱码问题解决方案：</p><p>API中对于BufferedWriter的write(int c)解释为“Writes a single character”，所以其实写入的数据类型为char，内存长度只有2个字节，而且是以Unicode编码，所以会出现乱码。</p><p>故需要先将int强转为Integer, 再wirte(c.toString())即可。</p></blockquote><h3 id="写算法题的输入输出范例"><a href="#写算法题的输入输出范例" class="headerlink" title="写算法题的输入输出范例"></a>写算法题的输入输出范例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        String input = br.readLine();</span><br><span class="line">        String output = operate(input); <span class="comment">//operate看作是解决算法问题的方法</span></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        bw.write(output);</span><br><span class="line">        </span><br><span class="line">        bw.flush(); <span class="comment">//必须刷新缓冲区，否则无法打印结果</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果输出是浮点数，且要保留精度，或者格式化输出，还是使用System.out.printf;</p><p>可以使用bw.newLine()输出一个换行符。</p></blockquote><h2 id="算法小技巧"><a href="#算法小技巧" class="headerlink" title="算法小技巧"></a>算法小技巧</h2><h3 id="求最大公约数-辗转相除法"><a href="#求最大公约数-辗转相除法" class="headerlink" title="求最大公约数(辗转相除法)"></a>求最大公约数(辗转相除法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = n, b = m; <span class="comment">//n和m是实际问题中的两个整数</span></span><br><span class="line"><span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> r = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a; <span class="comment">//此时a就是n,m的最大公约数</span></span><br></pre></td></tr></table></figure><h3 id="求最小公倍数"><a href="#求最小公倍数" class="headerlink" title="求最小公倍数"></a>求最小公倍数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a和b的最小公倍数 = a*b / a和b的最大公约数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||最小二乘法</title>
      <link href="/2020/10/09/mathAnalysis-5-4/"/>
      <url>/2020/10/09/mathAnalysis-5-4/</url>
      
        <content type="html"><![CDATA[<h1 id="最小二乘法-多项式拟合曲线"><a href="#最小二乘法-多项式拟合曲线" class="headerlink" title="最小二乘法(多项式拟合曲线)"></a>最小二乘法(多项式拟合曲线)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在函数类$\Phi=span [\phi_0(x),\phi_1(x),\cdots,\phi_n(x)]$中找到一个函数,使得拟合函数和原函数的误差向量的二范数达到最小.</p><h2 id="多项式拟合函数-1-x-x-2-cdots-x-n"><a href="#多项式拟合函数-1-x-x-2-cdots-x-n" class="headerlink" title="多项式拟合函数($1,x,x^2,\cdots,x^n$)"></a>多项式拟合函数($1,x,x^2,\cdots,x^n$)</h2><script type="math/tex; mode=display">\phi(x)=a_0\phi_0(x)+a_1\phi_1(x)+\cdots+a_n\phi_n(x)</script><p>只需要求出系数$a_0,a_1,\cdots,a_n$即可求出拟合曲线</p><h2 id="正则方程组"><a href="#正则方程组" class="headerlink" title="正则方程组"></a>正则方程组</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201009/image-20200611221402561.png" alt="image-20200611221402561"></p><p>$(\phi_0,\phi_1)=\rho\phi_0\phi_1$</p><h2 id="构造最小二乘法的一些思路"><a href="#构造最小二乘法的一些思路" class="headerlink" title="构造最小二乘法的一些思路"></a>构造最小二乘法的一些思路</h2><ul><li>如果离散节点构成的函数图像不是多项式函数,而是指数函数,可以采用取对数的方式来化成多项式函数求值!</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||牛顿插值多项式</title>
      <link href="/2020/10/09/mathAnalysis-5-3/"/>
      <url>/2020/10/09/mathAnalysis-5-3/</url>
      
        <content type="html"><![CDATA[<h1 id="牛顿插值多项式"><a href="#牛顿插值多项式" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h1><h2 id="差商"><a href="#差商" class="headerlink" title="差商"></a>差商</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>一阶差商：$f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}$</li><li>二阶差商：$f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}$</li><li>k阶差商以此类推</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>$f[x_0,x_1,\cdots,x_k]=\sum_{j=0}^k\frac{1}{\omega’_{k+1}(x_j)}f(x_j)$</li><li>差商对节点具有对称性</li><li>n次多项式$f(x)$的k阶差商$f[x_0,x_1,\cdots,x_{k-1},x]$,当$k\le n$时，是一个关于x的n-k次多项式，当$k&gt;n$时，恒等于0.</li><li>若$f(x)$具有k阶连续导数，则：$f[x_0,x_1,\cdots,x_k]=\frac{f^{(k)}(\xi)}{k!}$</li></ol><h2 id="牛顿插值多项式-1"><a href="#牛顿插值多项式-1" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>$N_n(x)=f(x_0)+f[x_0,x_1]\omega_1(x)+f[x_0,x_1,x_2]\omega_2(x)+\cdots+f[x_0,x_1,\cdots,x_n]\omega_n(x)$</p><h3 id="余项"><a href="#余项" class="headerlink" title="余项"></a>余项</h3><p>$R_n(x)=f[x,x_0,x_1,\cdots,x_n]\omega_{n+1}(x)=\frac{f^{(n+1)}(\zeta)}{(n+1)!}\omega_{n+1}(x)$</p>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||分段插值多项式</title>
      <link href="/2020/10/09/mathAnalysis-5-2/"/>
      <url>/2020/10/09/mathAnalysis-5-2/</url>
      
        <content type="html"><![CDATA[<h1 id="分段插值多项式"><a href="#分段插值多项式" class="headerlink" title="分段插值多项式"></a>分段插值多项式</h1><h2 id="Runge现象"><a href="#Runge现象" class="headerlink" title="Runge现象"></a>Runge现象</h2><ul><li>高次的插值函数的近似效果越差,以致完全失真,这个现象称为Runge现象.(高次插值数值不稳定)</li></ul><h2 id="分段线性插值"><a href="#分段线性插值" class="headerlink" title="分段线性插值"></a>分段线性插值</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><script type="math/tex; mode=display">S_1(x)=\frac{x_i-x}{h_i}y_{i-1}+\frac{x-x_{i-1}}{h_i}y_i, x \in [x_{i-1},x_i]</script><h3 id="插值余项"><a href="#插值余项" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">f(x)-S_1(x)=\frac{f''(\xi)}{2!}(x-x_{i-1})(x-x_i)\le\frac{M_2}{8}h^2</script><h2 id="分段二次插值"><a href="#分段二次插值" class="headerlink" title="分段二次插值"></a>分段二次插值</h2><h3 id="插值余项-1"><a href="#插值余项-1" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">f(x)-S_2(x)=\frac{f'''(\xi)}{3!}(x-x_{i-1})(x-x_{i-\frac{1}{2}})(x-x_i)\le \frac{M_3}{72\sqrt3}h^3</script><h2 id="分段Hermite插值"><a href="#分段Hermite插值" class="headerlink" title="分段Hermite插值"></a>分段Hermite插值</h2><h3 id="插值余项-2"><a href="#插值余项-2" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">f(x)-H_3(x)=\frac{f^{(4)}(\xi)}{4!}(x-x_{i-1})^2(x-x_i)^2\le \frac{M_4}{384}h^2(h^4?)</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||插值的定义</title>
      <link href="/2020/10/09/mathAnalysis-5-1/"/>
      <url>/2020/10/09/mathAnalysis-5-1/</url>
      
        <content type="html"><![CDATA[<h1 id="插值的定义"><a href="#插值的定义" class="headerlink" title="插值的定义"></a>插值的定义</h1><h2 id="插值条件"><a href="#插值条件" class="headerlink" title="插值条件"></a>插值条件</h2><ul><li><p>设函数$f(x)$在区间$[a,b]$上连续，给定$n+1$个节点，$a\le x_0&lt;x_1…&lt;x_n\le b$。</p></li><li><p>已知$f(x_k)=y_k(k=0,1,…n)$,在函数类P中寻找一函数$\phi(x)$作为$f(x)$的近似表达式，使满足：</p><p>$\phi(x_k)=f(x_k)=y_k,k=0,1,…,n$</p><p>注：$\phi(x)$为插值函数，函数类P为多项式函数类</p></li></ul><h2 id="插值定理"><a href="#插值定理" class="headerlink" title="插值定理"></a>插值定理</h2><ul><li>如果$n+1$个节点互不相等，则存在唯一的一个插值函数$p_n(x)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第四章||牛顿迭代法</title>
      <link href="/2020/10/09/mathAnalysis-4-3/"/>
      <url>/2020/10/09/mathAnalysis-4-3/</url>
      
        <content type="html"><![CDATA[<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><h2 id="Newton-迭代格式"><a href="#Newton-迭代格式" class="headerlink" title="Newton 迭代格式"></a>Newton 迭代格式</h2><ul><li>迭代格式（切线法）：$x_{k+1}=x_k-\frac{f(x_k)}{f^{‘}(x_k)}$</li><li>$\phi’(x)=\frac{f(x)f’’(x)}{(f’(x))^2}$</li></ul><h2 id="Newton-迭代法的收敛性"><a href="#Newton-迭代法的收敛性" class="headerlink" title="Newton 迭代法的收敛性"></a>Newton 迭代法的收敛性</h2><ul><li><p><strong>收敛阶：</strong>Newton 迭代法对于单根$\alpha$至少是平方阶收敛，Newton 迭代法对初值$x_0$的选取较为严格。</p></li><li><p><strong>定理：</strong>$\lim_{k\to\infty}\frac{x_{k+1}-\alpha}{(x_k-\alpha)^2}=\frac{f^{‘’}(\alpha)}{2f^{‘}(\alpha)}$</p></li></ul><h2 id="Newton-迭代法的变形"><a href="#Newton-迭代法的变形" class="headerlink" title="Newton 迭代法的变形"></a>Newton 迭代法的变形</h2><h3 id="简化-Newton-迭代法（线性收敛）"><a href="#简化-Newton-迭代法（线性收敛）" class="headerlink" title="简化 Newton 迭代法（线性收敛）"></a>简化 Newton 迭代法（线性收敛）</h3><ul><li>迭代格式：$x_{k+1}=x_k-\frac{f(x_k)}{M}\ ,k=0,1,2,\cdots$</li><li>$M通常取f^{‘}(x_o)$</li></ul><h3 id="割线法（该迭代法的收敛阶介于1和2之间）"><a href="#割线法（该迭代法的收敛阶介于1和2之间）" class="headerlink" title="割线法（该迭代法的收敛阶介于1和2之间）"></a>割线法（该迭代法的收敛阶介于1和2之间）</h3><ul><li>用<strong>函数$f(x)$的差商</strong>近似 Newton 迭代格式中的导数$f’（x）,即$</li><li>$f’(x)\approx\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$</li><li>Newton 迭代法可以修改为：$x_{k+1}=x_k-\frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1}),\ k=1,2,3,\cdots$</li></ul><h3 id="求方程重根的-Newton-迭代法（往往具有平方阶收敛）"><a href="#求方程重根的-Newton-迭代法（往往具有平方阶收敛）" class="headerlink" title="求方程重根的 Newton 迭代法（往往具有平方阶收敛）"></a>求方程重根的 Newton 迭代法（往往具有平方阶收敛）</h3><ul><li><strong>带参数m的迭代格式：</strong>$x_{k+1}=x_k-m\frac{f(x_k)}{f’(x_k)},\ k=0,1,2,\cdots$</li><li><strong>不带参数m的迭代格式：</strong>$x_{k+1}=x_k-\frac{u(x_k)}{u’(x_k)},\ k=0,1,2,\cdots \ ;u(x)=\frac{f(x)}{f’(x)}$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第四章||二分法</title>
      <link href="/2020/10/09/mathAnalysis-4-1/"/>
      <url>/2020/10/09/mathAnalysis-4-1/</url>
      
        <content type="html"><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul><li><p><strong>定义：</strong>设$[a,b]$为方程$f(x)=0$的有根区间。所谓二分法就是<strong>对有根区间</strong>$[a,b]$<strong>逐次分半</strong>，使得有根区间长度逐次缩小，从而得到根的近似值。</p></li><li><p><strong>步骤：</strong></p><script type="math/tex; mode=display">①记a_0=a,\ b=b_0,\ 计算\ x_1=\frac{a+b}{2} \\</script><script type="math/tex; mode=display">②若f(a_0)f(x_1)<0,\ 取\ a_1=a_0,\ b_1=x_1; \\</script><script type="math/tex; mode=display">③若f(a_0)f(x_1)>0,\ 取\ a_1=x_1,\ b_1=b_0; \\</script><script type="math/tex; mode=display">④则得到新的有根区间\ [a_1,b_1],\ 其区间长度恰好是\ [a_0,b_0]\ 长度的一半; \\</script><script type="math/tex; mode=display">⑤重复上述操作，直至根的近似值达到精度要求结束二分法。</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第四章||简单迭代法</title>
      <link href="/2020/10/09/mathAnalysis-4-2/"/>
      <url>/2020/10/09/mathAnalysis-4-2/</url>
      
        <content type="html"><![CDATA[<h1 id="简单迭代法"><a href="#简单迭代法" class="headerlink" title="简单迭代法"></a>简单迭代法</h1><h2 id="简单迭代法的一般形式"><a href="#简单迭代法的一般形式" class="headerlink" title="简单迭代法的一般形式"></a>简单迭代法的一般形式</h2><ul><li><strong>迭代格式：</strong>$x_{k+1}=\phi(x_k),\ \phi(x)称为迭代函数$</li></ul><h2 id="简单迭代法的收敛条件"><a href="#简单迭代法的收敛条件" class="headerlink" title="简单迭代法的收敛条件"></a>简单迭代法的收敛条件</h2><ul><li><p>收敛定理：</p><p>① 假设迭代函数$\phi(x)$在区间$[a,b]$上可导，且满足条件：</p><p>② $a\le \phi(x) \le b,\ x\in[a,b]$</p><p>③ 存在正数$L &lt; 1,$使对任意 $x \in [a,b]$ 有 $|\phi^{‘}(x)|\le L &lt; 1$</p></li></ul><h2 id="简单迭代法的收敛阶"><a href="#简单迭代法的收敛阶" class="headerlink" title="简单迭代法的收敛阶"></a>简单迭代法的收敛阶</h2><ul><li><strong>一般格式：</strong>$\lim_{k\to \infty} \tfrac{|e_{k+1}|}{|e_k|^p}=C$</li><li>$p$为<strong>收敛阶</strong>，$C$为<strong>渐近误差常数</strong>。</li><li><strong>收敛阶的求法：</strong>$\phi^{‘}(\alpha)=\phi^{‘’}(\alpha)=\cdots=\phi^{(p-1)}(\alpha)=0,\ \phi^{(P)}(\alpha)\neq0,\ p\ge2$,则迭代法<strong>p阶收敛</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法常用模板</title>
      <link href="/2020/10/06/algorithmTemplate-1/"/>
      <url>/2020/10/06/algorithmTemplate-1/</url>
      
        <content type="html"><![CDATA[<ul><li>常用排序、二分、高精度、前缀和、差分、位运算、双指针、离散化、区间合并<a id="more"></a></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left-<span class="number">1</span>, j=right+<span class="number">1</span>, x=arr[(left+right)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(arr[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(arr[j] &gt; x);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    quickSort(arr, left, j);</span><br><span class="line">    quickSort(arr, j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left == right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(arr, left, mid);</span><br><span class="line">    mergeSort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//temp数组用于临时存放left到right的有序数列</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[k++] = arr[i++]; </span><br><span class="line">        <span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数依次放到temp数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right) temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    <span class="keyword">for</span>(i=left, j=<span class="number">0</span>; i &lt;= right; i++, j++) arr[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i]; <span class="comment">//找出第i小的元素，并放到数组的下标i中</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;min)&#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">       <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">//将元素i插入到有序数列0,1,2...i-1中</span></span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]; j--)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找-两种情况"><a href="#二分查找-两种情况" class="headerlink" title="二分查找(两种情况)"></a>二分查找(两种情况)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) right = mid; <span class="comment">//满足区间在左半边</span></span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) left = mid; <span class="comment">//满足区间在右半边</span></span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：浮点数二分可以用于开n次方，也不用判断边界条件</span></span><br></pre></td></tr></table></figure><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">add</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A + B 数字均为逆序存储，例：12345被存储为54321</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//假设A&gt;B</span></span><br><span class="line">    <span class="keyword">if</span>(A.size() &lt; B.size())</span><br><span class="line">        <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果就是t%10的余数</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后一次加法如果还有进位就把t加到结果中</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">sub</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">  <span class="comment">//假设A&gt;B,C = A - B</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t = A.get(i) - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t -= B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果有两种情况，一种是需要借位，一种是不需要</span></span><br><span class="line">        C.add((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算借位</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果可能为000123的情况，所以要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.get(C.size()-<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mul</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//A为高精度，b为低精度，C = Axb</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i)*b;</span><br><span class="line">        <span class="comment">//第i位的结果t % 10</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断最后一次计算是否有进位</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果b为0，计算结果可能为00000，故需要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r; <span class="comment">//余数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">div</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A / b</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=A.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span>+A.get(i);</span><br><span class="line">       <span class="comment">//第i位结果</span></span><br><span class="line">        C.add(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序存储</span></span><br><span class="line">    Collections.reverse(C);</span><br><span class="line">    <span class="comment">//结果可能为011，去除前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>]+a[<span class="number">2</span>]+...+a[i];</span><br><span class="line">a[l]~a[r]的和=S[r] - S[l-<span class="number">1</span>]; <span class="comment">//a[0] = 0; S[0] = 0</span></span><br></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[i][j]为第i行j列左上部分所有元素的和</span><br><span class="line">求左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的和：</span><br><span class="line">A = S[x2][y2] - S[x1-<span class="number">1</span>][y2] - S[x2][y1-<span class="number">1</span>] + S[x1-<span class="number">1</span>][y1-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已知a[], b[],b[]为a[]的差分数组，即a[i] = b[<span class="number">0</span>]+b[<span class="number">1</span>]+...+b[i];</span><br><span class="line">给下标区间为[l,r]的a[]都加上常数c &lt;=&gt; b[l] += c, b[r+<span class="number">1</span>] -= c;</span><br></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的每一个元素加上c(先构造差分矩阵再插入)</span><br><span class="line">&lt;=&gt; </span><br><span class="line">b[x1][y1] += c,</span><br><span class="line">b[x1][y2+<span class="number">1</span>] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y1] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求n的第k位数字（n为二进制表示形式）</span></span><br><span class="line">n &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//返回n的最后一位1（n为二进制表示形式）</span></span><br><span class="line">lowbit(n) <span class="keyword">return</span> n &amp; -n;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="comment">// check(i, j) 表示根据题意设定的维护双指针的条件</span></span><br><span class="line">    <span class="keyword">while</span>(check(i, j)) j++;</span><br><span class="line">    <span class="comment">// 根据题意具体的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常见的问题有两类：<ul><li>对于一个序列，用两个指针维护一段区间</li><li>对于两个序列，维护某种次序，比如归并排序中合并两个子序列</li></ul></li></ul><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; alls; <span class="comment">//存储所有待离散化的值（已去重）</span></span><br><span class="line">List&lt;Integer&gt; allList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">allList.addAll(alls);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(allList, (a1, a2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (Integer)a1 - (Integer)a2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果要使用前缀和，返回值+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=allList.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(allList.get(mid) &gt;= x) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span>; <span class="comment">//映射到1,2,...,n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先将区间序列按照左端点排好序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = a;</span><br><span class="line">        <span class="keyword">this</span>.second = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设list已经排好序,list.size() &gt;= 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Pair&gt; <span class="title">merge</span><span class="params">(List&lt;Pair&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Pair&gt; res = <span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line">    <span class="comment">//先将第一个区间加到res中</span></span><br><span class="line">    res.add(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//判断两个区间是否有交集</span></span><br><span class="line">        <span class="keyword">if</span>(res.get(res.size()-<span class="number">1</span>).second &lt; list.get(i).first)&#123;</span><br><span class="line">            <span class="comment">//没有，直接加</span></span><br><span class="line">            res.add(list.get(i));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有，判断区间左端点是谁</span></span><br><span class="line">            <span class="keyword">int</span> second = res.get(res.size()-<span class="number">1</span>).second;</span><br><span class="line">            <span class="keyword">int</span> nSecond = list.get(i).second;</span><br><span class="line">            res.get(res.size()-<span class="number">1</span>).second = (second &gt; nSecond) ? second : nSecond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 高精度 </tag>
            
            <tag> 前缀和与差分 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 离散化 </tag>
            
            <tag> 区间合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;三种迭代法的矩阵表示形式</title>
      <link href="/2020/10/05/mathAnalysis-3-4/"/>
      <url>/2020/10/05/mathAnalysis-3-4/</url>
      
        <content type="html"><![CDATA[<h1 id="三种迭代法的矩阵表示形式（-Ax-b-）"><a href="#三种迭代法的矩阵表示形式（-Ax-b-）" class="headerlink" title="三种迭代法的矩阵表示形式（$Ax= b$）"></a>三种迭代法的矩阵表示形式（$Ax= b$）</h1><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">假设A=D-L-U,D为对角矩阵， \\</script><script type="math/tex; mode=display">-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">(D-L-U)x = b \\\Rightarrow Dx = (L+U)x+b \\</script><script type="math/tex; mode=display">\Rightarrow x = D^{-1}(L+U)x+D^{-1}b \\\Rightarrow x^{(k+1)} = D^{-1}(L+U)x^{k}+D^{-1}b</script><a id="more"></a><ul><li><strong>迭代矩阵：</strong>$B=D^{-1}(L+U)$</li></ul><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><script type="math/tex; mode=display">假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">(D-L-U)x = b \\\Rightarrow Dx = Lx + Ux + b \\</script><script type="math/tex; mode=display">\Rightarrow Dx^{(k+1)} = Lx^{(k+1)}+Ux^k+b \\\Rightarrow (D-L)x^{(k+1)} = Ux^k+b \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = (D-L)^{-1}Ux^k+(D-L)^{-1}b</script><ul><li><strong>迭代矩阵：</strong>$G=(D-L)^{-1}U$</li></ul><h2 id="SOR迭代法"><a href="#SOR迭代法" class="headerlink" title="SOR迭代法"></a>SOR迭代法</h2><script type="math/tex; mode=display">假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">L为缺少对角线元素的下三角矩阵，U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">(D-L-U)x = b\\</script><script type="math/tex; mode=display">\Rightarrow x = x +[b-(D-L-U)x] \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = x^{k} + D^{-1}[b-(D-L-U)x^{k}],J迭代格式 \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = x^k + D^{-1}[b+(U-D)x^k+Lx^{(k+1)}],G-S迭代格式 \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = x^k + \omega D^{-1}[b+(U-D)x^k+Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">\Rightarrow Dx^{(k+1)} = Dx^k+[\omega b+ \omega(U-D)x^k+\omega Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">\Rightarrow (D-\omega L)x^{(k+1)} = [D(1-\omega)+\omega U]x^k + \omega b \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]x^k + \omega(D-\omega L)^{-1}b</script><ul><li><strong>迭代矩阵：</strong>$L_{\omega} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;SOR迭代法</title>
      <link href="/2020/10/05/mathAnalysis-3-3/"/>
      <url>/2020/10/05/mathAnalysis-3-3/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li>Jacobi迭代法的实质是用当前的迭代值加上一个修正量来得到一个新的迭代值，结合J迭代法和GS迭代法以及修正量的思想引入<strong>SOR迭代法</strong>。<a id="more"></a></li></ul><h2 id="SOR迭代法的表达式"><a href="#SOR迭代法的表达式" class="headerlink" title="SOR迭代法的表达式"></a>SOR迭代法的表达式</h2><ul><li><p>$x^{(k+1)}_i=x_i^{(k)}+\frac{\omega}{a_{ii}}(b_i - \sum^{i-1}_{j=1}a_{ij}x_j^{(k+1)}-\sum^n_{j=i}a_{ij}x_j^{(k)})$</p><p>$i=1,2,\cdots,n,\quad k=0,1,\cdots$</p></li><li><p>$\omega$称作<strong>松弛因子</strong>，当$\omega &lt; 1$时，此迭代称为<strong>欠松弛迭代</strong>，$\omega&gt;1$时，称为<strong>超松弛迭代</strong>。</p></li></ul><h2 id="SOR迭代法的判定定理"><a href="#SOR迭代法的判定定理" class="headerlink" title="SOR迭代法的判定定理"></a>SOR迭代法的判定定理</h2><ul><li><strong>定理一</strong>：SOR方法收敛的<strong>充分必要条件</strong>是 $\rho(M_\omega)&lt;1$；收敛的<strong>充分</strong>条件为 $||M_\omega||&lt;1$。（$M_\omega$为迭代矩阵）</li><li><strong>定理二</strong>：SOR方法收敛的<strong>必要条件</strong>是：$0&lt;\omega&lt;2$。</li><li><strong>定理三</strong>：设系数矩阵$A$是对称正定的，且 $0&lt;\omega&lt;2$，则SOR方法收敛。</li><li><strong>定理四</strong>：当系数矩阵$A$是$\alpha-$严格对角占优矩阵，且 $0&lt;w \le1$，SOR方法收敛。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;Jacobi迭代法和Gauss-Seidel迭代法</title>
      <link href="/2020/10/05/mathAnalysis-3-2/"/>
      <url>/2020/10/05/mathAnalysis-3-2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>以该线性方程组为例，介绍几种线性方程组的数值解法</li><li><script type="math/tex; mode=display">\left\{  \begin{array}{c}    a_{11}x_1+a_{12}x_2+a_{13}x_3=b_1 \\     a_{21}x_1+a_{22}x_2+a_{23}x_3=b_2 \\     a_{31}x_1+a_{32}x_2+a_{33}x_3=b_3 \end{array} \right.</script></li></ul><a id="more"></a><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">\left\{\begin{array}{c}x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k)}-a_{23}x_3^{(k)}) \\x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k)}-a_{32}x_3^{(k)})\end{array}\right.</script><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><ul><li>由Jacobi迭代公式我们可知，在计算$x_2^{(k+1)}$时，此时$x_1^{(k+1)}$已经计算出；在计算$x_3^{(k+1)}$时，$x_1^{(k+1)},x_2^{(k+1)}$也已经计算出。为了充分利用这些数据便有了Gauss-Seidel迭代法：</li></ul><script type="math/tex; mode=display">\left\{\begin{array}{c}x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k+1)}-a_{23}x_3^{(k)}) \\x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k+1)}-a_{32}x_3^{(k+1)})\end{array}\right.</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;迭代法的收敛性</title>
      <link href="/2020/10/05/mathAnalysis-3-1/"/>
      <url>/2020/10/05/mathAnalysis-3-1/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代法的一般形式"><a href="#迭代法的一般形式" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h2><h3 id="线性方程组的等价形式"><a href="#线性方程组的等价形式" class="headerlink" title="线性方程组的等价形式"></a>线性方程组的等价形式</h3><ul><li>$Ax=b \Leftrightarrow x = Mx+g$<ul><li>$M$成为迭代矩阵，$g$为某一向量<a id="more"></a></li></ul></li></ul><h3 id="迭代法的一般形式-1"><a href="#迭代法的一般形式-1" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h3><ul><li>$x^{(k+1)}=Mx^{(k)}+g$</li></ul><h2 id="迭代法收敛的判定定理"><a href="#迭代法收敛的判定定理" class="headerlink" title="迭代法收敛的判定定理"></a>迭代法收敛的判定定理</h2><ul><li><strong>定理一</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分必要条件</strong>是迭代矩阵$M$的谱半径 $\rho(M)&lt;1$。</li><li><strong>定理二</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分条件</strong>是 $||M||&lt;1$。</li><li><strong>补充：</strong>当迭代方法的迭代矩阵谱半径$\rho(M)&lt;1$时，谱半径越小，迭代方法的收敛速度越快。</li></ul><h2 id="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"><a href="#Jacobi迭代法和Gauss-Seidel迭代法的收敛性" class="headerlink" title="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"></a>Jacobi迭代法和Gauss-Seidel迭代法的收敛性</h2><h3 id="严格对角占优矩阵"><a href="#严格对角占优矩阵" class="headerlink" title="严格对角占优矩阵"></a>严格对角占优矩阵</h3><script type="math/tex; mode=display">设n阶A=(a_{ij})，如果A的元素满足:</script><script type="math/tex; mode=display">\sum^n_{j=1 \\ j\neq i}|a_{ij}| < |a_{ii}|,\ i=1,2,\cdots,n \\则称A是严格对角占优矩阵</script><h3 id="判定定理"><a href="#判定定理" class="headerlink" title="判定定理"></a>判定定理</h3><ul><li><p><strong>定理一</strong>：设$A$是严格对角占优矩阵，则解方程组$Ax=b$的$J$迭代法和$GS$迭代法均收敛。</p></li><li><p><strong>定理二</strong>：设$A$是对称正定矩阵，则解方程组$Ax=b$的$GS$迭代法是收敛的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;线性方程组的固有性态</title>
      <link href="/2020/10/05/mathAnalysis-2-6/"/>
      <url>/2020/10/05/mathAnalysis-2-6/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>由于原始数据微小变化而导致解严重失真的方程组称为<strong>病态方程组</strong>，相应的系数矩阵称为<strong>病态矩阵</strong>。</li><li>使用<strong>条件数</strong>来判定线性方程组是否<strong>病态</strong>。<a id="more"></a></li></ul><h2 id="条件数"><a href="#条件数" class="headerlink" title="条件数"></a>条件数</h2><ul><li>$Cond(A)=||A||\  ||A^{-1}||$</li><li>经常使用的条件数: $Cond_p(A)=||A||_p \  ||A^{-1}||_p,\  p=1,2,\infty$</li><li>当$A$为<strong>对称矩阵</strong>时, 可有</li></ul><script type="math/tex; mode=display">Cond_2(A)=\frac{|\lambda|_{max}}{|\lambda|_{min}}</script><ul><li>通常用<strong>条件数过大</strong>来判定方程组是病态方程组</li></ul><h2 id="逆矩阵的求法"><a href="#逆矩阵的求法" class="headerlink" title="逆矩阵的求法"></a>逆矩阵的求法</h2><ul><li>$(A,E) \Rightarrow 经过初等行变换得 (E, A^{-1})$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;范数</title>
      <link href="/2020/10/05/mathAnalysis-2-5/"/>
      <url>/2020/10/05/mathAnalysis-2-5/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li>为了对线性方程组的性态和其数值解进行分析，故引入范数来表示。<a id="more"></a></li></ul><h2 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>假设$||\cdot||$为向量空间$R^n$的实值函数，且满足以下三个条件：</li><li><strong>非负性：</strong>对于任何向量$x\in R^n$，$||x||\ge 0$，且$||x||=0$当且仅当$x=0$</li><li><strong>齐次性：</strong>对于任何实数$\alpha$和向量$x\in R^n$，$||\alpha x||=|\alpha|||x||$</li><li><strong>三角不等式：</strong>对于任何向量$x,y\in R^n$，$||x+y||\le||x||+||y||$</li></ul><p>则称$||\cdot||$为向量空间$R^n$上的范数，$||x||$为向量$x$的范数</p><h3 id="常用的三个向量范数"><a href="#常用的三个向量范数" class="headerlink" title="常用的三个向量范数"></a>常用的三个向量范数</h3><ul><li>向量1-范数：$||x||_1=\sum^n_{i=1}|x_i|$</li><li>向量2-范数：$||x||_2=(\sum^n_{i=1}x_i^2)^{\frac{1}{2}}$(向量的模)</li><li>向量$\infty$-范数：$||x||_\infty=max_{1\le i\le n}|x_i|$</li></ul><h3 id="范数的等价性以及常用的等价公式"><a href="#范数的等价性以及常用的等价公式" class="headerlink" title="范数的等价性以及常用的等价公式"></a>范数的等价性以及常用的等价公式</h3><ul><li><p><strong>范数的等价性：</strong>对于$R^n$空间上的任意两个范数$||\cdot||_\alpha$和$||\cdot||_\beta$，存在正常数$m,M$，使得：</p><p>$m||x||_\beta \le ||x||_\alpha \le M||x||_\beta, \forall x \in R^n$</p></li><li><p><strong>常用的等价公式：</strong></p><p>$||x||_\infty \le ||x||_1 \le n||x||_\infty$</p><p>$||x||_\infty \le ||x||_2 \le \sqrt n||x||_\infty$</p><p>$||x||_2 \le ||x||_1 \le \sqrt n||x||_2$</p></li></ul><h2 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>与向量范数定义类似，除去向量范数满足的三个条件以外，还要满足第四个条件：</li><li>$||AB|| \le ||A||||B||$</li><li>满足四个条件则称$||A||$为$A$的范数</li></ul><h3 id="四个常用的矩阵范数"><a href="#四个常用的矩阵范数" class="headerlink" title="四个常用的矩阵范数"></a>四个常用的矩阵范数</h3><ul><li>矩阵的1-范数（列范数）：$||A||_1=max_{1\le j\le n}\sum_{i=1}^n|a_{ij}|$</li><li>矩阵的2-范数（谱范数）：$||A||_2=(A^TA的最大特征值)^{\frac{1}{2}}$</li><li>矩阵的$\infty$-范数（行范数）：$||A||_\infty=max_{1\le i \le n}\sum_{j=1}^n|a_{ij}|$</li><li>矩阵的F-范数：$||A||_F=(\sum_{i,j=1}^n|a_{ij}|^2)^{\frac{1}{2}}$</li></ul><p>识记：1是竖着的所以一范数是列范数，$\infty$范数是横着的所以是行范数。</p><h3 id="矩阵相容范数的判定"><a href="#矩阵相容范数的判定" class="headerlink" title="矩阵相容范数的判定"></a>矩阵相容范数的判定</h3><ul><li>$||Ax||\le ||A||\  ||x||,\  \forall x \in R^n$</li></ul><h3 id="谱半径"><a href="#谱半径" class="headerlink" title="谱半径"></a>谱半径</h3><ul><li>$\rho(A)=max_{1\le i \le n}|\lambda|$</li></ul><h3 id="特征值-lambda-的求法"><a href="#特征值-lambda-的求法" class="headerlink" title="特征值$\lambda$的求法"></a>特征值$\lambda$的求法</h3><ul><li>计算行列式: $|\lambda E - A| = 0$</li><li>特征值得和等于矩阵主对角线元素之和</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;追赶法</title>
      <link href="/2020/10/05/mathAnalysis-2-4/"/>
      <url>/2020/10/05/mathAnalysis-2-4/</url>
      
        <content type="html"><![CDATA[<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul><li>追赶法是求三对角线性方程组的三角分解法。<a id="more"></a></li></ul><h2 id="矩阵：-A-TM"><a href="#矩阵：-A-TM" class="headerlink" title="矩阵：$A=TM$"></a>矩阵：$A=TM$</h2><script type="math/tex; mode=display">A=\left[\begin{matrix}a_1 & c_1 \\d_2 & a_2    & c_2 \\    & \ddots & \ddots & \ddots \\    &        & d_{n-1}& a_{n-1} & c_{n-1} \\    &        &        & d_n     & a_n      \\\end{matrix}\right]</script><h2 id="三对角矩阵-A-的各阶顺序主子式不为零的充要条件"><a href="#三对角矩阵-A-的各阶顺序主子式不为零的充要条件" class="headerlink" title="三对角矩阵$A$的各阶顺序主子式不为零的充要条件"></a>三对角矩阵$A$的各阶顺序主子式不为零的充要条件</h2><ul><li>$|a_1|&gt;|c_1|;|a_n|&gt;|d_n|;$</li><li>$|a_i|\ge |c_i|+|d_i|,c_id_i\neq0,i=2,3,…n-1$</li></ul><h2 id="追赶法的具体步骤"><a href="#追赶法的具体步骤" class="headerlink" title="追赶法的具体步骤"></a>追赶法的具体步骤</h2><ul><li>先求第一行，再求第二行，依次类推</li><li>每一行都是从左到右开始求解</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;平方根法</title>
      <link href="/2020/10/05/mathAnyalsis-2-3/"/>
      <url>/2020/10/05/mathAnyalsis-2-3/</url>
      
        <content type="html"><![CDATA[<h2 id="引入：对称正定矩阵"><a href="#引入：对称正定矩阵" class="headerlink" title="引入：对称正定矩阵"></a>引入：对称正定矩阵</h2><ul><li>矩阵各元素的各元素沿主对角线对称</li><li>矩阵的所有特征值均大于零</li></ul><a id="more"></a><h2 id="平方根法的使用条件"><a href="#平方根法的使用条件" class="headerlink" title="平方根法的使用条件"></a>平方根法的使用条件</h2><ul><li>$A$为对称正定矩阵，且$U_{kk}&gt;0$。</li></ul><h2 id="平方根法的步骤"><a href="#平方根法的步骤" class="headerlink" title="平方根法的步骤"></a>平方根法的步骤</h2><ul><li>$A=UU^T$,只需要计算$U$即可。</li><li>计算顺序：计算下三角矩阵$U$的第一列、第二列……依此类推。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;直接三角分解法</title>
      <link href="/2020/10/05/mathAnalysis-2-2/"/>
      <url>/2020/10/05/mathAnalysis-2-2/</url>
      
        <content type="html"><![CDATA[<h2 id="定义（顺序Gauss消去法的矩阵形式）"><a href="#定义（顺序Gauss消去法的矩阵形式）" class="headerlink" title="定义（顺序Gauss消去法的矩阵形式）"></a>定义（顺序Gauss消去法的矩阵形式）</h2><ul><li>将系数矩阵$A$分解成$A=LU$（单位下三角矩阵$L$和上三角矩阵$U$）</li></ul><script type="math/tex; mode=display">Ax=b\Rightarrow\begin{cases}Ux=y \\Ly=b\end{cases}</script><a id="more"></a><ul><li>充要条件$A$的各阶顺序主子式不为零</li></ul><h2 id="获取-L-矩阵和-U-矩阵的方法"><a href="#获取-L-矩阵和-U-矩阵的方法" class="headerlink" title="获取$L$矩阵和$U$矩阵的方法"></a>获取$L$矩阵和$U$矩阵的方法</h2><ul><li>先求$U$矩阵的第一行，再求$L$矩阵的第一列，以此类推。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;顺序Gauss消去法</title>
      <link href="/2020/03/11/mathAnalysis-2-1/"/>
      <url>/2020/03/11/mathAnalysis-2-1/</url>
      
        <content type="html"><![CDATA[<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>将线性方程组的增广矩阵，只通过行变换，将增广矩阵化简成一个上三角矩阵。再从增广矩阵的最后一行开始依次回代，求出解向量。<a id="more"></a></li></ul><h2 id="算法成立的充要条件"><a href="#算法成立的充要条件" class="headerlink" title="算法成立的充要条件"></a>算法成立的充要条件</h2><ul><li>主元素不为零$\Leftrightarrow$系数矩阵的各阶主子式都不为零</li><li>主元素：顺序Gauss消去法中的$a_{kk}^{(k)},(k=1,2,…n)$。</li></ul><h2 id="列主元Gauss消去法"><a href="#列主元Gauss消去法" class="headerlink" title="列主元Gauss消去法"></a>列主元Gauss消去法</h2><ul><li>在顺序Gauss消去法的基础上，在每一步消元之前，在主元所在的列选取绝对值最大的元素作为主元素。</li><li>充要条件：$|A|\neq0$ </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第一章&gt;&gt;误差分析</title>
      <link href="/2020/03/11/mathAnalysis-1-1/"/>
      <url>/2020/03/11/mathAnalysis-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="误差的来源与分类"><a href="#误差的来源与分类" class="headerlink" title="误差的来源与分类"></a>误差的来源与分类</h2><ul><li>观测误差</li><li>模型误差</li><li>截断误差：近似计算出现的误差<a id="more"></a></li><li>舍入误差：由于计算级只能进行有限位的运算而产生的误差</li><li>绝对误差:  $e=x^{*}-x$ 其中e为绝对误差<br>如果$\epsilon$满足：<br>  $|e|\leq\epsilon$, 则$\epsilon$为$x$的绝对误差限</li><li>相对误差：<br>  $e_r = \frac{x^* - x}{x} = \frac{e}{x}$, $e_r$为相对误差</li><li>相对误差限：<br>  $\epsilon_r=\frac{\epsilon}{|x|}$, $\epsilon_r$为相对误差限，同时$|e_r|\le\epsilon_r$</li></ul><h2 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a>有效数字</h2><ul><li>有效数字与绝对误差限的关系：<script type="math/tex; mode=display">|x^*-x|\leq\frac{1}{2}\times10^{m-n},其中n为有效数字的位数。</script><script type="math/tex; mode=display">m为x^*化为标准浮点数形式下的10m次幂。</script>注：精确值的有效数字有无穷多位！</li><li><p>有效数字和相对误差限的关系(其中$a_1$为$x$化为标准浮点数下小数点后第一个非零的数)：</p><ul><li><p>已知有效位数$n$:<br>  $\epsilon_r\le\frac{1}{2a_1}\times10^{-n+1}$</p></li><li><p>已知$x$的相对误差限:<br>  $\epsilon_r\le\frac{1}{2(a_1+1)}\times10^{-n+1}$</p></li></ul></li></ul><h2 id="数值计算中的若干原则"><a href="#数值计算中的若干原则" class="headerlink" title="数值计算中的若干原则"></a>数值计算中的若干原则</h2><ul><li>避免两个相近的数相减（使用其他算法，公式？乘除？）<script type="math/tex; mode=display">假设z=x-y,z^*=x^*-y^*,那么：</script><script type="math/tex; mode=display">e_r(z)=|\frac{x}{x-y}||e_r(x)|+|\frac{y}{x-y}||e_r(x)|</script><script type="math/tex; mode=display">从该式中我们可以看出z的相对误差会特别大</script></li><li><p>防止“大数”吃掉小数（改变运算顺序？）</p></li><li><p>绝对值太小的数不宜做除数</p><script type="math/tex; mode=display">  假设z=x \div y,z^* = x^* \div y^*,那么：</script><script type="math/tex; mode=display">  e(z)=|z^*-z|=|\frac{y(x^*-x)+x(y-y^*)}{yy*}|\approx \frac{|y||e(x)|+|x||e(y)|}{y^2}​</script><p>  则如果$y$的绝对值太小，那么$z$的绝对误差较大</p></li><li><p>注意简化计算程序，减少计算次数（舍入误差的积累和计算的时间）</p></li><li><p>选用数值稳定性好的算法</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><p>将下列表达式进行等价变形，使其数值计算结果较为精确。</p><p>(1) $\frac{1}{1-2x}-\frac{1+x}{1-x},|x|&lt;&lt;1$</p><p>解：$原式=\frac{2x^2}{(1-2x)(1-x)}$</p><p>(2)$\frac{1-e^x}{x},|x|&lt;&lt;1$</p><p>解：由$e^x$在x=0处的泰勒展开式可得：</p><p>$e^x= 1+x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2+R_n(x)$</p><p>所以</p><p>$\frac{1-e^x}{x}=\frac{x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2}{x}=1+\frac{1}{2!}x+\frac{1}{3!}x^2+…+\frac{1}{n!}x^{n-1}$</p></li><li><p>假设$f=(\sqrt{2}-1)^6,\sqrt{2}$取1.4，下列哪种计算方式的精确度最高。</p><p>(1)$\frac{1}{(\sqrt{2}+1)^6}\Rightarrow f(x)=\frac{1}{x^6}$</p><p>(2)$(3-2\sqrt2)^3 \Rightarrow f(x)=x^3$</p><p>(3)$\frac{1}{(3-2\sqrt2)^3} \Rightarrow f(x)=\frac{1}{x^3}$</p><p>(4)$99-70\sqrt2 \Rightarrow f(x)=99-70x$</p><p>解：使用函数的条件数$cond=|\frac{f^{‘}(x)x}{f(x)}|$</p><p>将$x=1.4$带入其中，可得(3)式的精确度最高。</p><p>注：条件数低为良态，条件数高为病态。   </p><h2 id="补充：-x-1x-2-的绝对误差限"><a href="#补充：-x-1x-2-的绝对误差限" class="headerlink" title="补充：$x_1x_2$的绝对误差限"></a>补充：$x_1x_2$的绝对误差限</h2></li></ol><p>$x_1\approx x_1,x_2\approx x_2$</p><script type="math/tex; mode=display">|x_1x_2-x_1^*x_2^*|=|x_1x_2-x_1x_2^*+x_1x_2^*-x_1^*x_2^*|</script><script type="math/tex; mode=display">\le|x_1||x_2-x_2^*|+|x_2^*||x_1-x_1^*|</script><script type="math/tex; mode=display">    =|x_1||e(x_2)|+|x_2||e(x_1)|</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
