<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>消费者生产者问题、哲学家就餐问题</title>
    <url>/2020/11/18/MutipleThread-1/</url>
    <content><![CDATA[<blockquote>
<p>本文主要分析了消费者生产者问题和哲学家问题产生死锁并如何解决死锁。</p>
</blockquote>
<h2 id="消费者和生产者问题"><a href="#消费者和生产者问题" class="headerlink" title="消费者和生产者问题"></a>消费者和生产者问题</h2><p><strong>问题背景：将生产者想象成做包子的师傅，消费者想象成买包子的顾客；缓冲区想象成一个容量为N的篮子，做包子的师傅只有篮子没有被装满的时候才会做包子，顾客只有篮子里不为空的时候才会买包子。</strong></p>
<p><strong>问题分析：这里有两个同步问题和一个互斥问题。</strong></p>
<ol>
<li>只有当前缓冲区没有满(cnt &lt; N)，生产者才能生产（这里设置一个empty信号量）。</li>
<li>只有当前缓冲区没有空(cnt &gt; 0)，消费者才能消费（这里设置一个full信号量）。</li>
<li>对缓冲区的访问需要互斥访问（这里设置一个mutex互斥信号量）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nicklaus.interview.synchronization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerAndComsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始的产品数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  N = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mutex表示互斥锁，empty表示当前当前还能生产多少个商品，full表示当前已经生产了多少个商品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore mutex, empty, full;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示当前生产了多少个产品</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        empty = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line">        full = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//一前一后实现进程同步</span></span><br><span class="line">                    empty.acquire();</span><br><span class="line">                    <span class="comment">//使用读写锁实现进程同步</span></span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(<span class="string">&quot;生产者生产了一个商品，当前有&quot;</span>+count+<span class="string">&quot;个商品。&quot;</span>);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    full.release();</span><br><span class="line">                    <span class="comment">//睡眠一秒</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    full.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    count--;</span><br><span class="line">                    System.out.println(<span class="string">&quot;消费者消费了一个商品，当前有&quot;</span>+count+<span class="string">&quot;个商品。&quot;</span>);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    empty.release();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(producer).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(consumer).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="多消费者和多生产者问题"><a href="#多消费者和多生产者问题" class="headerlink" title="多消费者和多生产者问题"></a>多消费者和多生产者问题</h2><p><strong>问题背景：桌上有一只盘子，每次只能向其中放入一个水果。爸爸专门向盘子中放苹果，妈妈专门向盘子中放橘子，儿子专门等着吃盘子中的苹果，女儿专门等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</strong></p>
<p><strong>问题分析：这里有三个同步问题和一个互斥问题。</strong></p>
<ol>
<li>互斥问题：对盘子（临界资源）的访问要互斥进行（mutex信号量）。</li>
<li>同步问题：只有盘子为空时，父亲或母亲才能放入水果（设置一个plate信号量）。</li>
<li>同步问题：父亲将苹果放入盘子后，儿子才能取出苹果（设置一个apple信号量）。</li>
<li>同步问题：母亲将橘子放入盘子后，女儿才能取出橘子（设置一个orange信号量）。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nicklaus.interview.synchronization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FamilyProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//互斥锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore mutex;</span><br><span class="line">    <span class="comment">//表示当前有多少个苹果（儿子只能吃苹果，父亲只能生产苹果）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore apple;</span><br><span class="line">    <span class="comment">//表示当前有多少个橘子（女儿只能吃橘子，母亲只能生产香蕉）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore orange;</span><br><span class="line">    <span class="comment">//表示当前盘子里面还可以装多少个水果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore plate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//表示当前盘子水果的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//表示当前苹果的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> appleCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//表示当前橘子的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> orangeCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        apple = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        orange = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">        plate = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    plate.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    <span class="comment">//父亲生产苹果</span></span><br><span class="line">                    <span class="comment">//父亲往盘子里放一个苹果</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;父亲生产了1个苹果，当前盘子里有&quot;</span> +(++cnt)+<span class="string">&quot;个水果，&quot;</span>+(++appleCnt)+<span class="string">&quot;个苹果。&quot;</span>);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    apple.release();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mother</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    plate.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    <span class="comment">//母亲生产橘子</span></span><br><span class="line">                    <span class="comment">//母亲往盘子里放一个橘子</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;母亲生产了1个橘子，当前盘子里有&quot;</span> +(++cnt)+<span class="string">&quot;个水果，&quot;</span>+(++orangeCnt)+<span class="string">&quot;个橘子。&quot;</span>);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    orange.release();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    apple.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    <span class="comment">//儿子从盘子里拿一个苹果</span></span><br><span class="line">                    <span class="comment">//儿子吃苹果</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;儿子吃了一个苹果，当前盘子里有&quot;</span> +(--cnt)+<span class="string">&quot;个水果，&quot;</span>+(--appleCnt)+<span class="string">&quot;个苹果。&quot;</span>);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    plate.release();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Daughter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    orange.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    <span class="comment">//女儿从盘子里拿一个橘子</span></span><br><span class="line">                    <span class="comment">//女儿吃橘子</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;女儿吃了一个橘子，当前盘子里有&quot;</span> +(--cnt)+<span class="string">&quot;个水果，&quot;</span>+(--orangeCnt)+<span class="string">&quot;个橘子。&quot;</span>);</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    plate.release();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Father()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Mother()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Son()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Daughter()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p><strong>问题背景：一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆了一根筷子，桌子的中间是一碗米饭。哲学家倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响其他人。只有当哲学家饥饿时，才试图拿起左右两根筷子（一根根地拿起）。如果筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</strong></p>
<p><strong>问题分析：想象这么一个场景，如果所有哲学家都同时拿起自己左手边的筷子，那么会有什么情况发生呢？</strong></p>
<p><em>显然所有的哲学家进入了循环等待的情况，所有哲学家都在等待其他哲学家放下自己手中的筷子！</em></p>
<p><strong>两种解决问题的思路</strong></p>
<ol>
<li>偶数序号的哲学家先拿起左边的筷子再拿起右边的筷子，奇数序号的哲学家先拿起右边的筷子再拿起左边的筷子，即相邻的哲学家竞争得到筷子，而不是循环等待。</li>
<li>保证至少有一个哲学家可以就餐成功，即限制哲学家同时就餐的数量。比如同时最多允许四个哲学家就餐。</li>
</ol>
<p><em>下列代码实现的是第一种思路</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nicklaus.interview.synchronization;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhilosopherProblem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore[] chopsticks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        chopsticks = <span class="keyword">new</span> Semaphore[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ )</span><br><span class="line">            chopsticks[i] = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Philosopher</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Philosopher</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.number = number;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果编号是偶数就先拿起左边的筷子，再拿起右边的筷子</span></span><br><span class="line">            <span class="comment">//如果编号是奇数就先拿起右边的筷子，再拿起左边的筷子</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(number % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="comment">//偶数</span></span><br><span class="line">                        chopsticks[number].acquire(); <span class="comment">//拿起左边</span></span><br><span class="line">                        chopsticks[(number + <span class="number">1</span>) % <span class="number">5</span>].acquire(); <span class="comment">//拿起右边</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;哲学家 &quot;</span> + number + <span class="string">&quot; 此时正在吃饭！&quot;</span>);</span><br><span class="line">                        chopsticks[number].release();</span><br><span class="line">                        chopsticks[(number + <span class="number">1</span>) % <span class="number">5</span>].release();</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//奇数</span></span><br><span class="line">                        chopsticks[(number + <span class="number">1</span>) % <span class="number">5</span>].acquire(); <span class="comment">//拿起右边</span></span><br><span class="line">                        chopsticks[number].acquire(); <span class="comment">//拿起左边</span></span><br><span class="line">                        System.out.println(<span class="string">&quot;哲学家 &quot;</span> + number + <span class="string">&quot; 此时正在吃饭！&quot;</span>);</span><br><span class="line">                        chopsticks[(number + <span class="number">1</span>) % <span class="number">5</span>].release();</span><br><span class="line">                        chopsticks[number].release();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Philosopher(<span class="number">0</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Philosopher(<span class="number">1</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Philosopher(<span class="number">2</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Philosopher(<span class="number">3</span>));</span><br><span class="line">        threadPool.execute(<span class="keyword">new</span> Philosopher(<span class="number">4</span>));</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>死锁</tag>
        <tag>同步与互斥</tag>
      </tags>
  </entry>
  <entry>
    <title>做算法题的小技巧</title>
    <url>/2020/10/10/algorithm-1/</url>
    <content><![CDATA[<blockquote>
<p>在写算法题的过程中总结的一些经验和技巧，</p>
<p>希望有一天leet coin可以5000+！</p>
</blockquote>
<h2 id="java输入输出问题"><a href="#java输入输出问题" class="headerlink" title="java输入输出问题"></a>java输入输出问题</h2><h3 id="BufferedReader和Scanner"><a href="#BufferedReader和Scanner" class="headerlink" title="BufferedReader和Scanner"></a>BufferedReader和Scanner</h3><ul>
<li><p>首先明确一点BufferedReader的读取速度是要快于Scanner的，因为BufferedReader有缓冲区，默认大小为8kb，足够算法题的输入使用。</p>
</li>
<li><p>BufferedReader的缺点就是只能读入字符，如果要读取数字需要进行转换，readLine()根据enter键读取下一个输入。</p>
</li>
<li><p>Scanner的优点就是可以读入数字和字符，不需要转换(nextInt() | nextLine() | nextLong() …)，next()根据enter、空格、Tab键读取下一个输入。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输入：hello world</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.print(br.readLine()); <span class="comment">// print&gt; hello world</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(in.next()); <span class="comment">// print&gt; hello</span></span><br><span class="line">System.out.print(in.nextLine()); <span class="comment">// print&gt; hello world</span></span><br></pre></td></tr></table></figure>
<h3 id="BufferedWriter和System-out"><a href="#BufferedWriter和System-out" class="headerlink" title="BufferedWriter和System.out"></a>BufferedWriter和System.out</h3><ul>
<li>和BufferedReader一样，BufferedWriter也是缓冲流，将字符先写入缓冲区，调用flush方法之后，将字符输出。</li>
<li>System.out是标准的字符输出流，可以直接将字符输出，并自动flush</li>
<li>BufferedWriter比System.out的写速度要快<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出hello world</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// &gt;&gt; hello world</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">bw.write(<span class="string">&quot;hello world&quot;</span>); <span class="comment">// &gt;&gt; </span></span><br><span class="line">bw.flush(); <span class="comment">// &gt;&gt; hello world</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>BufferedWriter.write(int c) 输出乱码问题解决方案：</p>
<p>API中对于BufferedWriter的write(int c)解释为“Writes a single character”，所以其实写入的数据类型为char，内存长度只有2个字节，而且是以Unicode编码，所以会出现乱码。</p>
<p>故需要先将int强转为Integer, 再wirte(c.toString())即可。</p>
</blockquote>
<h3 id="写算法题的输入输出范例"><a href="#写算法题的输入输出范例" class="headerlink" title="写算法题的输入输出范例"></a>写算法题的输入输出范例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        String input = br.readLine();</span><br><span class="line">        String output = operate(input); <span class="comment">//operate看作是解决算法问题的方法</span></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        bw.write(output);</span><br><span class="line">        </span><br><span class="line">        bw.flush(); <span class="comment">//必须刷新缓冲区，否则无法打印结果</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果输出是浮点数，且要保留精度，或者格式化输出，还是使用System.out.printf;</p>
<p>可以使用bw.newLine()输出一个换行符。</p>
</blockquote>
<h2 id="算法小技巧"><a href="#算法小技巧" class="headerlink" title="算法小技巧"></a>算法小技巧</h2><h3 id="求最大公约数-辗转相除法"><a href="#求最大公约数-辗转相除法" class="headerlink" title="求最大公约数(辗转相除法)"></a>求最大公约数(辗转相除法)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = n, b = m; <span class="comment">//n和m是实际问题中的两个整数</span></span><br><span class="line"><span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> r = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a; <span class="comment">//此时a就是n,m的最大公约数</span></span><br></pre></td></tr></table></figure>
<h3 id="求最小公倍数"><a href="#求最小公倍数" class="headerlink" title="求最小公倍数"></a>求最小公倍数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">a和b的最小公倍数 = a*b / a和b的最大公约数</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>做算法题中常用的Java的Collections API</title>
    <url>/2020/10/15/algorithm-2/</url>
    <content><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote>
<p>Java中的ArrayList本质上就是一个动态数组，当你写如下代码时：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//ArrayList此时的默认容量为10</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">5</span>); <span class="comment">//ArrayList的容量为5</span></span><br><span class="line"><span class="comment">//当已经经过了很多次插入和删除操作，此时你写了如下代码</span></span><br><span class="line">arr.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//ArrayList会先去判断插入当前元素是否会超过当前数组大小;</span></span><br><span class="line"><span class="comment">//如果超过了，就将自身的容量扩容成当前的150%，(扩容的过程中会将当前数组的所有元素移动到扩容后的数组中去，这个操作十分耗时！)</span></span><br><span class="line">arr.add(<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//在下标是10的位置插入5;</span></span><br><span class="line"><span class="comment">//ArrayList先判断下标是否合法，再看是否需要扩容；</span></span><br><span class="line"><span class="comment">//将[index, currentSize-1]的元素复制到[index+1, currentSize]中，即index后的所有元素整体后移，这个操作也十分耗时！)</span></span><br><span class="line"><span class="comment">//再将值赋给arr[index]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201015/a-2.png" alt="ArrayList扩容源码"></p>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201015/a-2-1.png" alt="ArrayList.add(int index, E element)"></p>
<blockquote>
<p>E remove(int index) 和 boolean remove(Object O)和ArrayList中的add源码类似，ArrayList会将要删除元素下标index后面的元素整体往前移动1步，操作十分耗时！</p>
</blockquote>
<h3 id="什么情况下使用ArrayList"><a href="#什么情况下使用ArrayList" class="headerlink" title="什么情况下使用ArrayList"></a>什么情况下使用ArrayList</h3><ul>
<li>根据以上分析，当算法题涉及到的删除和插入操作不多，且要多次随机访问某给节点时，可以使用</li>
<li>ArrayList的优势就是随机访问某个节点的时间复杂度是O(1)</li>
</ul>
<h3 id="ArrayList的常用方法"><a href="#ArrayList的常用方法" class="headerlink" title="ArrayList的常用方法"></a>ArrayList的常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; demo1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">demo1.add(<span class="number">1</span>); <span class="comment">// 1. 添加一个元素</span></span><br><span class="line">ArrayList&lt;Integer&gt; demo1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">new</span> HashSet&lt;&gt;()); <span class="comment">// 2. 将其他Collections转换成一个ArrayList</span></span><br><span class="line">demo1.remove(<span class="number">0</span>); <span class="comment">// 3. 删除某个下标的元素，e.g. 删除下标为0的元素</span></span><br><span class="line">demo1.size(); <span class="comment">// 4. 返回当前ArrayList的长度</span></span><br><span class="line">demo1.clear(); <span class="comment">// 5.  清空ArrayList中的所有元素</span></span><br><span class="line">Collections.sort(demo1); <span class="comment">// 6. 将数组升序排序</span></span><br></pre></td></tr></table></figure>
<h3 id="ArrayList的遍历方式"><a href="#ArrayList的遍历方式" class="headerlink" title="ArrayList的遍历方式"></a>ArrayList的遍历方式</h3><ul>
<li>普通for循环</li>
<li>增强for循环</li>
<li>迭代器iterator循环</li>
</ul>
<blockquote>
<p>顺序删除ArrayList中所有元素的两种方式</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);<span class="comment">//假设array中已经存在10个元素</span></span><br><span class="line"><span class="comment">//普通for循环，从后往前删除(结合remove源码的特点)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = array.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    array.remove(i);</span><br><span class="line"><span class="comment">//迭代器删除，只能调用迭代器的remove方法，用ArrayList中的remove方法会抛异常</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = array.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    iterator.next();</span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将一个List转换成一个数组的两种方式，以整型Integer为例，假设已经有个变量名为list的ArrayList</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.就是直接开辟一个新的数组，通过遍历取值的方式来转换</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    arr[i] = list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用stream流的方式直接一行代码搞定</span></span><br><span class="line"><span class="keyword">int</span>[] arr = list.stream().mapToInt(number -&gt; number.intValue()).toArray();</span><br></pre></td></tr></table></figure>
<ul>
<li>方法一的代码执行速度要比方法二更快，因为方法二stream流操作需要额外的时间更多。</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><blockquote>
<p>LinkedList和ArrayList的使用场景恰好相反，LinkedList是链表，所以删除和插入操作的时间复杂度是O(1)，但是查找的时间复杂度却是O(n)。LinkedList同时还实现了Deque(双端队列)和Queue(队列)，所以LinkedList实际上是一个双向链表</p>
</blockquote>
<h3 id="作为链表使用"><a href="#作为链表使用" class="headerlink" title="作为链表使用"></a>作为链表使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>); <span class="comment">// 1.插入一个元素</span></span><br><span class="line">list.addFirst(<span class="number">3</span>); <span class="comment">// 2.在链表头部插入一个元素</span></span><br><span class="line">list.addLast(<span class="number">4</span>); <span class="comment">// 3.在链表的尾部插入一个元素</span></span><br></pre></td></tr></table></figure>
<h3 id="作为队列-Queue-使用"><a href="#作为队列-Queue-使用" class="headerlink" title="作为队列(Queue)使用"></a>作为队列(Queue)使用</h3><blockquote>
<p>队列特点：先进先出</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">1</span>); <span class="comment">// 1.从队尾插入一个元素</span></span><br><span class="line">queue.poll(); <span class="comment">// 2.返回并从队首弹出一个元素</span></span><br><span class="line">queue.peek(); <span class="comment">// 3.返回队首元素</span></span><br><span class="line">queue.isEmpty(); <span class="comment">// 4.判断队列是否为空</span></span><br><span class="line">queue.size(); <span class="comment">// 5.返回队列元素的个数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：使用数组队列ArrayDeque的速度要比LinkedList快！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;Deque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="作为双端队列-Deque-使用"><a href="#作为双端队列-Deque-使用" class="headerlink" title="作为双端队列(Deque)使用"></a>作为双端队列(Deque)使用</h3><p>双端队列特点：队首和队尾均可插入和弹出</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(<span class="number">1</span>); <span class="comment">// 1.从队尾插入一个元素 &gt;&gt; 1</span></span><br><span class="line">deque.offerFirst(<span class="number">2</span>); <span class="comment">//2.从队首插入一个元素 &gt;&gt; 2 1</span></span><br><span class="line">deque.offerLast(<span class="number">3</span>); <span class="comment">//3.从队尾插入一个元素 &gt;&gt; 2 1 3</span></span><br><span class="line">deque.peekFirst(); <span class="comment">//4.返回队首元素</span></span><br><span class="line">deque.peekLast(); <span class="comment">//5.返回队尾元素</span></span><br><span class="line">deque.pollFirst(); <span class="comment">//6.返回并弹出队首元素 &gt;&gt; 1 3</span></span><br><span class="line">deque.pollLast(); <span class="comment">//7.返回并弹出队尾元素 &gt;&gt; 1</span></span><br><span class="line">deque.isEmpty();</span><br><span class="line">deque.size();</span><br></pre></td></tr></table></figure>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><blockquote>
<p>Java中LinkedList是用链表实现的堆栈，Stack类是用数组实现的堆栈</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">1</span>);stack.push(<span class="number">3</span>); <span class="comment">// 1.往栈顶插入一个元素</span></span><br><span class="line">stack.peek(); <span class="comment">// 2.返回栈顶元素</span></span><br><span class="line">stack.pop(); <span class="comment">// 3.返回并弹出栈顶元素</span></span><br><span class="line">stack.size(); <span class="comment">// 4.返回栈的元素个数</span></span><br><span class="line">stack.empty(); <span class="comment">// 5.true 栈为空， false 栈非空</span></span><br></pre></td></tr></table></figure>
<h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><blockquote>
<p>Java中的优先队列是用堆实现的</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化时传入一个比较器，则按照比较器的规则进行排序</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;&gt;());</span><br><span class="line"><span class="comment">//不传入比较器则按照默认规则进行排序，比如按照数字的升序进行排列</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue2 = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">queue2.add(<span class="number">1</span>); <span class="comment">// 1.插入一个元素</span></span><br><span class="line">queue2.peek(); <span class="comment">// 2.返回堆顶元素</span></span><br><span class="line">queue2.poll(); <span class="comment">// 3.返回并删除堆顶元素</span></span><br><span class="line">queue2.size(); queue2.isEmpty();</span><br></pre></td></tr></table></figure>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote>
<p>目前算法中常用到HashSet，TreeSet在后续题目中用到再回来记录</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashSet常用于去重</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span>  HashSet&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span>[] numgbers = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(set.contains(numbers[i]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//write the code for target logic of algorithm</span></span><br><span class="line">    &#125;</span><br><span class="line">   set.add(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote>
<p>这里的map也只介绍HashMap，Java中的HashMap解决冲突的方式使用的是链寻址法，在冲突位置使用的是一颗平衡树(红黑树)来存储冲突元素，即最坏的时间复杂度为O(log n)。同时HashMap还有第二种解决冲突的方式，名为开放寻址法，即在发生冲突时，不断地往后找，直到找到一个没有存过值的位置来存储元素，一般开放寻址法的hash表的大小是原数组的2~3倍。（具体的hash散列的描述请看<a href="https://www.dylan-club.top/2020/10/28/java-basic-1/">hash表的基本原理以及Java的hash表部分源码的个人理解</a>）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//HashMap初始化</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; personMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加一个键值对</span></span><br><span class="line">        personMap.put(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//判断HashMap中是否含有某一个键</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = personMap.containsKey(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//根据key获取value</span></span><br><span class="line">        <span class="keyword">int</span> age = personMap.get(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//根据键删除一个entry</span></span><br><span class="line">        personMap.remove(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//根据keyset来遍历values</span></span><br><span class="line">        Set&lt;String&gt; keyset = personMap.keySet();</span><br><span class="line">        <span class="keyword">for</span>(String key : keyset)&#123;</span><br><span class="line">            System.out.println(personMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树的创建以及遍历方式（Java实现）</title>
    <url>/2020/10/18/algorithm-3/</url>
    <content><![CDATA[<h2 id="二叉搜索树是什么？"><a href="#二叉搜索树是什么？" class="headerlink" title="二叉搜索树是什么？"></a>二叉搜索树是什么？</h2><p><strong>通俗一点说就是，对于一颗二叉树所有的非叶子节点，满足它的左儿子节点（如果有的话）一定小于它，它的右儿子节点（如果有的话）一定大于它。</strong></p>
<h2 id="二叉树搜索树的创建"><a href="#二叉树搜索树的创建" class="headerlink" title="二叉树搜索树的创建"></a>二叉树搜索树的创建</h2><h3 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个根节点</span></span><br><span class="line">    TreeNode root;</span><br><span class="line">    <span class="comment">//定义树的结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode leftChild;</span><br><span class="line">        TreeNode rightChild;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意一下，如果建立了一个BinarySearchTree的测试类，我们要在外部初始化一个TreeNode对象需要如何做呢？</p>
<blockquote>
<p>1.假如该内部类是常规的内部类，那么这个类的对象就是属于它外部那个类的对象的，因此如果我们想要实例化内部类的话，就需要先创建一个外部类的对象，再通过外部类的对象来初始化内部类。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinarySearchTree.TreeNode node = <span class="keyword">new</span> BinarySearchTree().<span class="function">new <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.假如该内部类是静态内部类，那么这个内部类的对象显然就是属于外部类的了，可以不用实例化外部类了，代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BinarySearchTree.TreeNode node = <span class="keyword">new</span> BinarySearchTree.<span class="function">new <span class="title">TreeNode</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="二叉树的插入"><a href="#二叉树的插入" class="headerlink" title="二叉树的插入"></a>二叉树的插入</h3><p>依次插入：45、32、64、14、40、50、80</p>
</blockquote>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-1.jpg" alt="二叉搜索树插入图解"></p>
<blockquote>
<p>从图解中我们不难发现，二叉树的插入的思想就是从根节点开始往下找，直到找到一个叶子节点，满足这个点只比这个叶子节点大或者小，直接把该点插入到该叶子节点的左儿子或者右儿子节点，那么代码就可以写成：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义树的迭代器</span></span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//如果值小于node</span></span><br><span class="line">        <span class="keyword">if</span>(value &lt; node.val)&#123;</span><br><span class="line">            <span class="comment">//如果node的左儿子节点存在，就继续循环</span></span><br><span class="line">            <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)</span><br><span class="line">                node = node.leftChild;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明该点已经是叶子节点，可以插入了</span></span><br><span class="line">                TreeNode newNode = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                node.leftChild = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果node的右儿子节点存在，就继续循环</span></span><br><span class="line">            <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)</span><br><span class="line">                node = node.rightChild;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode newNode = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                node.rightChild = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开始之前：前序、中序和后序遍历都是相对于根节点而言的。即前序遍历是先遍历根节点、再遍历左子树、再遍历右子树；中序遍历是先遍历左子树、再遍历根节点、再遍历右子树；后序遍历是先遍历左子树、再遍历右子树、再遍历根节点。算法题中后序遍历用得相对较多。</p>
</blockquote>
<h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-2.jpg" alt="二叉搜索树的前序遍历图解"></p>
<ul>
<li>看完图解可以很快想出一种递归的写法，就是每次递归的搜索左子树时，先打印一下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrder(root.leftChild);</span><br><span class="line">    preOrder(root.rightChild);</span><br><span class="line">&#125;</span><br><span class="line">&gt; <span class="number">45</span> <span class="number">32</span> <span class="number">14</span> <span class="number">40</span> <span class="number">64</span> <span class="number">50</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-3.jpg" alt="二叉搜索树前序遍历栈模拟"></p>
<blockquote>
<p>非递归思路：就是用一个栈来存储节点，每次抛出栈顶元素，并将栈顶元素的右儿子和左儿子依次加入栈中，直到栈为空。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="comment">//打印值</span></span><br><span class="line">        System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.rightChild);</span><br><span class="line">        <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.leftChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-4.jpg" alt="二叉搜索树的中序遍历图解"></p>
<blockquote>
<p>从图解中我们可以发现，如果要用递归来实现的话，我们需要先用dfs穷尽左子树，然后再回溯到根节点，再回溯到右子树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.leftChild);</span><br><span class="line">    Systemn.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    inOrder(root.rightChild);</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">14</span> <span class="number">32</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">64</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>用栈实现的非递归做法就不能像前序遍历那种实现了，因为我们需要用到左子树。那么我们就可以利用递归的思路，先穷尽左子树，再将栈顶弹出，再回溯右子树。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//node是穷尽左子树的指针</span></span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="comment">//穷尽左子树</span></span><br><span class="line">            node = node.leftChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//执行到这里说明左子树已经被穷尽了，我们就需要弹出栈顶元素，回溯根节点和右子树</span></span><br><span class="line">            TreeNode top = stack.pop();</span><br><span class="line">            <span class="comment">//打印结果</span></span><br><span class="line">            System.out.print(top.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//回溯右子树</span></span><br><span class="line">            node = top.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-5.jpg" alt="二叉搜索树后序遍历图解"></p>
<blockquote>
<p>后序遍历其实就是先穷尽左子树，再穷尽右子树，最后将结果打印再回溯！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.leftChild);</span><br><span class="line">    postOrder(root.rightChild);</span><br><span class="line">    System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">14</span> <span class="number">40</span> <span class="number">32</span> <span class="number">50</span> <span class="number">80</span> <span class="number">64</span> <span class="number">45</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在前序遍历中我们使用了栈先存储右子节点，再存储左子节点的方式来实现递归的模拟。其实如果我们将栈顶元素抛出，再加入栈顶元素的左儿子和右儿子，会有什么状况发生呢？</p>
<p>遍历的顺序就会变为：根节点-&gt;右子树-&gt;左子树</p>
<p>如果将结果逆序我们会发现：左子树-&gt;右子树-&gt;根节点，正好是后序遍历！所以我们只需要用一个辅助栈来存储每次弹出的栈顶元素即可！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; favor = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        favor.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.leftChild);</span><br><span class="line">        <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印辅助栈即可</span></span><br><span class="line">    <span class="keyword">while</span>(!favor.isEmpty())</span><br><span class="line">        System.out.print(favor.pop() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><blockquote>
<p>层序遍历较上面三种排序就更好理解，就是从左到右一次打印每一层的节点，只需要一个队列来模拟广度优先搜索即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode top = queue.poll();</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.print(top.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(top.leftChild != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(top.leftChild);</span><br><span class="line">        <span class="keyword">if</span>(top.rightChild != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(top.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">45</span> <span class="number">32</span> <span class="number">64</span> <span class="number">14</span> <span class="number">40</span> <span class="number">50</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>有关二叉搜索树的难点主要在于后序遍历的非递归写法怎么建模更简单，同时要深入理解递归和回溯的顺序才行，不能知其然而不知其所以然。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的位运算符总结以及算法技巧</title>
    <url>/2020/10/23/algorithm-4/</url>
    <content><![CDATA[<h2 id="amp-运算符"><a href="#amp-运算符" class="headerlink" title="&amp;运算符"></a>&amp;运算符</h2><p><strong>比如两个整型（int）数字使用&amp;运算符，那么将这两个数转换成二进制表示形式，两个数的每一位进行比较，如果两位均为以1，则该位为1，否则为0</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a = 5; 二进制表示形式 101</span></span><br><span class="line"><span class="comment">//b = 3; 二进制表示形式 011</span></span><br><span class="line"><span class="keyword">int</span> c = a &amp; b;</span><br><span class="line">print c; <span class="comment">// &gt; 结果的二进制表示形式 001</span></span><br></pre></td></tr></table></figure>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="判断某一个数的二进制表示形式最后一位是否为1"><a href="#判断某一个数的二进制表示形式最后一位是否为1" class="headerlink" title="判断某一个数的二进制表示形式最后一位是否为1"></a>判断某一个数的二进制表示形式最后一位是否为1</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3369</span>;</span><br><span class="line"><span class="keyword">int</span> b = a &amp; <span class="number">1</span>;</span><br><span class="line">&gt; 如果a最后一位是<span class="number">1</span>,b == <span class="number">1</span>; 反之, b == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="| 运算符"></a>| 运算符</h2><p><strong>将两个整型（int）数字使用|运算符，那么将这两个数转换成二进制表示形式，两个数的每一位进行比较，如果两位中至少有一位是1，则该位为1，否则为0</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a = 5; 二进制表示形式 101</span></span><br><span class="line"><span class="comment">//b = 3; 二进制表示形式 011</span></span><br><span class="line"><span class="keyword">int</span> c = a | b;</span><br><span class="line">print c; <span class="comment">// &gt; 结果的二进制表示形式 111 (十进制表示形式为7)</span></span><br></pre></td></tr></table></figure>
<h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><h4 id="可以还原一个整数"><a href="#可以还原一个整数" class="headerlink" title="可以还原一个整数"></a>可以还原一个整数</h4><p><strong>比如我们在做算法题时，我们只能依次从高位向低位得到一个数的某一位1，如何还原这个数？</strong></p>
<blockquote>
<p>第一个bit位为$(1000)_2$，即 bit1 = 8;</p>
<p>第二个bit位为$(0010)_2$，即bit2 = 2;</p>
<p>第三个bit位为$(0001)_2$，即bit3 = 1;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> realNum = bit1 | bit2 | bit3;</span><br><span class="line">&gt; print realNum <span class="number">11</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="运算符-1"><a href="#运算符-1" class="headerlink" title="~ 运算符"></a>~ 运算符</h2><p><strong>在一个整型（int）数字前使用~运算符，就是将这个数的二进制表示形式的每一位取反，即如果该位是1就会变成0；反之，就会由0变成1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>;</span><br><span class="line"><span class="comment">// 二进制表示形式 00000000000000000000000000001000</span></span><br><span class="line">System.out.println(Integer.toBinaryString(a)); </span><br><span class="line"><span class="comment">// 二进制表示形式 11111111111111111111111111110111</span></span><br><span class="line">System.out.println(Integer.toBinaryString(~a));</span><br><span class="line">System.out.println(~a); <span class="comment">// -9</span></span><br></pre></td></tr></table></figure>
<h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><h4 id="不使用—运算符表示一个数的负数"><a href="#不使用—运算符表示一个数的负数" class="headerlink" title="不使用—运算符表示一个数的负数"></a>不使用—运算符表示一个数的负数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如何表示-8</span></span><br><span class="line"><span class="keyword">int</span> neA = (~a) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="返回一个数的最后一位1的十进制表示形式"><a href="#返回一个数的最后一位1的十进制表示形式" class="headerlink" title="返回一个数的最后一位1的十进制表示形式"></a>返回一个数的最后一位1的十进制表示形式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">n &amp; -n; <span class="comment">//根据取反+1来理解就容易多了</span></span><br></pre></td></tr></table></figure>
<h2 id="运算符-2"><a href="#运算符-2" class="headerlink" title="^ 运算符"></a>^ 运算符</h2><p><strong>将两个整型（int）数字使用^(异或)运算符，那么将这两个数转换成二进制表示形式，两个数的每一位进行比较，两位相同得0，不同为1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">8</span>; <span class="comment">// 二进制表示形式 1000</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">12</span>; <span class="comment">// 二进制表示形式 1100</span></span><br><span class="line">System.out.print(a ^ b); <span class="comment">// 结果为4</span></span><br></pre></td></tr></table></figure>
<h3 id="规律"><a href="#规律" class="headerlink" title="规律"></a>规律</h3><ul>
<li>任何数和本身异或则为 <code>0</code></li>
<li><p>任何数和 0 异或是 <code>本身</code></p>
</li>
<li><p>异或满足交换律。 即 <code>a ^ b ^ c</code> ，等价于 <code>a ^ c ^ b</code></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">System.out.println(a ^ b); <span class="comment">// 结果为12</span></span><br><span class="line">System.out.println(a ^ a); <span class="comment">// 结果为0</span></span><br></pre></td></tr></table></figure>
<h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><h4 id="比如一个数组中只有1个数的数量为1，其他数的数量都为2，如何使用O-n-的时间复杂度，O-1-的空间复杂度解决这个问题？"><a href="#比如一个数组中只有1个数的数量为1，其他数的数量都为2，如何使用O-n-的时间复杂度，O-1-的空间复杂度解决这个问题？" class="headerlink" title="比如一个数组中只有1个数的数量为1，其他数的数量都为2，如何使用O(n)的时间复杂度，O(1)的空间复杂度解决这个问题？"></a>比如一个数组中只有1个数的数量为1，其他数的数量都为2，如何使用O(n)的时间复杂度，O(1)的空间复杂度解决这个问题？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++ )</span><br><span class="line">    a ^= nums[i];</span><br><span class="line"><span class="keyword">return</span> a;</span><br></pre></td></tr></table></figure>
<h2 id="lt-lt-运算符"><a href="#lt-lt-运算符" class="headerlink" title="&lt;&lt; 运算符"></a>&lt;&lt; 运算符</h2><p><strong>左移运算符是将运算符左边的数整体向左移动运算符右边指定的位数（低位补0）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">System.out.println(a &lt;&lt; <span class="number">4</span>); <span class="comment">//结果为 16 (二进制表示 00001 -&gt; 10000)</span></span><br></pre></td></tr></table></figure>
<h3 id="应用-4"><a href="#应用-4" class="headerlink" title="应用"></a>应用</h3><h4 id="将1移动到指定位置-常用于需要用二进制数解题的情况"><a href="#将1移动到指定位置-常用于需要用二进制数解题的情况" class="headerlink" title="将1移动到指定位置(常用于需要用二进制数解题的情况)"></a>将1移动到指定位置(常用于需要用二进制数解题的情况)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> &lt;&lt; n; <span class="comment">// n 表示具体移动的位数</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">// 结果为 -2147483648，因为int是32位整数，最高位是符号位, 符号位1为负数，0为正数</span></span><br><span class="line"><span class="comment">//值得的是 1 &lt;&lt; 32 的结果是 1, 1 &lt;&lt; 33 的结果是2，所以说可以看成32位一次周期循环</span></span><br></pre></td></tr></table></figure>
<h2 id="gt-gt-运算符"><a href="#gt-gt-运算符" class="headerlink" title="&gt;&gt; 运算符"></a>&gt;&gt; 运算符</h2><p><strong>“有符号”右移运算符，将运算符左边的对象向右移动运算符右边指定的位数。使用符号扩展机制，也就是说，如果值为正，则在高位补0，如果值为负，则在高位补1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">13</span>; <span class="comment">// 二进制表示形式为 1101</span></span><br><span class="line"><span class="keyword">int</span> b = a &gt;&gt; <span class="number">2</span>; <span class="comment">// 表示将12转换成二进制，然后将整体右移两位，结果为 11</span></span><br><span class="line">System.out.println(b); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>特别注意：a本身的最高位1是第四位，如果将a右移5五位会怎么样呢？</p>
<p>当右移的位数超过某个数最高位1的位数时，答案始终为0！（该结论仅适用于该数为正数的情况）</p>
</blockquote>
<h2 id="gt-gt-gt-运算符"><a href="#gt-gt-gt-运算符" class="headerlink" title="&gt;&gt;&gt; 运算符"></a>&gt;&gt;&gt; 运算符</h2><p><strong>“无符号”右移运算符，将运算符左边的对象向右移动运算符右边指定的位数。采用0扩展机制，也就是说，无论值的正负，都在高位补0</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> b = -<span class="number">8</span>;</span><br><span class="line">System.out.println(a &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 结果为 3 (二进制表示形式 1100 -&gt; 11)</span></span><br><span class="line">System.out.println(b &gt;&gt;&gt; <span class="number">2</span>); <span class="comment">// 结果为 1073741822 (无符号右移是高位补0，所以负数变成正数)</span></span><br></pre></td></tr></table></figure>
<h2 id="二进制原码、反码、补码"><a href="#二进制原码、反码、补码" class="headerlink" title="二进制原码、反码、补码"></a>二进制原码、反码、补码</h2><blockquote>
<p>以int32位整型举例（比如用2来举例）</p>
</blockquote>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><p><strong>原码的第一位为符号位（同一个数字的正数和负数只有第一位符号位不同）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>的原码： <span class="number">00000000</span>	<span class="number">00000000</span>	<span class="number">00000000</span>	<span class="number">00000010</span></span><br><span class="line">-<span class="number">2</span>的原码：<span class="number">10000000</span>	<span class="number">00000000</span>	<span class="number">00000000</span>	<span class="number">00000010</span></span><br></pre></td></tr></table></figure>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><p><strong>正数的反码与原码相同，负数的反码在原码的基础上，符号位不变，其余的按位取反</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>的原码： <span class="number">00000000</span>	<span class="number">00000000</span>	<span class="number">00000000</span>	<span class="number">00000010</span></span><br><span class="line">-<span class="number">2</span>的原码：<span class="number">11111111</span>	<span class="number">11111111</span>	<span class="number">11111111</span>	<span class="number">11111101</span></span><br></pre></td></tr></table></figure>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p><strong>正数的补码就是原码本身，负数的补码是它的反码+1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>的原码： <span class="number">00000000</span>	<span class="number">00000000</span>	<span class="number">00000000</span>	<span class="number">00000010</span></span><br><span class="line">-<span class="number">2</span>的原码：<span class="number">11111111</span>	<span class="number">11111111</span>	<span class="number">11111111</span>	<span class="number">11111110</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java是使用补码进行整数运算的！</p>
</blockquote>
<h2 id="综合运用：不使用“-”实现两个数相加"><a href="#综合运用：不使用“-”实现两个数相加" class="headerlink" title="综合运用：不使用“+ - * /”实现两个数相加"></a>综合运用：不使用“+ - * /”实现两个数相加</h2><blockquote>
<p>分析：a ^ b 异或是不进位加法， a &amp; b &lt;&lt; 1 与是计算两个数相加的进位，所以可以使用一个循环，重复计算直到进位0！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = c;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(a);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>基础算法常用模板</title>
    <url>/2020/10/06/algorithmTemplate-1/</url>
    <content><![CDATA[<ul>
<li>常用排序、二分、高精度、前缀和、差分、位运算、双指针、离散化、区间合并<a id="more"></a>
</li>
</ul>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left-<span class="number">1</span>, j=right+<span class="number">1</span>, x=arr[(left+right)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(arr[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(arr[j] &gt; x);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    quickSort(arr, left, j);</span><br><span class="line">    quickSort(arr, j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left == right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(arr, left, mid);</span><br><span class="line">    mergeSort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//temp数组用于临时存放left到right的有序数列</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[k++] = arr[i++]; </span><br><span class="line">        <span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数依次放到temp数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right) temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    <span class="keyword">for</span>(i=left, j=<span class="number">0</span>; i &lt;= right; i++, j++) arr[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i]; <span class="comment">//找出第i小的元素，并放到数组的下标i中</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;min)&#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">       	<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">//将元素i插入到有序数列0,1,2...i-1中</span></span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]; j--)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二分查找-两种情况"><a href="#二分查找-两种情况" class="headerlink" title="二分查找(两种情况)"></a>二分查找(两种情况)</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) right = mid; <span class="comment">//满足区间在左半边</span></span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) left = mid; <span class="comment">//满足区间在右半边</span></span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：浮点数二分可以用于开n次方，也不用判断边界条件</span></span><br></pre></td></tr></table></figure>
<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">add</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A + B 数字均为逆序存储，例：12345被存储为54321</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//假设A&gt;B</span></span><br><span class="line">    <span class="keyword">if</span>(A.size() &lt; B.size())</span><br><span class="line">        <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果就是t%10的余数</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后一次加法如果还有进位就把t加到结果中</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">sub</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">  	<span class="comment">//假设A&gt;B,C = A - B</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t = A.get(i) - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t -= B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果有两种情况，一种是需要借位，一种是不需要</span></span><br><span class="line">        C.add((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算借位</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果可能为000123的情况，所以要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.get(C.size()-<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mul</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//A为高精度，b为低精度，C = Axb</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i)*b;</span><br><span class="line">        <span class="comment">//第i位的结果t % 10</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断最后一次计算是否有进位</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果b为0，计算结果可能为00000，故需要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> r; <span class="comment">//余数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">div</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A / b</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=A.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span>+A.get(i);</span><br><span class="line">       	<span class="comment">//第i位结果</span></span><br><span class="line">        C.add(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序存储</span></span><br><span class="line">    Collections.reverse(C);</span><br><span class="line">    <span class="comment">//结果可能为011，去除前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>]+a[<span class="number">2</span>]+...+a[i];</span><br><span class="line">a[l]~a[r]的和=S[r] - S[l-<span class="number">1</span>]; <span class="comment">//a[0] = 0; S[0] = 0</span></span><br></pre></td></tr></table></figure>
<h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">S[i][j]为第i行j列左上部分所有元素的和</span><br><span class="line">求左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的和：</span><br><span class="line">A = S[x2][y2] - S[x1-<span class="number">1</span>][y2] - S[x2][y1-<span class="number">1</span>] + S[x1-<span class="number">1</span>][y1-<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">已知a[], b[],b[]为a[]的差分数组，即a[i] = b[<span class="number">0</span>]+b[<span class="number">1</span>]+...+b[i];</span><br><span class="line">给下标区间为[l,r]的a[]都加上常数c &lt;=&gt; b[l] += c, b[r+<span class="number">1</span>] -= c;</span><br></pre></td></tr></table></figure>
<h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">给左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的每一个元素加上c(先构造差分矩阵再插入)</span><br><span class="line">&lt;=&gt; </span><br><span class="line">b[x1][y1] += c,</span><br><span class="line">b[x1][y2+<span class="number">1</span>] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y1] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求n的第k位数字（n为二进制表示形式）</span></span><br><span class="line">n &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//返回n的最后一位1（n为二进制表示形式）</span></span><br><span class="line">lowbit(n) <span class="keyword">return</span> n &amp; -n; </span><br></pre></td></tr></table></figure>
<h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="comment">// check(i, j) 表示根据题意设定的维护双指针的条件</span></span><br><span class="line">    <span class="keyword">while</span>(check(i, j)) j++;</span><br><span class="line">    <span class="comment">// 根据题意具体的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常见的问题有两类：<ul>
<li>对于一个序列，用两个指针维护一段区间</li>
<li>对于两个序列，维护某种次序，比如归并排序中合并两个子序列</li>
</ul>
</li>
</ul>
<h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;Integer&gt; alls; <span class="comment">//存储所有待离散化的值（已去重）</span></span><br><span class="line">List&lt;Integer&gt; allList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">allList.addAll(alls);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(allList, (a1, a2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (Integer)a1 - (Integer)a2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果要使用前缀和，返回值+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=allList.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(allList.get(mid) &gt;= x) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span>; <span class="comment">//映射到1,2,...,n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先将区间序列按照左端点排好序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = a;</span><br><span class="line">        <span class="keyword">this</span>.second = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设list已经排好序,list.size() &gt;= 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Pair&gt; <span class="title">merge</span><span class="params">(List&lt;Pair&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Pair&gt; res = <span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line">    <span class="comment">//先将第一个区间加到res中</span></span><br><span class="line">    res.add(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//判断两个区间是否有交集</span></span><br><span class="line">        <span class="keyword">if</span>(res.get(res.size()-<span class="number">1</span>).second &lt; list.get(i).first)&#123;</span><br><span class="line">            <span class="comment">//没有，直接加</span></span><br><span class="line">            res.add(list.get(i));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有，判断区间左端点是谁</span></span><br><span class="line">            <span class="keyword">int</span> second = res.get(res.size()-<span class="number">1</span>).second;</span><br><span class="line">            <span class="keyword">int</span> nSecond = list.get(i).second;</span><br><span class="line">            res.get(res.size()-<span class="number">1</span>).second = (second &gt; nSecond) ? second : nSecond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>位运算</tag>
        <tag>排序</tag>
        <tag>二分查找</tag>
        <tag>高精度</tag>
        <tag>前缀和与差分</tag>
        <tag>双指针</tag>
        <tag>离散化</tag>
        <tag>区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习作业</title>
    <url>/2020/11/06/homework-analysis/</url>
    <content><![CDATA[<h1 id="深度学习作业"><a href="#深度学习作业" class="headerlink" title="深度学习作业"></a>深度学习作业</h1><p><a href="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201105/%E5%88%98%E5%81%A5-20175302-%E8%BD%AF%E8%8B%B11802.pptx">深度学习ppt</a></p>
]]></content>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构常用模板</title>
    <url>/2020/10/16/algroithmTemplate-2/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章总结自AcWing算法基础课学习模板，主要有链表、栈、队列、单调栈、单调队列、KMP、字典树、并查集、堆、哈希散列的实现。</p>
</blockquote>
<h2 id="单链表（数组实现）"><a href="#单链表（数组实现）" class="headerlink" title="单链表（数组实现）"></a>单链表（数组实现）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head; <span class="comment">//链表的头指针</span></span><br><span class="line"><span class="keyword">int</span> idx; <span class="comment">//记录当前用到了数组的第几个下标</span></span><br><span class="line"><span class="comment">//假设N是一个很大的常数</span></span><br><span class="line"><span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的值</span></span><br><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的next指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = -<span class="number">1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往链表头部插入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    next[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表的头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = next[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双链表（数组实现）"><a href="#双链表（数组实现）" class="headerlink" title="双链表（数组实现）"></a>双链表（数组实现）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的左指针</span></span><br><span class="line"><span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的右指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">    left[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//0表示右端点</span></span><br><span class="line">    right[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//1表示左端点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的右侧插入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    right[idx] = right[a];</span><br><span class="line">    left[idx] = a;</span><br><span class="line">    left[right[a]] = idx;</span><br><span class="line">    right[a] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    right[left[a]] = right[a];</span><br><span class="line">    left[right[a]] = left[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="栈（数组实现）"><a href="#栈（数组实现）" class="headerlink" title="栈（数组实现）"></a>栈（数组实现）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>; <span class="comment">//栈顶指针</span></span><br><span class="line"><span class="keyword">int</span>[] stk = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//使用数组存储栈的元素</span></span><br><span class="line">stk[++tt] = x; <span class="comment">//往栈中push一个元素</span></span><br><span class="line">tt--; <span class="comment">//从栈中pop一个元素</span></span><br><span class="line">stk[tt]; <span class="comment">//栈顶的元素</span></span><br><span class="line">tt &gt; <span class="number">0</span>; <span class="comment">//判断栈顶的值是否为空</span></span><br></pre></td></tr></table></figure>
<h2 id="队列（数组实现）"><a href="#队列（数组实现）" class="headerlink" title="队列（数组实现）"></a>队列（数组实现）</h2><h3 id="普通队列（双端队列）"><a href="#普通队列（双端队列）" class="headerlink" title="普通队列（双端队列）"></a>普通队列（双端队列）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>; <span class="comment">//队首指针</span></span><br><span class="line"><span class="keyword">int</span> tt = -<span class="number">1</span>; <span class="comment">//队尾指针</span></span><br><span class="line"><span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N]； <span class="comment">//用于存放队列中的元素</span></span><br><span class="line">q[++tt] = x; <span class="comment">//往队列中offer一个元素</span></span><br><span class="line">hh++; <span class="comment">//从队列中poll一个元素</span></span><br><span class="line">q[hh]; <span class="comment">//队首元素</span></span><br><span class="line">hh &lt;= tt; <span class="comment">//判断队列是否为空</span></span><br></pre></td></tr></table></figure>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//由于用数组实现队列，经过多次插入和弹出之后，队列走到了数组的末端，但是数组的前半部分仍然有剩余</span></span><br><span class="line"><span class="comment">//所以可以用循环队列，来保证在大部分情况下，可以存储较多的元素</span></span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//循环队列最多存N-1个元素</span></span><br><span class="line">q[tt++] = x; <span class="comment">//往队尾插入一个元素</span></span><br><span class="line"><span class="comment">//从队首弹出一个元素</span></span><br><span class="line">hh ++;</span><br><span class="line"><span class="keyword">if</span>(hh==N) hh = <span class="number">0</span>;</span><br><span class="line">q[hh]; <span class="comment">//队首元素</span></span><br><span class="line">hh != tt <span class="comment">//判断队列是否为空</span></span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote>
<p>常见题型：找出每个数左边离他最近比他大（或小）的数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>; <span class="keyword">int</span>[] stk = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8.</span>..&#125; <span class="comment">//假定a为输入数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(tt &gt; <span class="number">0</span> &amp;&amp; check(stk[tt], a[i])) tt--;</span><br><span class="line">    stk[++tt] = a[i];</span><br><span class="line">    <span class="comment">//具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><blockquote>
<p>经典题型：滑动窗口的最大值/最小值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>; <span class="keyword">int</span> tt = -<span class="number">1</span>; <span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8.</span>..&#125; <span class="comment">//假定a数组为输入数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//checkOut函数判断队首是否在窗口外</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; checkOut()) hh++;</span><br><span class="line">    <span class="comment">//check函数为具体算法的判断函数</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; check(q[tt], a[i])) tt--;</span><br><span class="line">    q[++tt] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>]; <span class="comment">//长文本（下标从1开始）</span></span><br><span class="line"><span class="keyword">char</span>[] p = <span class="keyword">new</span> <span class="keyword">char</span>[m+<span class="number">1</span>]; <span class="comment">//模式串（下标从1开始）</span></span><br><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>]; <span class="comment">//模式串的next数组</span></span><br><span class="line"><span class="comment">//求next数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果前缀和后缀字符串不匹配，就向前看一步</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//更新next数组</span></span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配过程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//和构建next数组的过程类似</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//找到了之后</span></span><br><span class="line">    <span class="keyword">if</span>(j==m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功的具体逻辑</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Trie树（字典树）"><a href="#Trie树（字典树）" class="headerlink" title="Trie树（字典树）"></a>Trie树（字典树）</h2><blockquote>
<p>常见题型：给一个字符串数组，问某个字符串出现的次数</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] son = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">26</span>]; <span class="comment">//假设字符串是26个小写字母,son存放每个节点的子节点</span></span><br><span class="line"><span class="comment">//下标为0的点是根节点</span></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//记录以某个下标结尾的字符串出现的次数</span></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>; <span class="comment">//记录当前用到了数组的哪一个下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>; <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//如果这个字母之前没有出现</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>) son[p][u] = idx++;</span><br><span class="line">        <span class="comment">//重新定位根节点</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录该字符串出现的次数</span></span><br><span class="line">    count[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个字符串出现的次数（和插入有些类似）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//如果当前字母没有出现过，说明该字符串不在该数组中，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新定位根节点</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote>
<p>有两个集合，想要查看数a,b是否在同一个集合中，想要合并两个集合，如果在题目中出现这样的情况，想一想这个问题能否用并查集来解决！</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"><span class="comment">//p数组存放的每个节点的祖宗节点</span></span><br><span class="line"><span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集的核心，find函数，返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集，假设节点的编号为1~n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=nl i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合a合并到集合b中去</span></span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"><span class="comment">//size数组存放的每个节点所在的集合的大小，注意只有祖宗节点的size才有意义</span></span><br><span class="line"><span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N], size = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集和size数组，假设节点的编号为1~n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先判断a,b是否在同一个集合中</span></span><br><span class="line"><span class="keyword">if</span>(find(a) != find(b))</span><br><span class="line">&#123;</span><br><span class="line">    size[find(b)] += size[find(a)];</span><br><span class="line">    p[find(a)] = find(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集</span><br><span class="line"><span class="comment">//d[x]存储x到p[x]的距离</span></span><br><span class="line"><span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N], d = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = find(p[x]);</span><br><span class="line">        <span class="comment">//由于p[x]都要指向祖宗节点，所以要更新d[x]</span></span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a集合合并到b集合中</span></span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line"><span class="comment">//根据具体问题计算distance</span></span><br><span class="line">d[find(a)] = distance;</span><br></pre></td></tr></table></figure>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h存储堆中的值，h[1]为堆顶，x的左儿子是2x，x的右儿子是2x+1</span></span><br><span class="line"><span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">//hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="keyword">int</span>[] ph = <span class="keyword">new</span> <span class="keyword">int</span>[N], hp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//表示堆的大小</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个节点的值及其映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//交换ph映射</span></span><br><span class="line">    <span class="keyword">int</span> tempIndex = ph[hp[a]];</span><br><span class="line">    ph[hp[a]] = ph[hp[b]];</span><br><span class="line">    ph[hp[b]] = tempOrder;</span><br><span class="line">    <span class="comment">//交换hp映射</span></span><br><span class="line">    <span class="keyword">int</span> tempK = hp[a];</span><br><span class="line">    hp[a] = hp[b];</span><br><span class="line">    hp[b] = tempK;</span><br><span class="line">    <span class="comment">//交换值</span></span><br><span class="line">    <span class="keyword">int</span> temp = h[a];</span><br><span class="line">    h[a] = h[b];</span><br><span class="line">    h[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempIndex = index;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*index &lt;= size &amp;&amp; h[<span class="number">2</span>*index] &lt; h[tempIndex]) tempIndex = <span class="number">2</span>*index;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*index+<span class="number">1</span> &lt;= size &amp;&amp; h[<span class="number">2</span>*index+<span class="number">1</span>] &lt; h[tempIndex]) tempIndex = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果儿子节点比节点小则互换</span></span><br><span class="line">    <span class="keyword">if</span>(tempIndex != index)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(index, tempIndex);</span><br><span class="line">        <span class="comment">//递归下沉</span></span><br><span class="line">        down(tempIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//节点上浮的条件</span></span><br><span class="line">    <span class="keyword">while</span>(index/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; h[index] &lt; h[index/<span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(index, index/<span class="number">2</span>);</span><br><span class="line">        index &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h2><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//h数组中所有的初始值为-1</span></span><br><span class="line"><span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], value = <span class="keyword">new</span> <span class="keyword">int</span>[N], next = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向哈希表中插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    next[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在哈希表中查找某个数是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[k]; i!=-<span class="number">1</span>; i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(value[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果x在哈希表中，则返回x的下标，如果不在则返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != <span class="keyword">null</span> &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>( k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p><strong>核心思想：将字符串看成P进制的数，P的经验值是131或1331，取这两个值的冲突概率较低</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span>[] h = <span class="keyword">new</span> <span class="keyword">long</span>[N]; <span class="comment">//h[k]存储字符串前k个字母的哈希值</span></span><br><span class="line"><span class="keyword">long</span>[] p = <span class="keyword">new</span> <span class="keyword">long</span>[N]; <span class="comment">//p[k]存储P^k mod 2^64(Java中会溢出成负数，暂时不考虑字符串很长的情况)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i-<span class="number">1</span>]*P + str[i]; <span class="comment">//暂时不考虑取模的情况</span></span><br><span class="line">    p[i] = pp[i-<span class="number">1</span>]*P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算字串str[l~r]的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l-<span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>链表</tag>
        <tag>栈</tag>
        <tag>队列</tag>
        <tag>字符串</tag>
        <tag>并查集</tag>
        <tag>堆</tag>
        <tag>哈希散列</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第一章&gt;&gt;误差分析</title>
    <url>/2020/03/11/mathAnalysis-1-1/</url>
    <content><![CDATA[<h2 id="误差的来源与分类"><a href="#误差的来源与分类" class="headerlink" title="误差的来源与分类"></a>误差的来源与分类</h2><ul>
<li>观测误差</li>
<li>模型误差</li>
<li>截断误差：近似计算出现的误差<a id="more"></a></li>
<li>舍入误差：由于计算级只能进行有限位的运算而产生的误差</li>
<li>绝对误差:  $e=x^{*}-x$ 其中e为绝对误差<br>如果$\epsilon$满足：<br>  $|e|\leq\epsilon$, 则$\epsilon$为$x$的绝对误差限</li>
<li>相对误差：<br>  $e_r = \frac{x^* - x}{x} = \frac{e}{x}$, $e_r$为相对误差</li>
<li>相对误差限：<br>  $\epsilon_r=\frac{\epsilon}{|x|}$, $\epsilon_r$为相对误差限，同时$|e_r|\le\epsilon_r$</li>
</ul>
<h2 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a>有效数字</h2><ul>
<li>有效数字与绝对误差限的关系：<script type="math/tex; mode=display">
|x^*-x|\leq\frac{1}{2}\times10^{m-n},其中n为有效数字的位数。</script><script type="math/tex; mode=display">
m为x^*化为标准浮点数形式下的10m次幂。</script>注：精确值的有效数字有无穷多位！</li>
<li><p>有效数字和相对误差限的关系(其中$a_1$为$x$化为标准浮点数下小数点后第一个非零的数)：</p>
<ul>
<li><p>已知有效位数$n$:<br>  $\epsilon_r\le\frac{1}{2a_1}\times10^{-n+1}$</p>
</li>
<li><p>已知$x$的相对误差限:<br>  $\epsilon_r\le\frac{1}{2(a_1+1)}\times10^{-n+1}$</p>
</li>
</ul>
</li>
</ul>
<h2 id="数值计算中的若干原则"><a href="#数值计算中的若干原则" class="headerlink" title="数值计算中的若干原则"></a>数值计算中的若干原则</h2><ul>
<li>避免两个相近的数相减（使用其他算法，公式？乘除？）<script type="math/tex; mode=display">
假设z=x-y,z^*=x^*-y^*,那么：</script><script type="math/tex; mode=display">
e_r(z)=|\frac{x}{x-y}||e_r(x)|+|\frac{y}{x-y}||e_r(x)|</script><script type="math/tex; mode=display">
从该式中我们可以看出z的相对误差会特别大</script></li>
<li><p>防止“大数”吃掉小数（改变运算顺序？）</p>
</li>
<li><p>绝对值太小的数不宜做除数</p>
<script type="math/tex; mode=display">
  假设z=x \div y,z^* = x^* \div y^*,那么：</script><script type="math/tex; mode=display">
  e(z)=|z^*-z|=|\frac{y(x^*-x)+x(y-y^*)}{yy*}|\approx \frac{|y||e(x)|+|x||e(y)|}{y^2}​</script><p>  则如果$y$的绝对值太小，那么$z$的绝对误差较大</p>
</li>
<li><p>注意简化计算程序，减少计算次数（舍入误差的积累和计算的时间）</p>
</li>
<li><p>选用数值稳定性好的算法</p>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol>
<li><p>将下列表达式进行等价变形，使其数值计算结果较为精确。</p>
<p>(1) $\frac{1}{1-2x}-\frac{1+x}{1-x},|x|&lt;&lt;1$</p>
<p>解：$原式=\frac{2x^2}{(1-2x)(1-x)}$</p>
<p>(2)$\frac{1-e^x}{x},|x|&lt;&lt;1$</p>
<p>解：由$e^x$在x=0处的泰勒展开式可得：</p>
<p>$e^x= 1+x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2+R_n(x)$</p>
<p>所以</p>
<p>$\frac{1-e^x}{x}=\frac{x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2}{x}=1+\frac{1}{2!}x+\frac{1}{3!}x^2+…+\frac{1}{n!}x^{n-1}$</p>
</li>
<li><p>假设$f=(\sqrt{2}-1)^6,\sqrt{2}$取1.4，下列哪种计算方式的精确度最高。</p>
<p>(1)$\frac{1}{(\sqrt{2}+1)^6}\Rightarrow f(x)=\frac{1}{x^6}$</p>
<p>(2)$(3-2\sqrt2)^3 \Rightarrow f(x)=x^3$</p>
<p>(3)$\frac{1}{(3-2\sqrt2)^3} \Rightarrow f(x)=\frac{1}{x^3}$</p>
<p>(4)$99-70\sqrt2 \Rightarrow f(x)=99-70x$</p>
<p>解：使用函数的条件数$cond=|\frac{f^{‘}(x)x}{f(x)}|$</p>
<p>将$x=1.4$带入其中，可得(3)式的精确度最高。</p>
<p>注：条件数低为良态，条件数高为病态。   </p>
<h2 id="补充：-x-1x-2-的绝对误差限"><a href="#补充：-x-1x-2-的绝对误差限" class="headerlink" title="补充：$x_1x_2$的绝对误差限"></a>补充：$x_1x_2$的绝对误差限</h2></li>
</ol>
<p>$x_1\approx x_1,x_2\approx x_2$</p>
<script type="math/tex; mode=display">
|x_1x_2-x_1^*x_2^*|=|x_1x_2-x_1x_2^*+x_1x_2^*-x_1^*x_2^*|</script><script type="math/tex; mode=display">
\le|x_1||x_2-x_2^*|+|x_2^*||x_1-x_1^*|</script><script type="math/tex; mode=display">
    =|x_1||e(x_2)|+|x_2||e(x_1)|</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;顺序Gauss消去法</title>
    <url>/2020/03/11/mathAnalysis-2-1/</url>
    <content><![CDATA[<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul>
<li>将线性方程组的增广矩阵，只通过行变换，将增广矩阵化简成一个上三角矩阵。再从增广矩阵的最后一行开始依次回代，求出解向量。<a id="more"></a>
</li>
</ul>
<h2 id="算法成立的充要条件"><a href="#算法成立的充要条件" class="headerlink" title="算法成立的充要条件"></a>算法成立的充要条件</h2><ul>
<li>主元素不为零$\Leftrightarrow$系数矩阵的各阶主子式都不为零</li>
<li>主元素：顺序Gauss消去法中的$a_{kk}^{(k)},(k=1,2,…n)$。</li>
</ul>
<h2 id="列主元Gauss消去法"><a href="#列主元Gauss消去法" class="headerlink" title="列主元Gauss消去法"></a>列主元Gauss消去法</h2><ul>
<li>在顺序Gauss消去法的基础上，在每一步消元之前，在主元所在的列选取绝对值最大的元素作为主元素。</li>
<li>充要条件：$|A|\neq0$ </li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;直接三角分解法</title>
    <url>/2020/10/05/mathAnalysis-2-2/</url>
    <content><![CDATA[<h2 id="定义（顺序Gauss消去法的矩阵形式）"><a href="#定义（顺序Gauss消去法的矩阵形式）" class="headerlink" title="定义（顺序Gauss消去法的矩阵形式）"></a>定义（顺序Gauss消去法的矩阵形式）</h2><ul>
<li>将系数矩阵$A$分解成$A=LU$（单位下三角矩阵$L$和上三角矩阵$U$）</li>
</ul>
<script type="math/tex; mode=display">
Ax=b\Rightarrow
\begin{cases}
Ux=y \\
Ly=b
\end{cases}</script><a id="more"></a>
<ul>
<li>充要条件$A$的各阶顺序主子式不为零</li>
</ul>
<h2 id="获取-L-矩阵和-U-矩阵的方法"><a href="#获取-L-矩阵和-U-矩阵的方法" class="headerlink" title="获取$L$矩阵和$U$矩阵的方法"></a>获取$L$矩阵和$U$矩阵的方法</h2><ul>
<li>先求$U$矩阵的第一行，再求$L$矩阵的第一列，以此类推。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;追赶法</title>
    <url>/2020/10/05/mathAnalysis-2-4/</url>
    <content><![CDATA[<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul>
<li>追赶法是求三对角线性方程组的三角分解法。<a id="more"></a>
</li>
</ul>
<h2 id="矩阵：-A-TM"><a href="#矩阵：-A-TM" class="headerlink" title="矩阵：$A=TM$"></a>矩阵：$A=TM$</h2><script type="math/tex; mode=display">
A=\left[
\begin{matrix}
a_1 & c_1 \\
d_2 & a_2    & c_2 \\
    & \ddots & \ddots & \ddots \\
    &        & d_{n-1}& a_{n-1} & c_{n-1} \\
    &        &        & d_n     & a_n      \\
\end{matrix}
\right]</script><h2 id="三对角矩阵-A-的各阶顺序主子式不为零的充要条件"><a href="#三对角矩阵-A-的各阶顺序主子式不为零的充要条件" class="headerlink" title="三对角矩阵$A$的各阶顺序主子式不为零的充要条件"></a>三对角矩阵$A$的各阶顺序主子式不为零的充要条件</h2><ul>
<li>$|a_1|&gt;|c_1|;|a_n|&gt;|d_n|;$</li>
<li>$|a_i|\ge |c_i|+|d_i|,c_id_i\neq0,i=2,3,…n-1$</li>
</ul>
<h2 id="追赶法的具体步骤"><a href="#追赶法的具体步骤" class="headerlink" title="追赶法的具体步骤"></a>追赶法的具体步骤</h2><ul>
<li>先求第一行，再求第二行，依次类推</li>
<li>每一行都是从左到右开始求解</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;范数</title>
    <url>/2020/10/05/mathAnalysis-2-5/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul>
<li>为了对线性方程组的性态和其数值解进行分析，故引入范数来表示。<a id="more"></a>
</li>
</ul>
<h2 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>假设$||\cdot||$为向量空间$R^n$的实值函数，且满足以下三个条件：</li>
<li><strong>非负性：</strong>对于任何向量$x\in R^n$，$||x||\ge 0$，且$||x||=0$当且仅当$x=0$</li>
<li><strong>齐次性：</strong>对于任何实数$\alpha$和向量$x\in R^n$，$||\alpha x||=|\alpha|||x||$</li>
<li><strong>三角不等式：</strong>对于任何向量$x,y\in R^n$，$||x+y||\le||x||+||y||$</li>
</ul>
<p>则称$||\cdot||$为向量空间$R^n$上的范数，$||x||$为向量$x$的范数</p>
<h3 id="常用的三个向量范数"><a href="#常用的三个向量范数" class="headerlink" title="常用的三个向量范数"></a>常用的三个向量范数</h3><ul>
<li>向量1-范数：$||x||_1=\sum^n_{i=1}|x_i|$</li>
<li>向量2-范数：$||x||_2=(\sum^n_{i=1}x_i^2)^{\frac{1}{2}}$(向量的模)</li>
<li>向量$\infty$-范数：$||x||_\infty=max_{1\le i\le n}|x_i|$</li>
</ul>
<h3 id="范数的等价性以及常用的等价公式"><a href="#范数的等价性以及常用的等价公式" class="headerlink" title="范数的等价性以及常用的等价公式"></a>范数的等价性以及常用的等价公式</h3><ul>
<li><p><strong>范数的等价性：</strong>对于$R^n$空间上的任意两个范数$||\cdot||_\alpha$和$||\cdot||_\beta$，存在正常数$m,M$，使得：</p>
<p>$m||x||_\beta \le ||x||_\alpha \le M||x||_\beta, \forall x \in R^n$</p>
</li>
<li><p><strong>常用的等价公式：</strong></p>
<p>$||x||_\infty \le ||x||_1 \le n||x||_\infty$</p>
<p>$||x||_\infty \le ||x||_2 \le \sqrt n||x||_\infty$</p>
<p>$||x||_2 \le ||x||_1 \le \sqrt n||x||_2$</p>
</li>
</ul>
<h2 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul>
<li>与向量范数定义类似，除去向量范数满足的三个条件以外，还要满足第四个条件：</li>
<li>$||AB|| \le ||A||||B||$</li>
<li>满足四个条件则称$||A||$为$A$的范数</li>
</ul>
<h3 id="四个常用的矩阵范数"><a href="#四个常用的矩阵范数" class="headerlink" title="四个常用的矩阵范数"></a>四个常用的矩阵范数</h3><ul>
<li>矩阵的1-范数（列范数）：$||A||_1=max_{1\le j\le n}\sum_{i=1}^n|a_{ij}|$</li>
<li>矩阵的2-范数（谱范数）：$||A||_2=(A^TA的最大特征值)^{\frac{1}{2}}$</li>
<li>矩阵的$\infty$-范数（行范数）：$||A||_\infty=max_{1\le i \le n}\sum_{j=1}^n|a_{ij}|$</li>
<li>矩阵的F-范数：$||A||_F=(\sum_{i,j=1}^n|a_{ij}|^2)^{\frac{1}{2}}$</li>
</ul>
<p>识记：1是竖着的所以一范数是列范数，$\infty$范数是横着的所以是行范数。</p>
<h3 id="矩阵相容范数的判定"><a href="#矩阵相容范数的判定" class="headerlink" title="矩阵相容范数的判定"></a>矩阵相容范数的判定</h3><ul>
<li>$||Ax||\le ||A||\  ||x||,\  \forall x \in R^n$</li>
</ul>
<h3 id="谱半径"><a href="#谱半径" class="headerlink" title="谱半径"></a>谱半径</h3><ul>
<li>$\rho(A)=max_{1\le i \le n}|\lambda|$</li>
</ul>
<h3 id="特征值-lambda-的求法"><a href="#特征值-lambda-的求法" class="headerlink" title="特征值$\lambda$的求法"></a>特征值$\lambda$的求法</h3><ul>
<li>计算行列式: $|\lambda E - A| = 0$</li>
<li>特征值得和等于矩阵主对角线元素之和</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;线性方程组的固有性态</title>
    <url>/2020/10/05/mathAnalysis-2-6/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>由于原始数据微小变化而导致解严重失真的方程组称为<strong>病态方程组</strong>，相应的系数矩阵称为<strong>病态矩阵</strong>。</li>
<li>使用<strong>条件数</strong>来判定线性方程组是否<strong>病态</strong>。<a id="more"></a>
</li>
</ul>
<h2 id="条件数"><a href="#条件数" class="headerlink" title="条件数"></a>条件数</h2><ul>
<li>$Cond(A)=||A||\  ||A^{-1}||$</li>
<li>经常使用的条件数: $Cond_p(A)=||A||_p \  ||A^{-1}||_p,\  p=1,2,\infty$</li>
<li>当$A$为<strong>对称矩阵</strong>时, 可有</li>
</ul>
<script type="math/tex; mode=display">
Cond_2(A)=\frac{|\lambda|_{max}}{|\lambda|_{min}}</script><ul>
<li>通常用<strong>条件数过大</strong>来判定方程组是病态方程组</li>
</ul>
<h2 id="逆矩阵的求法"><a href="#逆矩阵的求法" class="headerlink" title="逆矩阵的求法"></a>逆矩阵的求法</h2><ul>
<li>$(A,E) \Rightarrow 经过初等行变换得 (E, A^{-1})$</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;迭代法的收敛性</title>
    <url>/2020/10/05/mathAnalysis-3-1/</url>
    <content><![CDATA[<h2 id="迭代法的一般形式"><a href="#迭代法的一般形式" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h2><h3 id="线性方程组的等价形式"><a href="#线性方程组的等价形式" class="headerlink" title="线性方程组的等价形式"></a>线性方程组的等价形式</h3><ul>
<li>$Ax=b \Leftrightarrow x = Mx+g$<ul>
<li>$M$成为迭代矩阵，$g$为某一向量<a id="more"></a>
</li>
</ul>
</li>
</ul>
<h3 id="迭代法的一般形式-1"><a href="#迭代法的一般形式-1" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h3><ul>
<li>$x^{(k+1)}=Mx^{(k)}+g$</li>
</ul>
<h2 id="迭代法收敛的判定定理"><a href="#迭代法收敛的判定定理" class="headerlink" title="迭代法收敛的判定定理"></a>迭代法收敛的判定定理</h2><ul>
<li><strong>定理一</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分必要条件</strong>是迭代矩阵$M$的谱半径 $\rho(M)&lt;1$。</li>
<li><strong>定理二</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分条件</strong>是 $||M||&lt;1$。</li>
<li><strong>补充：</strong>当迭代方法的迭代矩阵谱半径$\rho(M)&lt;1$时，谱半径越小，迭代方法的收敛速度越快。</li>
</ul>
<h2 id="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"><a href="#Jacobi迭代法和Gauss-Seidel迭代法的收敛性" class="headerlink" title="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"></a>Jacobi迭代法和Gauss-Seidel迭代法的收敛性</h2><h3 id="严格对角占优矩阵"><a href="#严格对角占优矩阵" class="headerlink" title="严格对角占优矩阵"></a>严格对角占优矩阵</h3><script type="math/tex; mode=display">
设n阶A=(a_{ij})，如果A的元素满足:</script><script type="math/tex; mode=display">
\sum^n_{j=1 \\ 
j\neq i}|a_{ij}| < |a_{ii}|,\ i=1,2,\cdots,n \\
则称A是严格对角占优矩阵</script><h3 id="判定定理"><a href="#判定定理" class="headerlink" title="判定定理"></a>判定定理</h3><ul>
<li><p><strong>定理一</strong>：设$A$是严格对角占优矩阵，则解方程组$Ax=b$的$J$迭代法和$GS$迭代法均收敛。</p>
</li>
<li><p><strong>定理二</strong>：设$A$是对称正定矩阵，则解方程组$Ax=b$的$GS$迭代法是收敛的。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;Jacobi迭代法和Gauss-Seidel迭代法</title>
    <url>/2020/10/05/mathAnalysis-3-2/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>以该线性方程组为例，介绍几种线性方程组的数值解法</li>
<li><script type="math/tex; mode=display">\left\{  \begin{array}{c}    a_{11}x_1+a_{12}x_2+a_{13}x_3=b_1 \\     a_{21}x_1+a_{22}x_2+a_{23}x_3=b_2 \\     a_{31}x_1+a_{32}x_2+a_{33}x_3=b_3 \end{array} \right.</script></li>
</ul>
<a id="more"></a>
<h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">
\left\{
\begin{array}{c}
x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\
x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k)}-a_{23}x_3^{(k)}) \\
x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k)}-a_{32}x_3^{(k)})
\end{array}
\right.</script><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><ul>
<li>由Jacobi迭代公式我们可知，在计算$x_2^{(k+1)}$时，此时$x_1^{(k+1)}$已经计算出；在计算$x_3^{(k+1)}$时，$x_1^{(k+1)},x_2^{(k+1)}$也已经计算出。为了充分利用这些数据便有了Gauss-Seidel迭代法：</li>
</ul>
<script type="math/tex; mode=display">
\left\{
\begin{array}{c}
x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\
x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k+1)}-a_{23}x_3^{(k)}) \\
x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k+1)}-a_{32}x_3^{(k+1)})
\end{array}
\right.</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;SOR迭代法</title>
    <url>/2020/10/05/mathAnalysis-3-3/</url>
    <content><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul>
<li>Jacobi迭代法的实质是用当前的迭代值加上一个修正量来得到一个新的迭代值，结合J迭代法和GS迭代法以及修正量的思想引入<strong>SOR迭代法</strong>。<a id="more"></a>
</li>
</ul>
<h2 id="SOR迭代法的表达式"><a href="#SOR迭代法的表达式" class="headerlink" title="SOR迭代法的表达式"></a>SOR迭代法的表达式</h2><ul>
<li><p>$x^{(k+1)}_i=x_i^{(k)}+\frac{\omega}{a_{ii}}(b_i - \sum^{i-1}_{j=1}a_{ij}x_j^{(k+1)}-\sum^n_{j=i}a_{ij}x_j^{(k)})$</p>
<p>$i=1,2,\cdots,n,\quad k=0,1,\cdots$</p>
</li>
<li><p>$\omega$称作<strong>松弛因子</strong>，当$\omega &lt; 1$时，此迭代称为<strong>欠松弛迭代</strong>，$\omega&gt;1$时，称为<strong>超松弛迭代</strong>。</p>
</li>
</ul>
<h2 id="SOR迭代法的判定定理"><a href="#SOR迭代法的判定定理" class="headerlink" title="SOR迭代法的判定定理"></a>SOR迭代法的判定定理</h2><ul>
<li><strong>定理一</strong>：SOR方法收敛的<strong>充分必要条件</strong>是 $\rho(M_\omega)&lt;1$；收敛的<strong>充分</strong>条件为 $||M_\omega||&lt;1$。（$M_\omega$为迭代矩阵）</li>
<li><strong>定理二</strong>：SOR方法收敛的<strong>必要条件</strong>是：$0&lt;\omega&lt;2$。</li>
<li><strong>定理三</strong>：设系数矩阵$A$是对称正定的，且 $0&lt;\omega&lt;2$，则SOR方法收敛。</li>
<li><strong>定理四</strong>：当系数矩阵$A$是$\alpha-$严格对角占优矩阵，且 $0&lt;w \le1$，SOR方法收敛。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第三章&gt;&gt;三种迭代法的矩阵表示形式</title>
    <url>/2020/10/05/mathAnalysis-3-4/</url>
    <content><![CDATA[<h1 id="三种迭代法的矩阵表示形式（-Ax-b-）"><a href="#三种迭代法的矩阵表示形式（-Ax-b-）" class="headerlink" title="三种迭代法的矩阵表示形式（$Ax= b$）"></a>三种迭代法的矩阵表示形式（$Ax= b$）</h1><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">
假设A=D-L-U,D为对角矩阵， \\</script><script type="math/tex; mode=display">
-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">
(D-L-U)x = b \\
\Rightarrow Dx = (L+U)x+b \\</script><script type="math/tex; mode=display">
\Rightarrow x = D^{-1}(L+U)x+D^{-1}b \\
\Rightarrow x^{(k+1)} = D^{-1}(L+U)x^{k}+D^{-1}b</script><a id="more"></a>
<ul>
<li><strong>迭代矩阵：</strong>$B=D^{-1}(L+U)$</li>
</ul>
<h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><script type="math/tex; mode=display">
假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">
-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">
(D-L-U)x = b \\
\Rightarrow Dx = Lx + Ux + b \\</script><script type="math/tex; mode=display">
\Rightarrow Dx^{(k+1)} = Lx^{(k+1)}+Ux^k+b \\
\Rightarrow (D-L)x^{(k+1)} = Ux^k+b \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = (D-L)^{-1}Ux^k+(D-L)^{-1}b</script><ul>
<li><strong>迭代矩阵：</strong>$G=(D-L)^{-1}U$</li>
</ul>
<h2 id="SOR迭代法"><a href="#SOR迭代法" class="headerlink" title="SOR迭代法"></a>SOR迭代法</h2><script type="math/tex; mode=display">
假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">
L为缺少对角线元素的下三角矩阵，U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">
(D-L-U)x = b\\</script><script type="math/tex; mode=display">
\Rightarrow x = x +[b-(D-L-U)x] \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = x^{k} + D^{-1}[b-(D-L-U)x^{k}],J迭代格式 \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = x^k + D^{-1}[b+(U-D)x^k+Lx^{(k+1)}],G-S迭代格式 \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = x^k + \omega D^{-1}[b+(U-D)x^k+Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">
\Rightarrow Dx^{(k+1)} = Dx^k+[\omega b+ \omega(U-D)x^k+\omega Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">
\Rightarrow (D-\omega L)x^{(k+1)} = [D(1-\omega)+\omega U]x^k + \omega b \\</script><script type="math/tex; mode=display">
\Rightarrow x^{(k+1)} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]x^k + \omega(D-\omega L)^{-1}b</script><ul>
<li><strong>迭代矩阵：</strong>$L_{\omega} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]$</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第四章||二分法</title>
    <url>/2020/10/09/mathAnalysis-4-1/</url>
    <content><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul>
<li><p><strong>定义：</strong>设$[a,b]$为方程$f(x)=0$的有根区间。所谓二分法就是<strong>对有根区间</strong>$[a,b]$<strong>逐次分半</strong>，使得有根区间长度逐次缩小，从而得到根的近似值。</p>
</li>
<li><p><strong>步骤：</strong></p>
<script type="math/tex; mode=display">
①记a_0=a,\ b=b_0,\ 计算\ x_1=\frac{a+b}{2} \\</script><script type="math/tex; mode=display">
②若f(a_0)f(x_1)<0,\ 取\ a_1=a_0,\ b_1=x_1; \\</script><script type="math/tex; mode=display">
③若f(a_0)f(x_1)>0,\ 取\ a_1=x_1,\ b_1=b_0; \\</script><script type="math/tex; mode=display">
④则得到新的有根区间\ [a_1,b_1],\ 其区间长度恰好是\ [a_0,b_0]\ 长度的一半; \\</script><script type="math/tex; mode=display">
⑤重复上述操作，直至根的近似值达到精度要求结束二分法。</script></li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第四章||简单迭代法</title>
    <url>/2020/10/09/mathAnalysis-4-2/</url>
    <content><![CDATA[<h1 id="简单迭代法"><a href="#简单迭代法" class="headerlink" title="简单迭代法"></a>简单迭代法</h1><h2 id="简单迭代法的一般形式"><a href="#简单迭代法的一般形式" class="headerlink" title="简单迭代法的一般形式"></a>简单迭代法的一般形式</h2><ul>
<li><strong>迭代格式：</strong>$x_{k+1}=\phi(x_k),\ \phi(x)称为迭代函数$</li>
</ul>
<h2 id="简单迭代法的收敛条件"><a href="#简单迭代法的收敛条件" class="headerlink" title="简单迭代法的收敛条件"></a>简单迭代法的收敛条件</h2><ul>
<li><p>收敛定理：</p>
<p>① 假设迭代函数$\phi(x)$在区间$[a,b]$上可导，且满足条件：</p>
<p>② $a\le \phi(x) \le b,\ x\in[a,b]$</p>
<p>③ 存在正数$L &lt; 1,$使对任意 $x \in [a,b]$ 有 $|\phi^{‘}(x)|\le L &lt; 1$</p>
</li>
</ul>
<h2 id="简单迭代法的收敛阶"><a href="#简单迭代法的收敛阶" class="headerlink" title="简单迭代法的收敛阶"></a>简单迭代法的收敛阶</h2><ul>
<li><strong>一般格式：</strong>$\lim_{k\to \infty} \tfrac{|e_{k+1}|}{|e_k|^p}=C$</li>
<li>$p$为<strong>收敛阶</strong>，$C$为<strong>渐近误差常数</strong>。</li>
<li><strong>收敛阶的求法：</strong>$\phi^{‘}(\alpha)=\phi^{‘’}(\alpha)=\cdots=\phi^{(p-1)}(\alpha)=0,\ \phi^{(P)}(\alpha)\neq0,\ p\ge2$,则迭代法<strong>p阶收敛</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第四章||牛顿迭代法</title>
    <url>/2020/10/09/mathAnalysis-4-3/</url>
    <content><![CDATA[<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><h2 id="Newton-迭代格式"><a href="#Newton-迭代格式" class="headerlink" title="Newton 迭代格式"></a>Newton 迭代格式</h2><ul>
<li>迭代格式（切线法）：$x_{k+1}=x_k-\frac{f(x_k)}{f^{‘}(x_k)}$</li>
<li>$\phi’(x)=\frac{f(x)f’’(x)}{(f’(x))^2}$</li>
</ul>
<h2 id="Newton-迭代法的收敛性"><a href="#Newton-迭代法的收敛性" class="headerlink" title="Newton 迭代法的收敛性"></a>Newton 迭代法的收敛性</h2><ul>
<li><p><strong>收敛阶：</strong>Newton 迭代法对于单根$\alpha$至少是平方阶收敛，Newton 迭代法对初值$x_0$的选取较为严格。</p>
</li>
<li><p><strong>定理：</strong>$\lim_{k\to\infty}\frac{x_{k+1}-\alpha}{(x_k-\alpha)^2}=\frac{f^{‘’}(\alpha)}{2f^{‘}(\alpha)}$</p>
</li>
</ul>
<h2 id="Newton-迭代法的变形"><a href="#Newton-迭代法的变形" class="headerlink" title="Newton 迭代法的变形"></a>Newton 迭代法的变形</h2><h3 id="简化-Newton-迭代法（线性收敛）"><a href="#简化-Newton-迭代法（线性收敛）" class="headerlink" title="简化 Newton 迭代法（线性收敛）"></a>简化 Newton 迭代法（线性收敛）</h3><ul>
<li>迭代格式：$x_{k+1}=x_k-\frac{f(x_k)}{M}\ ,k=0,1,2,\cdots$</li>
<li>$M通常取f^{‘}(x_o)$</li>
</ul>
<h3 id="割线法（该迭代法的收敛阶介于1和2之间）"><a href="#割线法（该迭代法的收敛阶介于1和2之间）" class="headerlink" title="割线法（该迭代法的收敛阶介于1和2之间）"></a>割线法（该迭代法的收敛阶介于1和2之间）</h3><ul>
<li>用<strong>函数$f(x)$的差商</strong>近似 Newton 迭代格式中的导数$f’（x）,即$</li>
<li>$f’(x)\approx\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$</li>
<li>Newton 迭代法可以修改为：$x_{k+1}=x_k-\frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1}),\ k=1,2,3,\cdots$</li>
</ul>
<h3 id="求方程重根的-Newton-迭代法（往往具有平方阶收敛）"><a href="#求方程重根的-Newton-迭代法（往往具有平方阶收敛）" class="headerlink" title="求方程重根的 Newton 迭代法（往往具有平方阶收敛）"></a>求方程重根的 Newton 迭代法（往往具有平方阶收敛）</h3><ul>
<li><strong>带参数m的迭代格式：</strong>$x_{k+1}=x_k-m\frac{f(x_k)}{f’(x_k)},\ k=0,1,2,\cdots$</li>
<li><strong>不带参数m的迭代格式：</strong>$x_{k+1}=x_k-\frac{u(x_k)}{u’(x_k)},\ k=0,1,2,\cdots \ ;u(x)=\frac{f(x)}{f’(x)}$</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||插值的定义</title>
    <url>/2020/10/09/mathAnalysis-5-1/</url>
    <content><![CDATA[<h1 id="插值的定义"><a href="#插值的定义" class="headerlink" title="插值的定义"></a>插值的定义</h1><h2 id="插值条件"><a href="#插值条件" class="headerlink" title="插值条件"></a>插值条件</h2><ul>
<li><p>设函数$f(x)$在区间$[a,b]$上连续，给定$n+1$个节点，$a\le x_0&lt;x_1…&lt;x_n\le b$。</p>
</li>
<li><p>已知$f(x_k)=y_k(k=0,1,…n)$,在函数类P中寻找一函数$\phi(x)$作为$f(x)$的近似表达式，使满足：</p>
<p>$\phi(x_k)=f(x_k)=y_k,k=0,1,…,n$</p>
<p>注：$\phi(x)$为插值函数，函数类P为多项式函数类</p>
</li>
</ul>
<h2 id="插值定理"><a href="#插值定理" class="headerlink" title="插值定理"></a>插值定理</h2><ul>
<li>如果$n+1$个节点互不相等，则存在唯一的一个插值函数$p_n(x)$。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||分段插值多项式</title>
    <url>/2020/10/09/mathAnalysis-5-2/</url>
    <content><![CDATA[<h1 id="分段插值多项式"><a href="#分段插值多项式" class="headerlink" title="分段插值多项式"></a>分段插值多项式</h1><h2 id="Runge现象"><a href="#Runge现象" class="headerlink" title="Runge现象"></a>Runge现象</h2><ul>
<li>高次的插值函数的近似效果越差,以致完全失真,这个现象称为Runge现象.(高次插值数值不稳定)</li>
</ul>
<h2 id="分段线性插值"><a href="#分段线性插值" class="headerlink" title="分段线性插值"></a>分段线性插值</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><script type="math/tex; mode=display">
S_1(x)=\frac{x_i-x}{h_i}y_{i-1}+\frac{x-x_{i-1}}{h_i}y_i, x \in [x_{i-1},x_i]</script><h3 id="插值余项"><a href="#插值余项" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">
f(x)-S_1(x)=\frac{f''(\xi)}{2!}(x-x_{i-1})(x-x_i)\le\frac{M_2}{8}h^2</script><h2 id="分段二次插值"><a href="#分段二次插值" class="headerlink" title="分段二次插值"></a>分段二次插值</h2><h3 id="插值余项-1"><a href="#插值余项-1" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">
f(x)-S_2(x)=\frac{f'''(\xi)}{3!}(x-x_{i-1})(x-x_{i-\frac{1}{2}})(x-x_i)\le \frac{M_3}{72\sqrt3}h^3</script><h2 id="分段Hermite插值"><a href="#分段Hermite插值" class="headerlink" title="分段Hermite插值"></a>分段Hermite插值</h2><h3 id="插值余项-2"><a href="#插值余项-2" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">
f(x)-H_3(x)=\frac{f^{(4)}(\xi)}{4!}(x-x_{i-1})^2(x-x_i)^2\le \frac{M_4}{384}h^2(h^4?)</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||牛顿插值多项式</title>
    <url>/2020/10/09/mathAnalysis-5-3/</url>
    <content><![CDATA[<h1 id="牛顿插值多项式"><a href="#牛顿插值多项式" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h1><h2 id="差商"><a href="#差商" class="headerlink" title="差商"></a>差商</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>一阶差商：$f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}$</li>
<li>二阶差商：$f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}$</li>
<li>k阶差商以此类推</li>
</ul>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol>
<li>$f[x_0,x_1,\cdots,x_k]=\sum_{j=0}^k\frac{1}{\omega’_{k+1}(x_j)}f(x_j)$</li>
<li>差商对节点具有对称性</li>
<li>n次多项式$f(x)$的k阶差商$f[x_0,x_1,\cdots,x_{k-1},x]$,当$k\le n$时，是一个关于x的n-k次多项式，当$k&gt;n$时，恒等于0.</li>
<li>若$f(x)$具有k阶连续导数，则：$f[x_0,x_1,\cdots,x_k]=\frac{f^{(k)}(\xi)}{k!}$</li>
</ol>
<h2 id="牛顿插值多项式-1"><a href="#牛顿插值多项式-1" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>$N_n(x)=f(x_0)+f[x_0,x_1]\omega_1(x)+f[x_0,x_1,x_2]\omega_2(x)+\cdots+f[x_0,x_1,\cdots,x_n]\omega_n(x)$</p>
<h3 id="余项"><a href="#余项" class="headerlink" title="余项"></a>余项</h3><p>$R_n(x)=f[x,x_0,x_1,\cdots,x_n]\omega_{n+1}(x)=\frac{f^{(n+1)}(\zeta)}{(n+1)!}\omega_{n+1}(x)$</p>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第五章||最小二乘法</title>
    <url>/2020/10/09/mathAnalysis-5-4/</url>
    <content><![CDATA[<h1 id="最小二乘法-多项式拟合曲线"><a href="#最小二乘法-多项式拟合曲线" class="headerlink" title="最小二乘法(多项式拟合曲线)"></a>最小二乘法(多项式拟合曲线)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在函数类$\Phi=span [\phi_0(x),\phi_1(x),\cdots,\phi_n(x)]$中找到一个函数,使得拟合函数和原函数的误差向量的二范数达到最小.</p>
<h2 id="多项式拟合函数-1-x-x-2-cdots-x-n"><a href="#多项式拟合函数-1-x-x-2-cdots-x-n" class="headerlink" title="多项式拟合函数($1,x,x^2,\cdots,x^n$)"></a>多项式拟合函数($1,x,x^2,\cdots,x^n$)</h2><script type="math/tex; mode=display">
\phi(x)=a_0\phi_0(x)+a_1\phi_1(x)+\cdots+a_n\phi_n(x)</script><p>只需要求出系数$a_0,a_1,\cdots,a_n$即可求出拟合曲线</p>
<h2 id="正则方程组"><a href="#正则方程组" class="headerlink" title="正则方程组"></a>正则方程组</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201009/image-20200611221402561.png" alt="image-20200611221402561"></p>
<p>$(\phi_0,\phi_1)=\rho\phi_0\phi_1$</p>
<h2 id="构造最小二乘法的一些思路"><a href="#构造最小二乘法的一些思路" class="headerlink" title="构造最小二乘法的一些思路"></a>构造最小二乘法的一些思路</h2><ul>
<li>如果离散节点构成的函数图像不是多项式函数,而是指数函数,可以采用取对数的方式来化成多项式函数求值!</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 数值积分的基本概念</title>
    <url>/2020/10/11/mathAnalysis-6-1/</url>
    <content><![CDATA[<h1 id="数值积分的基本概念"><a href="#数值积分的基本概念" class="headerlink" title="数值积分的基本概念"></a>数值积分的基本概念</h1><ul>
<li><p>牛顿-莱布尼兹公式</p>
<p>  $\int_b^af(x)dx=F(b)-F(a)$</p>
</li>
<li><p>定积分的定义</p>
<p>  $I=\int_a^bf(x)dx=lim_{\Delta x\rightarrow0}\sum_{i=0}^nf(x_i)\Delta x_i$</p>
</li>
<li><p>求积公式的一般形式</p>
<p>  $\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k).A_k为求积系数，x_k为求积节点$</p>
</li>
<li><p>积分中值定理</p>
<p>  在$[a,b]$内存在一点$\xi$,有$\int_a^bf(x)dx=(b-a)f(\xi)$成立</p>
</li>
<li><p>由积分中值定理可得三个数值积分公式</p>
<p>  左矩形公式：$f_a^bf(x)dx=(b-a)f(a)$</p>
<p>  中矩形公式：$f_a^bf(x)dx=(b-a)f(\frac{b+a}{2})$</p>
<p>  右矩形公式：$f_a^bf(x)dx=(b-a)f(b)$</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 数值积分的代数精度</title>
    <url>/2020/10/11/mathAnalysis-6-2/</url>
    <content><![CDATA[<h1 id="数值积分的代数精度"><a href="#数值积分的代数精度" class="headerlink" title="数值积分的代数精度"></a>数值积分的代数精度</h1><h2 id="代数精度的定义"><a href="#代数精度的定义" class="headerlink" title="代数精度的定义"></a>代数精度的定义</h2><ul>
<li><p>若求积公式 $\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)$对于$f(x)=x^j(j=0,1,2…m)$都精确成立，但对$f(x)=x^{m+1}$不精确成立，则称该求积公式有$m$次的代数精度。</p>
</li>
<li><p>如果一个求积公式的代数精度为$m$，则该求积公式对于任何次数不超过$m$的函数都是精确成立的。</p>
</li>
<li><p>一般来说，代数精度越高，求积公式的精度也越高。</p>
</li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul>
<li><p>已知一个求积公式，和一些离散的节点，让你求求积公式的代数精度：</p>
<p>这类题，有几个未知数就列几个方程求解即可，同时还要带入更高阶的多项式函数来验证求积公式是否具有更高阶的代数精度。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 插值型数值求积公式</title>
    <url>/2020/10/11/mathAnalysis-6-3/</url>
    <content><![CDATA[<h1 id="插值型数值求积公式"><a href="#插值型数值求积公式" class="headerlink" title="插值型数值求积公式"></a>插值型数值求积公式</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><script type="math/tex; mode=display">
\int_a^bf(x)dx\approx\int_a^bL_n(x)dx=\sum_{k=0}^n[\int_a^bl_k(x)dx]f(x_k)\\
A_k=\int_a^bl_k(x)dx\\
R[f] = \frac{1}{(n+1)!}\int_a^bf^{n+1}(\xi_x)\omega_{n+1}(x)dx</script><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul>
<li>求积公式至少具有n次代数精度的充分必要条件是其是插值型求积公式</li>
</ul>
<h2 id="Newton-Cotes-求积公式"><a href="#Newton-Cotes-求积公式" class="headerlink" title="Newton-Cotes 求积公式"></a>Newton-Cotes 求积公式</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><script type="math/tex; mode=display">
\int_a^bf(x)dx\approx(b-a)\sum_{k=0}^nC_k^{(n)}f(a+kh)</script><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><ul>
<li>当n为偶数时，Newton-Cotes求积公式至少具有n+1次代数精度。</li>
</ul>
<h3 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h3><h4 id="梯形公式"><a href="#梯形公式" class="headerlink" title="梯形公式"></a>梯形公式</h4><script type="math/tex; mode=display">
\int_a^bf(x)dx=\frac{(b-a)}{2}(f(a)+f(b))\\
R[f] \le \frac{M_2}{12}(b-a)^3</script><h4 id="Simpson公式-具有三次代数精度"><a href="#Simpson公式-具有三次代数精度" class="headerlink" title="Simpson公式(具有三次代数精度)"></a>Simpson公式(具有三次代数精度)</h4><script type="math/tex; mode=display">
\int_a^bf(x)dx=\frac{(b-a)}{6}(f(a)+4f(\frac{a+b}{2})+f(b)) \\
R[f] \le \frac{M_4}{2880}(b-a)^5</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| 复化求积公式</title>
    <url>/2020/10/11/mathAnalysis-6-4/</url>
    <content><![CDATA[<h1 id="复化求积公式"><a href="#复化求积公式" class="headerlink" title="复化求积公式"></a>复化求积公式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>和分段插值多项式的原理类似</li>
</ul>
<h2 id="复化梯形公式"><a href="#复化梯形公式" class="headerlink" title="复化梯形公式"></a>复化梯形公式</h2><script type="math/tex; mode=display">
\int_a^bf(x)dx \approx \frac{h}{2}[f(a) + 2\sum_{k=1}^{n-1}f(x_k)+f(b)] = T_n \\
R[f]=I-T_n\le \frac{(b-a)^3}{12n^2}M_2</script><h2 id="复化Simpson公式"><a href="#复化Simpson公式" class="headerlink" title="复化Simpson公式"></a>复化Simpson公式</h2><script type="math/tex; mode=display">
\int_a^bf(x)dx\approx \frac{h}{6}[f(a)+4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(b)]\\
|I-S_n|\le \frac{(b-a)^5}{2880n^4}M_4</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析||第六章|| Gauss型求积公式</title>
    <url>/2020/10/11/mathAnalysis-6-5/</url>
    <content><![CDATA[<h1 id="Gauss型求积公式"><a href="#Gauss型求积公式" class="headerlink" title="Gauss型求积公式"></a>Gauss型求积公式</h1><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul>
<li>区间$[a,b]$上权函数为$\rho(x)$的具有n个节点的求积公式的代数精度不超过$2n-1$.</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul>
<li><p>对于给定区间$[a,b]$及权函数$\rho(x)$,由$Schemite$正交化过程构造正交多项式$p_0(x),p_1(x),…,p_n(x)$;</p>
</li>
<li><p>求出$p_n(x)$的$n$个零点,即$Gauss$点</p>
</li>
<li><p>计算求积系数$A_i=\int_a^bl_i(x)\rho(x)dx,i=1,2,…,n$.</p>
</li>
</ul>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul>
<li>求计算积分$f_{-1}^1x^2f(x)dx的两点Gauss公式$</li>
</ul>
<script type="math/tex; mode=display">
1.首先进行Schemite正交化\\</script><script type="math/tex; mode=display">
p_0(x) = 1\\
p_1(x) = x - \frac{(x,p_0(x))}{(p_0(x),p_0(x))}p_0(x)=x\\</script><script type="math/tex; mode=display">
p_2(x) = x^2-\frac{(x^2,p_0(x))}{(p_0(x),p_0(x))}p_0(x) - \frac{(x^2,p_1(x))}{(p_1(x),p_1(x))}p_1(x)=x^2-\frac{3}{5}\\</script><script type="math/tex; mode=display">
2.令p_2(x) = 0,求出Gauss点\\</script><script type="math/tex; mode=display">
x_1=-\sqrt{\frac{3}{5}},x_2=\sqrt{\frac{3}{5}}\\</script><script type="math/tex; mode=display">
3.计算求积系数A_k \\</script><script type="math/tex; mode=display">
A_1 = \int_{-1}^1x^2\frac{x-x_2}{x_1-x_2}dx=\frac{1}{3}\\
A_2 = \int_{-1}^1x^2\frac{x-x_1}{x_2-x_1}dx=\frac{1}{3}</script>]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>数值分析&gt;&gt;第二章&gt;&gt;平方根法</title>
    <url>/2020/10/05/mathAnyalsis-2-3/</url>
    <content><![CDATA[<h2 id="引入：对称正定矩阵"><a href="#引入：对称正定矩阵" class="headerlink" title="引入：对称正定矩阵"></a>引入：对称正定矩阵</h2><ul>
<li>矩阵各元素的各元素沿主对角线对称</li>
<li>矩阵的所有特征值均大于零</li>
</ul>
<a id="more"></a>
<h2 id="平方根法的使用条件"><a href="#平方根法的使用条件" class="headerlink" title="平方根法的使用条件"></a>平方根法的使用条件</h2><ul>
<li>$A$为对称正定矩阵，且$U_{kk}&gt;0$。</li>
</ul>
<h2 id="平方根法的步骤"><a href="#平方根法的步骤" class="headerlink" title="平方根法的步骤"></a>平方根法的步骤</h2><ul>
<li>$A=UU^T$,只需要计算$U$即可。</li>
<li>计算顺序：计算下三角矩阵$U$的第一列、第二列……依此类推。</li>
</ul>
]]></content>
      <categories>
        <category>数值分析笔记</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-introduction</title>
    <url>/2020/10/11/softeware-testing-notes-1/</url>
    <content><![CDATA[<h2 id="Errors-Faults-and-Failures"><a href="#Errors-Faults-and-Failures" class="headerlink" title="Errors, Faults and Failures"></a>Errors, Faults and Failures</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-1-1.png" alt></p>
<ul>
<li>Error - A problem that is introduced into a system during development.</li>
<li>Faults - A result of error.(maybe something is missing, or incorrect execution)</li>
<li>Failures - The result when a fault executes.</li>
<li>Incidents - The symptoms(症状) that indicates that there is a fault.</li>
</ul>
<h2 id="Some-correct-descriptions-of-Test-Cases"><a href="#Some-correct-descriptions-of-Test-Cases" class="headerlink" title="Some correct descriptions of Test Cases"></a>Some correct descriptions of Test Cases</h2><ul>
<li>A test case is requires a description of the inputs to a system.</li>
<li>A test case is requires a description of the outputs from a system.</li>
<li>Each test case should be identifiable, e.g. assigned a Test ID.</li>
</ul>
<h2 id="Some-topics-which-are-considered-‘good-enough’-for-Testing"><a href="#Some-topics-which-are-considered-‘good-enough’-for-Testing" class="headerlink" title="Some topics which are considered ‘good enough’ for Testing"></a>Some topics which are considered ‘good enough’ for Testing</h2><ul>
<li>Test early and test often</li>
<li>Integrate development and testing lifecycles</li>
<li>Formalize the testing methodology</li>
<li>Develop a comprehensive test plan</li>
<li>Use static and dynamic testing</li>
<li>Balancing time, money and quality</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-Black-Box Testing</title>
    <url>/2020/10/14/software-testing-notes-2/</url>
    <content><![CDATA[<blockquote>
<p>Black-box testing –testing based on a specification</p>
</blockquote>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-2-1.png" alt></p>
<h2 id="Advantages-of-Black-box-Testing"><a href="#Advantages-of-Black-box-Testing" class="headerlink" title="Advantages of Black-box Testing"></a>Advantages of Black-box Testing</h2><blockquote>
<p>You don’t need to know how it is implemented</p>
</blockquote>
<ul>
<li>You can plan tests earlier</li>
<li>You can write tests earlier</li>
<li>You do not need to be the person who implements the code</li>
<li>When the implementation changes, the tests should still work</li>
</ul>
<h2 id="Different-techniques-for-Black-box-Testing"><a href="#Different-techniques-for-Black-box-Testing" class="headerlink" title="Different techniques for Black-box Testing"></a>Different techniques for Black-box Testing</h2><ul>
<li>Equivalence Partitioning</li>
<li>Boundary Value Analysis</li>
<li>Decision Tables</li>
<li>Cause-Effect Graphing</li>
<li>Error guessing</li>
</ul>
<h3 id="Equivalence-Partitioning"><a href="#Equivalence-Partitioning" class="headerlink" title="Equivalence Partitioning"></a>Equivalence Partitioning</h3><ul>
<li>Input data and output results often fall into different classes, where all members of the class are related</li>
<li>Each of these classes is an <strong>equivalence partition</strong> or <strong>domain</strong> where the program behaves in an equivalent way for each class member</li>
<li>techniques of equivalence partitioning<ul>
<li>valid &amp; invalid equivalence classes</li>
<li>guidelines for variables (integer, string, enum, array)</li>
</ul>
</li>
</ul>
<h2 id="Design-Reasonable-Test-Cases"><a href="#Design-Reasonable-Test-Cases" class="headerlink" title="Design Reasonable Test Cases"></a>Design Reasonable Test Cases</h2><ul>
<li><p>Step 1: Identify equivalence classes</p>
</li>
<li><p>Step 2: Design a new test case that covers a valid equivalence class which has not yet been tested (Repeat)</p>
</li>
<li><p>Step 3: Design a new test case that covers a invalid equivalence class which has not yet been tested (Repeat)</p>
</li>
</ul>
<h2 id="Weak-Normal-Strong-Robust"><a href="#Weak-Normal-Strong-Robust" class="headerlink" title="Weak, Normal, Strong, Robust"></a>Weak, Normal, Strong, Robust</h2><h3 id="Weak-vs-Strong"><a href="#Weak-vs-Strong" class="headerlink" title="Weak vs Strong"></a>Weak <em>vs</em> Strong</h3><ul>
<li>Weak: Assuming a single fault</li>
<li>Strong: Assuming multiple faults</li>
</ul>
<h3 id="Normal-vs-Robust"><a href="#Normal-vs-Robust" class="headerlink" title="Normal vs Robust"></a>Normal <em>vs</em> Robust</h3><ul>
<li>Normal: select values from the ‘valid’ range</li>
<li>Robust: select values from the ‘invalid’ range</li>
</ul>
<h2 id="Boundary-Value-Analysis"><a href="#Boundary-Value-Analysis" class="headerlink" title="Boundary Value Analysis"></a>Boundary Value Analysis</h2><blockquote>
<p>Boundary Value Analysis works well when the variables are independent and represent bounded physical quantities</p>
</blockquote>
<p>For any input variable, create tests cases with values that are:</p>
<ul>
<li>At the minimum (min)</li>
<li>Just above the minimum (min + 1)</li>
<li>At a nominal value</li>
<li>Just below the maximum (max –1)</li>
<li>At the maximum (max) 16</li>
</ul>
<h3 id="Some-descriptions-of-boundary-value-analysis"><a href="#Some-descriptions-of-boundary-value-analysis" class="headerlink" title="Some descriptions of boundary value analysis"></a>Some descriptions of boundary value analysis</h3><ul>
<li>The reason for focusing on the boundary value testing is that errors do occur near the extreme values of an input variable</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-White-Box Testing</title>
    <url>/2020/10/11/software-testing-notes-3/</url>
    <content><![CDATA[<blockquote>
<p>White-box testing –testing based on the logic in a program</p>
</blockquote>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-3-1.png" alt></p>
<h2 id="Some-descriptions-about-White-box-Testing"><a href="#Some-descriptions-about-White-box-Testing" class="headerlink" title="Some descriptions about White-box Testing"></a>Some descriptions about White-box Testing</h2><ul>
<li>White-box is based on the implementation</li>
<li>For high confidence, e.g. in safety critical software, need to look at the code and make sure every possibility is covered(<strong>Not all software</strong>)</li>
<li>Still worth doing black-box testing then look at EXTRA tests based on white-box approaches</li>
</ul>
<h2 id="White-box-Testing-types"><a href="#White-box-Testing-types" class="headerlink" title="White-box Testing types"></a>White-box Testing types</h2><ul>
<li>Static Analysis</li>
<li>Dynamic Testing with path coverage of code</li>
</ul>
<h2 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h2><ul>
<li>Discussed during the Software Lifecycle course</li>
<li>Code Inspection(代码检查)</li>
<li>The analysis cannot be automated</li>
<li>BUT, code inspections are an effective way to detect potential problems</li>
</ul>
<h2 id="Dynamic-Testing-Path-Coverage"><a href="#Dynamic-Testing-Path-Coverage" class="headerlink" title="Dynamic Testing: Path Coverage"></a>Dynamic Testing: Path Coverage</h2><ul>
<li>Write tests so that every path through the program is tested</li>
<li>The tests can be automated and repeated</li>
</ul>
<h2 id="Baic-principles-of-path-coverage"><a href="#Baic-principles-of-path-coverage" class="headerlink" title="Baic principles of path coverage"></a>Baic principles of path coverage</h2><ul>
<li>All independent path must be traversed at least once</li>
<li>All conditions(e.g. if statements) are tested for the true and false outcome</li>
<li>Review whether the test cover the internal data structure used</li>
<li>Test that loops work for their operational range(Not All)</li>
</ul>
<blockquote>
<p>e.g. if (name == null || name.equals(“”))</p>
<p>You need create two test cases for this if statement</p>
</blockquote>
<h2 id="Path-coverage-with-IDEA"><a href="#Path-coverage-with-IDEA" class="headerlink" title="Path coverage with IDEA"></a>Path coverage with IDEA</h2><h3 id="Step-1-Create-a-normal-class-with-some-methods"><a href="#Step-1-Create-a-normal-class-with-some-methods" class="headerlink" title="Step 1: Create a normal class with some methods"></a>Step 1: Create a normal class with some methods</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-2.png" alt></p>
<h3 id="Step-2-Using-Alt-Enter-to-create-a-test-class-with-this-normal-class"><a href="#Step-2-Using-Alt-Enter-to-create-a-test-class-with-this-normal-class" class="headerlink" title="Step 2:  Using Alt + Enter to create a test class with this normal class"></a>Step 2:  Using Alt + Enter to create a test class with this normal class</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-3.png" alt></p>
<h3 id="Step-3-Write-some-codes-to-test-path-coverage"><a href="#Step-3-Write-some-codes-to-test-path-coverage" class="headerlink" title="Step 3:  Write some codes to test path coverage"></a>Step 3:  Write some codes to test path coverage</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-4.png" alt></p>
<h3 id="Step-4-Run-with-code-coverage"><a href="#Step-4-Run-with-code-coverage" class="headerlink" title="Step 4: Run with code coverage"></a>Step 4: Run with code coverage</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-5.png" alt></p>
<blockquote>
<p>One useful tip: You could draw a decision tree to find how many test cases you need create when you analyse combination of if statements!</p>
</blockquote>
<h2 id="How-to-calculate-Cyclomatic-Complexity"><a href="#How-to-calculate-Cyclomatic-Complexity" class="headerlink" title="How to calculate Cyclomatic Complexity"></a>How to calculate Cyclomatic Complexity</h2><ul>
<li>Draw a Control flow graph already</li>
<li>cc = Numbers of Edges - Numbers of  Node + 2</li>
<li>or cc = Number of condition clause + 1</li>
</ul>
<h2 id="Basis-Path"><a href="#Basis-Path" class="headerlink" title="Basis Path"></a>Basis Path</h2><ul>
<li>Independent path through the code</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-Unit Testing</title>
    <url>/2020/10/11/software-testing-notes-4/</url>
    <content><![CDATA[<h2 id="What-is-Unit-Testing"><a href="#What-is-Unit-Testing" class="headerlink" title="What is Unit Testing?"></a>What is Unit Testing?</h2><h3 id="Software-Units"><a href="#Software-Units" class="headerlink" title="Software Units:"></a>Software Units:</h3><p>A unit is the smallest unit of the design in a software project</p>
<ul>
<li>In Java, a unit is a class or a method</li>
<li>In C, a unit is a function or .h/.c files</li>
</ul>
<h3 id="Unit-Testing"><a href="#Unit-Testing" class="headerlink" title="Unit Testing:"></a>Unit Testing:</h3><p>A process to check that each unit is working correctly, according to the requirements and design</p>
<ul>
<li>Test each unit independently of other units</li>
<li>We can use tools to help us, e.g. JUnit, but the tools aren’t required.</li>
</ul>
<h2 id="Something-should-be-concerned-when-doing-unit-testing"><a href="#Something-should-be-concerned-when-doing-unit-testing" class="headerlink" title="Something should be concerned when doing unit testing"></a>Something should be concerned when doing unit testing</h2><ul>
<li>Focus on single SUT at a time</li>
<li>Don’t test multiple units at once</li>
</ul>
<h2 id="Purpose-of-Unit-Testing"><a href="#Purpose-of-Unit-Testing" class="headerlink" title="Purpose of Unit Testing"></a>Purpose of Unit Testing</h2><ul>
<li>Validate whether code is consistent with the design and requirements.</li>
<li>Discover the errors between requirements , design and implementation.<ul>
<li>Error of omission(what is required, but not implemented)</li>
<li>Error of commission (an incorrect implementation)</li>
</ul>
</li>
</ul>
<h2 id="Aims-of-Unit-Tests"><a href="#Aims-of-Unit-Tests" class="headerlink" title="Aims of Unit Tests"></a>Aims of Unit Tests</h2><ul>
<li><strong>Aim:</strong> ensure that module was implemented correctly</li>
<li><strong>Input: </strong>detailed specification</li>
<li><strong>Process: </strong>design and implement tests and analyse results</li>
<li><strong>Personnal: </strong>Developers and Testers</li>
<li><strong>Test Approaches: </strong>black-box and white-box methods</li>
<li><strong>Evaluation: </strong>determine if the tests reveal errors</li>
</ul>
<h2 id="Some-benefits-of-Unit-Testing"><a href="#Some-benefits-of-Unit-Testing" class="headerlink" title="Some benefits of Unit Testing"></a>Some benefits of Unit Testing</h2><ul>
<li>The goal of unit testing is to isolate each part of the program and show that the individual parts are correct.</li>
<li>A unit test provides a strict, written contract that the piece of code must satisfy.</li>
<li>Easier to find issues when a test fails.</li>
<li>Unit tests find problems early in the development cycle. Reduce the costs.</li>
<li>Run the tests many times during development –easier to help with regression issues.</li>
</ul>
<h2 id="Aspects-of-unit-tests"><a href="#Aspects-of-unit-tests" class="headerlink" title="Aspects of unit tests"></a>Aspects of unit tests</h2><ul>
<li>Unit interface (need to be tested)</li>
<li>Functional tests - black box</li>
<li>Structural tests - white box</li>
<li>Error handling</li>
<li>Incorrect input</li>
</ul>
<h2 id="Unit-Testing-with-a-Framework"><a href="#Unit-Testing-with-a-Framework" class="headerlink" title="Unit Testing with a Framework"></a>Unit Testing with a Framework</h2><h3 id="Desirable-features-of-a-unit-test-framework"><a href="#Desirable-features-of-a-unit-test-framework" class="headerlink" title="Desirable features of a unit test framework"></a>Desirable features of a unit test framework</h3><ul>
<li>easy to write</li>
<li>easy to learn to write</li>
<li>quick to execute</li>
<li>easy to execute</li>
<li>isolated</li>
<li>composable</li>
</ul>
<h3 id="Test-Fixtures-Setup-Teardown"><a href="#Test-Fixtures-Setup-Teardown" class="headerlink" title="Test Fixtures: Setup - Teardown"></a>Test Fixtures: Setup - Teardown</h3><ul>
<li>Setup (might use common setup, e.g. @Before)</li>
<li>Exercise- call methods on the SUT</li>
<li>Verify(Assertions…)</li>
<li>Teardown (optional, e.g. @AfterEach, @AfterAll)</li>
</ul>
<p>(steps: Setup fixtures -&gt; Setup test -&gt; execute test -&gt; check result -&gt; teardown fixtures)</p>
<h2 id="Traditional-unit-testing-strategies"><a href="#Traditional-unit-testing-strategies" class="headerlink" title="Traditional unit testing strategies"></a>Traditional unit testing strategies</h2><h3 id="Top-down-unit-testing-strategy"><a href="#Top-down-unit-testing-strategy" class="headerlink" title="Top-down unit testing strategy"></a>Top-down unit testing strategy</h3><ul>
<li>Test the top level first. Create test-doubles for units called by the top-level. Create driver for top-level. Then, use the tested unit as the driver for next level.</li>
</ul>
<h3 id="Bottom-up-unit-testing-strategy"><a href="#Bottom-up-unit-testing-strategy" class="headerlink" title="Bottom-up unit testing strategy"></a>Bottom-up unit testing strategy</h3><ul>
<li>Test the bottom modules first. Create a driver module for it. When tested, move to next module up, creating a new driver. The tested lower-level module can be used instead of a stub.</li>
</ul>
<h3 id="Isolation-testing"><a href="#Isolation-testing" class="headerlink" title="Isolation testing"></a>Isolation testing</h3><ul>
<li>Do not consider the relationship between modules. Design test doubles and driver for every unit.</li>
</ul>
<h2 id="Test-Doubles"><a href="#Test-Doubles" class="headerlink" title="Test Doubles"></a>Test Doubles</h2><h3 id="Why-we-need-use-test-doubles"><a href="#Why-we-need-use-test-doubles" class="headerlink" title="Why we need use test doubles?"></a>Why we need use test doubles?</h3><p>There are times in testing when we need to use <strong>test doubles,</strong>  which are units that are used to replace a real part of the system for test purposes. Some examples:</p>
<ul>
<li>Databases</li>
<li>Code that is not ready yet</li>
<li>External hardware</li>
<li>Components that do not return values</li>
</ul>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-4-1.png" alt="testing workflow"></p>
<h3 id="Types-pf-Test-Double"><a href="#Types-pf-Test-Double" class="headerlink" title="Types pf Test Double"></a>Types pf Test Double</h3><ul>
<li>Dummy Object</li>
<li>Test Stub</li>
<li>Mock Object</li>
<li>Fake Object</li>
</ul>
<h3 id="Dummy-Object"><a href="#Dummy-Object" class="headerlink" title="Dummy Object"></a>Dummy Object</h3><ul>
<li>An SUT requires a data value as a part of test<ul>
<li>It does not matter what value is actually in the data value, it just needs to exist</li>
</ul>
</li>
<li>In some situations, the value null might be used. It depends on what the SUT will do with the value.<ul>
<li>e.g. service.getOne(new QueryWrapper()); // it just need a wraaper</li>
</ul>
</li>
</ul>
<h3 id="Test-Stub"><a href="#Test-Stub" class="headerlink" title="Test Stub"></a>Test Stub</h3><ul>
<li>it just need a value (a correct value, error value, log value)</li>
<li>e.g. Data logging software</li>
</ul>
<h3 id="Mock-Object"><a href="#Mock-Object" class="headerlink" title="Mock Object"></a>Mock Object</h3><ul>
<li>A Mock Object is setup with information about what calls it should expect. It might also be setup with details of the data it should expect.</li>
<li>Mock Objects are testing the behaviour of the interaction between the SUT and DOC</li>
<li>A number of values in one unit testing(interaction)</li>
</ul>
<h3 id="Fake-Object"><a href="#Fake-Object" class="headerlink" title="Fake Object"></a>Fake Object</h3><ul>
<li>An object that replaces the functionality of the DOC</li>
</ul>
<h2 id="Some-tips-of-Unit-testing"><a href="#Some-tips-of-Unit-testing" class="headerlink" title="Some tips of Unit testing"></a>Some tips of Unit testing</h2><ul>
<li>Print statements are useful for debugging!</li>
<li>Unit test cases can detect logic errors</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-Integration Testing</title>
    <url>/2020/10/15/software-testing-notes-5/</url>
    <content><![CDATA[<h2 id="What-is-Integration-Testing"><a href="#What-is-Integration-Testing" class="headerlink" title="What is Integration Testing"></a>What is Integration Testing</h2><ul>
<li><strong>Integration testing</strong> is the phase of software testing in which individual software modules are combined and tested as a group.</li>
<li>When should this happen?<ul>
<li>Integration testing follows unit testing and precedes system testing.</li>
</ul>
</li>
</ul>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201015/notes-5-1.png" alt="V-model"></p>
<h2 id="Integration-Testing-Cycle"><a href="#Integration-Testing-Cycle" class="headerlink" title="Integration Testing Cycle"></a>Integration Testing Cycle</h2><ul>
<li>Integration is conducted incrementally as a series of test cycles</li>
<li>Additional modules are integrated in each cycle</li>
<li>Continues until all modules are integrated</li>
</ul>
<h2 id="Integration-Testing-Strategy"><a href="#Integration-Testing-Strategy" class="headerlink" title="Integration Testing Strategy"></a>Integration Testing Strategy</h2><ul>
<li>Big Bang</li>
<li>Top-Down</li>
<li>Bottom-Up</li>
</ul>
<h3 id="Big-bang-Integration"><a href="#Big-bang-Integration" class="headerlink" title="Big-bang Integration"></a>Big-bang Integration</h3><ul>
<li>Link all of the modules together as a system</li>
<li>Limited need for test doubles and drivers</li>
<li>Difficult to isolate errors and identify where the problem occurs</li>
<li>Do not verify the interfaces across the module boundaries</li>
<li>Risk of late identification of problems</li>
</ul>
<h3 id="Top-down-Integration"><a href="#Top-down-Integration" class="headerlink" title="Top-down Integration"></a>Top-down Integration</h3><ul>
<li>As the system is constructed, test the interactions of modules from the ‘top’ down to the lower level modules</li>
<li>‘top’ is the module that calls other modules</li>
<li>Breadth-first and Depth-first approaches</li>
<li>Test doubles can be used for some tests</li>
</ul>
<h3 id="Bottom-up-Inegration"><a href="#Bottom-up-Inegration" class="headerlink" title="Bottom-up Inegration"></a>Bottom-up Inegration</h3><ul>
<li>Start with bottom-level components, which have no, or minimal, dependencies</li>
<li>Move up through connectons, verifying the interactions of modules</li>
<li>Driver modules used to test the integrated modules</li>
<li>It is likely that there is less need for Test Doubles because the lower levels will already exist(But, we maybe use test doubles for other reasons)</li>
</ul>
<h2 id="How-often-should-we-run-integration-tests"><a href="#How-often-should-we-run-integration-tests" class="headerlink" title="How often  should we run integration tests?"></a>How often  should we run integration tests?</h2><ul>
<li>Regular integration<ul>
<li>Daily</li>
<li>In an iteration (e.g. two weeks)</li>
</ul>
</li>
<li>Automated tests</li>
<li>A popular modern approach is to run a set of tests regularly as code is checked in<ul>
<li>idea of Continuous Integration (CI)</li>
</ul>
</li>
</ul>
<blockquote>
<p>Focus is on data that will be passed through the interface to other module</p>
</blockquote>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-System Testing</title>
    <url>/2020/10/22/software-testing-notes-6/</url>
    <content><![CDATA[<h2 id="Some-concepts-of-System-testing"><a href="#Some-concepts-of-System-testing" class="headerlink" title="Some concepts of System testing"></a>Some concepts of System testing</h2><ul>
<li><p>System testing is testing conducted on a complete, integrated system to evaluate the system’s compliance with its requirements specifications.</p>
</li>
<li><p>System testing falls within(属于) the scope of black box testing, and as such, should require no knowledge of the inner design of the code or logic.</p>
</li>
</ul>
<h2 id="Why-system-testing-is-necessary"><a href="#Why-system-testing-is-necessary" class="headerlink" title="Why system testing is necessary?"></a>Why system testing is necessary?</h2><ul>
<li>Some properties only verifiable at system level( Installation, usability, compatibility )</li>
<li>We may involve users at this level</li>
<li>The environment of system is taken to account</li>
</ul>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201022/notes-6-1.png" alt="system testing"></p>
<h2 id="System-testing-methods"><a href="#System-testing-methods" class="headerlink" title="System testing methods"></a>System testing methods</h2><h3 id="System-functionality-testing"><a href="#System-functionality-testing" class="headerlink" title="System functionality testing"></a>System functionality testing</h3><ul>
<li>Automate tests where possible</li>
<li>Create test scripts for other areas where a user will perform manual testing</li>
</ul>
<h3 id="GUI-Testing"><a href="#GUI-Testing" class="headerlink" title="GUI Testing"></a>GUI Testing</h3><blockquote>
<p>The diffculties of GUI software testing:</p>
</blockquote>
<ul>
<li>Possible interface test space is massive</li>
<li>Event-driven characteristics</li>
<li>Bad design mixes the interface with the ‘logic’ of the application. This can be harder to test</li>
</ul>
<h3 id="Usability-Testing-and-Accessibility-Testing"><a href="#Usability-Testing-and-Accessibility-Testing" class="headerlink" title="Usability Testing and Accessibility Testing"></a>Usability Testing and Accessibility Testing</h3><h3 id="Performance-Testing"><a href="#Performance-Testing" class="headerlink" title="Performance Testing"></a>Performance Testing</h3><ul>
<li>Performance testing is used to determine the speed or effectiveness of a computer, network, software program or device</li>
<li>Goals: eliminate bottlenecks and improve system reliability</li>
</ul>
<h3 id="Compatibility-Testing"><a href="#Compatibility-Testing" class="headerlink" title="Compatibility Testing"></a>Compatibility Testing</h3><ul>
<li>Compatibility testing is part of software non-functional tests</li>
<li>Conducted on the application to evaluate the application’s compatibility with the computing environment</li>
</ul>
<h3 id="Recovery-Testing"><a href="#Recovery-Testing" class="headerlink" title="Recovery Testing"></a>Recovery Testing</h3><h3 id="Installation-Testing"><a href="#Installation-Testing" class="headerlink" title="Installation Testing"></a>Installation Testing</h3>]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-Performance Testing</title>
    <url>/2020/10/22/software-testing-notes-7/</url>
    <content><![CDATA[<h1 id="A-type-of-system-testing-—-performance-testing"><a href="#A-type-of-system-testing-—-performance-testing" class="headerlink" title="A type of system testing — performance testing"></a>A type of system testing — performance testing</h1><h2 id="Where-does-performance-testing-fit"><a href="#Where-does-performance-testing-fit" class="headerlink" title="Where does performance testing fit ?"></a>Where does performance testing fit ?</h2><ul>
<li>Functional - for detail requirements or use cases</li>
<li><strong>Non-functional</strong> - the performance will be affected if there are larger amounts of data</li>
</ul>
<h2 id="Smart-test"><a href="#Smart-test" class="headerlink" title="Smart test"></a>Smart test</h2><ul>
<li>Specific</li>
<li>Measurable</li>
<li>Achievable</li>
<li>Relevant</li>
<li>Time-based</li>
</ul>
<h2 id="When-do-performance-testing"><a href="#When-do-performance-testing" class="headerlink" title="When do performance testing ?"></a>When do performance testing ?</h2><blockquote>
<p>Later in the development life-cycle(when there is a system test)</p>
</blockquote>
<h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><ul>
<li><strong>stable code base</strong> (The code will not change so the performance testing is meaningful)</li>
<li>Code should have been <strong>tested</strong>(not easily identify a bug or performance issues)</li>
</ul>
<h2 id="Key-Performance-Targets"><a href="#Key-Performance-Targets" class="headerlink" title="Key Performance Targets"></a>Key Performance Targets</h2><ul>
<li>Available or uptime </li>
<li>Concurrency</li>
<li>Response time</li>
<li>Computer usage (CPU, Memory, File I/O Disk )</li>
<li>Network usage (Data Volume / Throughput)</li>
</ul>
<h2 id="Example-types-of-performance-testing"><a href="#Example-types-of-performance-testing" class="headerlink" title="Example types of performance testing"></a>Example types of performance testing</h2><ul>
<li><strong>Pipe clean tests</strong>(validate different performances)</li>
<li><strong>Volume tests</strong>(expected loads)</li>
<li><strong>Stress tests</strong>(what will happen if the application is given more work to do)</li>
<li><strong>Soak / Stability</strong>(extended use tests)</li>
<li><strong>Smoke tests</strong>(focus on the area of change)</li>
<li><strong>Isolation</strong>(focus on specific areas)</li>
</ul>
]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试复习笔记-Testing Management</title>
    <url>/2020/10/22/software-testing-notes-8/</url>
    <content><![CDATA[<h1 id="Software-QA-and-Test-Management"><a href="#Software-QA-and-Test-Management" class="headerlink" title="Software QA and Test Management"></a>Software QA and Test Management</h1><h2 id="Why-do-we-test-software"><a href="#Why-do-we-test-software" class="headerlink" title="Why do we test software ?"></a>Why do we test software ?</h2><ul>
<li>The purpose is to find errors</li>
<li>To have confidence that the system meets its requirements</li>
<li>To produce a high-quality product</li>
<li>• To reduce (minimize) the risk that we fail to achieve the above</li>
</ul>
<h2 id="Quality-Assurance-Quality-Control"><a href="#Quality-Assurance-Quality-Control" class="headerlink" title="Quality Assurance, Quality Control"></a>Quality Assurance, Quality Control</h2><h3 id="Manage-the-process-QA"><a href="#Manage-the-process-QA" class="headerlink" title="Manage the process (QA)"></a>Manage the process (QA)</h3><ul>
<li>For example, detailed quality audit that checks if the specified processes are being followed</li>
<li>Focus on the process and not the product</li>
<li>Aiming to prevent issues</li>
</ul>
<h3 id="Manage-the-product-QC"><a href="#Manage-the-product-QC" class="headerlink" title="Manage the product (QC)"></a>Manage the product (QC)</h3><ul>
<li>For example, testing and code reviews</li>
<li>Focus on product, identifying deficiencies and suggesting improvements</li>
<li>Aiming to detect issues</li>
</ul>
<h2 id="The-benefits-of-standards"><a href="#The-benefits-of-standards" class="headerlink" title="The benefits of standards"></a>The benefits of standards</h2><ul>
<li>Standards capture wisdom that is of value to the organization</li>
<li>Standards provide a framework for defining what quality means in a particular setting</li>
<li>Standards assist continuity when work carried out by one person is taken up and continued by another</li>
</ul>
<h2 id="Test-Metrics"><a href="#Test-Metrics" class="headerlink" title="Test Metrics"></a>Test Metrics</h2><blockquote>
<ol>
<li>Measure the progress of testing in an organization and on projects </li>
<li>Help to understand issues about project progress and testing </li>
<li>Testability – how easy is it to specify and perform tests</li>
</ol>
</blockquote>
<h3 id="Good-use-of-test-metrics"><a href="#Good-use-of-test-metrics" class="headerlink" title="Good use of test metrics"></a>Good use of test metrics</h3><ul>
<li>Early detection of issues</li>
<li>Setting goals</li>
</ul>
<h2 id="Test-Planning-and-Test-case-Recording"><a href="#Test-Planning-and-Test-case-Recording" class="headerlink" title="Test Planning and Test case Recording"></a>Test Planning and Test case Recording</h2>]]></content>
      <categories>
        <category>Software Testing notes</category>
      </categories>
      <tags>
        <tag>Software Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索与图论常用模板</title>
    <url>/2020/11/15/algorithmTemplate-3/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：本篇总结自<a href="https://www.acwing.com">Acwing算法学习网站</a>，通过自己总结和参考Acwing算法基础课的讲解的方式，写下这篇笔记，供复习使用，主要包括图的搜索算法、最短路算法和最小生成树算法。</p>
</blockquote>
<h2 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title="树与图的存储"></a>树与图的存储</h2><ul>
<li>树是一种特殊的图，与图的存储方式相同。</li>
<li>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。</li>
<li>因此我们可以只考虑有向图的存储。</li>
</ul>
<ol>
<li>邻接矩阵(一般用来存储稠密图，边数$m$为$n^2$级别)：<code>g[a][b]表示有一条从a到b的边</code></li>
<li>邻接表(一般用来存储稀疏图)：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表采用的数据结构</span></span><br><span class="line"><span class="comment">//N表示点的数量，M表示边的数量</span></span><br><span class="line"><span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[M], ne = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//h数组表示每一个单链表的头节点</span></span><br><span class="line"><span class="comment">//e数组表示对应下标存储的是哪一个点</span></span><br><span class="line"><span class="comment">//ne数组表示对应点的下标存储的下一个点的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入边的操作，插入一条由a指向b的边</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b; </span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般来说还要在插入边之前初始化头节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; N; i++ )</span><br><span class="line">    h[i] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历邻接表的方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = h[a]; i != -<span class="number">1</span>; i = ne[i] )</span><br><span class="line">    <span class="comment">//do something</span></span><br></pre></td></tr></table></figure>
<h2 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h2><p><strong>时间复杂度$O(n + m)$，$n$表示点数，$m$表示边数</strong></p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p><strong>算法思路：</strong>就是从图（树）中的某个点开始，一条道走到黑，直到无路可走。然后在回溯到上一层看看是不是有路可走。直到所有点都被遍历，深度优先遍历结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//用一个st数组记录当前这个点是否已经被遍历过</span></span><br><span class="line">    st[u] = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历u的所有邻边，继续dfs</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; i != -<span class="number">1</span>; i = ne[i] ) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//如果这个点没有被遍历过</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])</span><br><span class="line">            dfs(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="宽度优先遍历"><a href="#宽度优先遍历" class="headerlink" title="宽度优先遍历"></a>宽度优先遍历</h3><p><strong>算法思路：</strong>就是从图（树）中的某一个节点开始，将所有与该点相邻的点加入队列中，每次从对头弹出一个节点，并重复的将它相邻的节点加入队列中，直到所有的边都被遍历完（队列为空）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="comment">//st数组用来记录当前这个点是否被遍历过</span></span><br><span class="line">st[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">queue.offer(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//只要队列不空</span></span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//弹出对头元素</span></span><br><span class="line">    <span class="keyword">int</span> t = queue.poll();</span><br><span class="line">    <span class="comment">//访问t的所有邻边</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i] )&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            <span class="comment">//加入队列中去</span></span><br><span class="line">            queue.offer(j);</span><br><span class="line">            st[j] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><strong>时间复杂度$O(n + m)$，$n$表示点数，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[N], ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//入度数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] d = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">topoSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将入度为0的点放入队列中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            q[++tt] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果队列不为空</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="comment">//弹出队首元素</span></span><br><span class="line">        <span class="keyword">int</span> t = q[hh++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问t的所有邻边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            d[j]--;</span><br><span class="line">            <span class="comment">//如果入度为0加入队列</span></span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">0</span>)</span><br><span class="line">                q[++tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h2><h3 id="朴素版Dijkstra算法"><a href="#朴素版Dijkstra算法" class="headerlink" title="朴素版Dijkstra算法"></a>朴素版Dijkstra算法</h3><p><strong>算法思路：</strong>每一次都是用当前距离最小的点去更新其他点到源点的距离，这是基于贪心的一种策略。</p>
<p><strong>适用场景：稠密</strong>图求单源最短路（即$m$是$n^2$级别的）且边权不为负数。</p>
<p><strong>时间复杂度：$O(n^2 + m)$，$n$表示点数，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="comment">//状态数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="comment">//距离数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//n表示点数,m表示边数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化距离数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        dist[i] = INF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认原点的距离为0</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++ )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找出当前为确定最短路且距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//用t这个点去更新其他的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + g[t][j])</span><br><span class="line">                dist[j] = dist[t] + g[t][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == INF)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆优化版Dijkstra算法"><a href="#堆优化版Dijkstra算法" class="headerlink" title="堆优化版Dijkstra算法"></a>堆优化版Dijkstra算法</h3><p><strong>算法思路：</strong>每一次都是用当前距离最小的点去更新其他点到源点的距离的基础之上，将每一次找未被确定最短路且距离最小的点时，用一个最小堆来维护距离数组，将查找最小距离这个过程的时间复杂度从$O(n)$下降到$O(logn)$。</p>
<p><strong>适用场景：稀疏</strong>图求单源最短路且边权不为负数。</p>
<p><strong>时间复杂度：$O(mlogn)$，$n$表示点数，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">1500010</span>, INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//邻接链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[N], w = <span class="keyword">new</span> <span class="keyword">int</span>[N], ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//状态数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="comment">//n表示点数,m表示边数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"><span class="comment">//距离数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化距离数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        dist[i] = INF;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用优先队列</span></span><br><span class="line">    PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认原点的距离为0</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一个表示权重，第二个表示是哪一个点</span></span><br><span class="line">    <span class="keyword">int</span>[] v1 = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    queue.offer(v1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果优先队列不为空</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出队首元素</span></span><br><span class="line">        <span class="keyword">int</span>[] t = queue.poll();</span><br><span class="line">        <span class="keyword">int</span> distance = t[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> vertice = t[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果已经被确定过最短距离直接跳过</span></span><br><span class="line">        <span class="keyword">if</span>(st[vertice])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        st[vertice] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//用vertice更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[vertice]; i != -<span class="number">1</span>; i = ne[i] )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; distance + w[i])&#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                <span class="comment">//放入队列中</span></span><br><span class="line">                <span class="keyword">int</span>[] v = &#123;dist[j], j&#125;;</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dist[n] == INF)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman-Ford算法"></a>Bellman-Ford算法</h3><p><strong>算法思路：</strong>Bellman-Ford算法算是一个暴力解法，就是对于图中的每一个点，都要做n - 1次松弛计算。意思就是从a点到b点的最短路径肯定是不会超过n-1条边的，如果n-1次松弛计算都计算不出最短路，只有一种可能，那就是路径中有负环！</p>
<p><strong>适用场景：</strong>求单源最短路，边权可以为负数。可以做有边数限制的最短路问题，比如最多经过k条边的最短路问题。</p>
<p><strong>时间复杂度：$O(nm)$，$n$表示点数，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>, INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a; <span class="keyword">this</span>.b = b; <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//距离数组</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N], backup = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    <span class="comment">//边数组</span></span><br><span class="line">    <span class="keyword">static</span> Edge[] edges = <span class="keyword">new</span> Edge[M];</span><br><span class="line">    <span class="comment">//n表示点数，m表示边数，k表示最多经过k条边</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bellmanFord</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化距离数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">            dist[i] = INF;</span><br><span class="line"></span><br><span class="line">        dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//k次迭代</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++ )&#123;</span><br><span class="line">            <span class="comment">//重置备份数组</span></span><br><span class="line">            System.arraycopy(dist, <span class="number">1</span>, backup, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++ )&#123;</span><br><span class="line">                Edge edge = edges[j];</span><br><span class="line">                <span class="keyword">int</span> a = edge.a, b = edge.b, w = edge.w;</span><br><span class="line">                <span class="keyword">if</span>(dist[b] &gt; backup[a] + w )</span><br><span class="line">                    dist[b] = backup[a] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        String[] ins = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        n = Integer.parseInt(ins[<span class="number">0</span>]); m = Integer.parseInt(ins[<span class="number">1</span>]); k = Integer.parseInt(ins[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读入m条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )&#123;</span><br><span class="line">            ins = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> a = Integer.parseInt(ins[<span class="number">0</span>]), b = Integer.parseInt(ins[<span class="number">1</span>]), w = Integer.parseInt(ins[<span class="number">2</span>]);</span><br><span class="line">            edges[i] = <span class="keyword">new</span> Edge(a, b, w);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Bellman-ford</span></span><br><span class="line">        bellmanFord();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dist[n] &gt; INF / <span class="number">2</span>)</span><br><span class="line">            bw.write(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            bw.write(dist[n] + <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.flush();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spfa-算法（队列优化的Bellman-Ford算法）"><a href="#spfa-算法（队列优化的Bellman-Ford算法）" class="headerlink" title="spfa 算法（队列优化的Bellman-Ford算法）"></a>spfa 算法（队列优化的Bellman-Ford算法）</h3><p><strong>算法思路：</strong>spfa的总体算法思路和Bellman-Ford算法差不多，它是当前如果某个点a到源点的距离变小了，就将这个点加入到队列中去，然后每次弹出队首元素，用这个点去更新它相邻的点的值，如果相邻的点距离变小了，那么也把他们加入到队列中去，直到队列为空，就是没有点的距离可以被更新的更短了，就找到了最短路径，spfa松弛计算的次数往往比Bellman-Ford要少。</p>
<p><strong>适用场景：</strong>求单源最短路，边权可以为负数。注意图中不能有负环，否则不能用它来求最短路，但是可以用spfa来判断负环。</p>
<p><strong>时间复杂度：平均情况下$O(m)$，最坏情况下$O(nm)$，$n$表示点数，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>, INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//邻接表存储图</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[N], w = <span class="keyword">new</span> <span class="keyword">int</span>[N], ne = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//状态数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="comment">//距离数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b; w[idx] = c; ne[idx] = h[a]; h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化距离</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        dist[i] = INF;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//初始化原点距离</span></span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    st[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">    queue.offer(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果队列不为空</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//弹出队首元素</span></span><br><span class="line">        <span class="keyword">int</span> t = queue.poll();</span><br><span class="line">        <span class="comment">//恢复状态</span></span><br><span class="line">        st[t] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用队首去更新其他点的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i] )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="comment">//松弛点如果没有被加到队列中去</span></span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    queue.offer(j);</span><br><span class="line">                    st[j] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spfa判断图中是否存在负环"><a href="#spfa判断图中是否存在负环" class="headerlink" title="spfa判断图中是否存在负环"></a>spfa判断图中是否存在负环</h3><p><strong>算法思路：</strong>和spfa求最短路类似，就是把图中每一个点用spfa求一遍最短路，如果其中有一个最短路通过的点数是n+1了，那么就说明一定有两个点是相同的，因为一共就只有n个点，那么这个点就是存在负环的。</p>
<p><strong>适用场景：</strong>判断图中是否存在负环</p>
<p><strong>时间复杂度：$O(nm)$，$n$表示点数，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], e = <span class="keyword">new</span> <span class="keyword">int</span>[M], w = <span class="keyword">new</span> <span class="keyword">int</span>[M], ne = <span class="keyword">new</span> <span class="keyword">int</span>[M];</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//距离数组</span></span><br><span class="line"><span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//状态数组</span></span><br><span class="line"><span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="comment">//记录每个点的最短距离经过了多少个点</span></span><br><span class="line"><span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">//将n个点加入到队列中去</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        queue.offer(i);</span><br><span class="line">        st[i] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列不为空</span></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="comment">//取出队首元素</span></span><br><span class="line">        <span class="keyword">int</span> t = queue.poll();</span><br><span class="line">        st[t] = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//更新t的相邻元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; i != -<span class="number">1</span>; i = ne[i] )&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="comment">//判断是否需要松弛</span></span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])&#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//说明有负环</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[j] == n + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                    queue.offer(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p><strong>算法思路：</strong>Floyd算法是基于动态规划提出的一种算法，<code>状态表示：f[k][i][j]表示从1~k个点当中选，使得点i到点j的距离最短。</code></p>
<p><code>状态计算：可以通过是否经过第k个点来划分状态，d[k][i][j] = Math.min(d[k - 1][i][j], d[k][i][k] + d[k][k][j])</code></p>
<p><code>通过优化之后的状态就是d[i][j] = Math(d[i][j], d[i][k] + d[k][j])</code></p>
<p><strong>适用场景：</strong>多源汇最短路问题（任意两点之间的最短路）</p>
<p><strong>时间复杂度：$O(n^3)$，$n$表示点数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">210</span>, INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//邻接矩阵存图</span></span><br><span class="line"><span class="keyword">int</span>[][] d = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="comment">//n表示点数，m表示边数，q表示询问次数</span></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++ )</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ )</span><br><span class="line">                d[i][j] = Math.min(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p><strong>算法思路：</strong>Prim算法也是基于贪心的一种算法，就是从图中任意一个点开始，将这个点加入到最小生成树中，下一次加入离最小生成树最近的点，直到图中的所有点都加入最小生成树中。</p>
<p><strong>适用场景：</strong>稠密图求最小生成树</p>
<p><strong>时间复杂度：$O(n^2 + m)$，$n$表示点数，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">510</span>, INF = (<span class="keyword">int</span>)<span class="number">1e9</span>;</span><br><span class="line"><span class="comment">//使用邻接矩阵存图</span></span><br><span class="line"><span class="keyword">int</span>[][] g = <span class="keyword">new</span> <span class="keyword">int</span>[N][N];</span><br><span class="line"><span class="comment">//表示这个点已经在最小生成树里了</span></span><br><span class="line"><span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="comment">//表示这个点到最小生成树的距离</span></span><br><span class="line"><span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//n表示点数，m表示边数</span></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化距离数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">        dist[i] = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">        <span class="keyword">int</span> t = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找到一个距离最小生成树最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == -<span class="number">1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个点不是第一个点</span></span><br><span class="line">        <span class="keyword">if</span>(t != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//表示这个点和其他点没有边，没有最小生成树</span></span><br><span class="line">            <span class="keyword">if</span>(dist[t] == INF)</span><br><span class="line">                <span class="keyword">return</span> INF;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                res += dist[t];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个点加入到最小生成树当中去</span></span><br><span class="line">        st[t] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用t去更新其他点的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++ )&#123;</span><br><span class="line">            <span class="comment">//如果这个点不在最小生成树中，就更新这个点的值</span></span><br><span class="line">            <span class="keyword">if</span>(!st[k])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[k] &gt; g[t][k])</span><br><span class="line">                    dist[k] = g[t][k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><p><strong>算法思路：</strong>Kruskal算法是一个特别优美求最小生成树的算法，主要的思想是先将所有边按权重从小到大进行排序（算法主要的时间复杂度就在排序算法上，可以使用快排或者归并排序）；然后将每一条边遍历一遍，如果一条边的两个点不在同一个集合里，就将两个集合合并。如果合并的次数为n -1（n表示点数），表示图中有最小生成树。</p>
<p><strong>适用场景：</strong>稀疏图求最小生成树</p>
<p><strong>时间复杂度：$O(mlogm)$，$m$表示边数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">200010</span>;</span><br><span class="line">    <span class="comment">//存边</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a; <span class="keyword">this</span>.b = b; <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存边数组</span></span><br><span class="line">    <span class="keyword">static</span> Edge[] edges = <span class="keyword">new</span> Edge[M];</span><br><span class="line">    <span class="comment">//n表示点数，m表示边数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="comment">//表示每个点的祖先节点是啥</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//并查集路径压缩</span></span><br><span class="line">        <span class="keyword">if</span>(x != p[x])</span><br><span class="line">            p[x] = find(p[x]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        String[] ins = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        n = Integer.parseInt(ins[<span class="number">0</span>]); m = Integer.parseInt(ins[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//存入m条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ )&#123;</span><br><span class="line">            ins = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> a = Integer.parseInt(ins[<span class="number">0</span>]), b = Integer.parseInt(ins[<span class="number">1</span>]), w = Integer.parseInt(ins[<span class="number">2</span>]);</span><br><span class="line">            edges[i] = <span class="keyword">new</span> Edge(a, b, w);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化所有的px</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++ )</span><br><span class="line">            p[i] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//首先将所有边排序</span></span><br><span class="line">        Arrays.sort(edges, <span class="number">0</span>, m, (e1, e2) -&gt; e1.w - e2.w );</span><br><span class="line">        <span class="comment">//res表示最小生成树中边所有的权重，cnt表示最小生成树中边的数量</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )&#123;</span><br><span class="line">            Edge edge = edges[i];</span><br><span class="line">            <span class="keyword">int</span> a = edge.a, b = edge.b, w = edge.w;</span><br><span class="line">            a = find(a); b = find(b);</span><br><span class="line">            <span class="comment">//表示a, b两点不在同一个集合里</span></span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                <span class="comment">//将两个集合合并</span></span><br><span class="line">                p[a] = b;</span><br><span class="line">                <span class="comment">//记录这两个边的权重</span></span><br><span class="line">                res += w;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出结果</span></span><br><span class="line">        <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)</span><br><span class="line">            bw.write(res + <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//表示至少有一条边不可达，没有最小生成树</span></span><br><span class="line">            bw.write(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        bw.flush();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>邻接表</tag>
        <tag>邻接矩阵</tag>
        <tag>深度优先遍历</tag>
        <tag>广度优先遍历</tag>
        <tag>Dijkstra</tag>
        <tag>Bellman-Ford</tag>
        <tag>spfa</tag>
        <tag>Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>hash表的基本原理以及Java的hash表部分源码的个人理解</title>
    <url>/2020/10/28/java-basic-1/</url>
    <content><![CDATA[<blockquote>
<p>有关Java的哈希表源码讲解比较好的几篇博文：</p>
<ol>
<li><a href="https://www.cnblogs.com/xuxinstyle/p/9537249.html">HashMap常见面试题总结</a></li>
<li><a href="https://blog.csdn.net/qq_35967283/article/details/86497796">ConcurrentHashMap的工作原理</a></li>
<li><a href="https://blog.csdn.net/weixin_43892898/article/details/88979688">Hashtable和HashMap的区别和联系</a></li>
</ol>
</blockquote>
<h2 id="Hash表的基本原理"><a href="#Hash表的基本原理" class="headerlink" title="Hash表的基本原理"></a>Hash表的基本原理</h2><p>​    hash表是根据索引快速定位数据的一种数据结构，在<sup><a href="#fn_理想情况" id="reffn_理想情况">理想情况</a></sup>下，它的增删查改的时间复杂度都是O(1)的。简单来说，比如有1111，2222， 3333, …. , 5689这些数，我想知道9527这个数存不存在，最简单的方式就是将这个数列遍历一遍，找出是否存在这个数，但是如果数据量特别大比如10亿，显然这样做的效率是特别低的。hash表就是先将每一个数先通过<strong>hash函数</strong>存进一个数组中，当我要查询9527这个数的时候，再通过hash函数找到这个数的下标，这个操作是O(1)的！因此hash表在理想状况下是高效的。</p>
<h2 id="常见的Hash函数"><a href="#常见的Hash函数" class="headerlink" title="常见的Hash函数"></a>常见的Hash函数</h2><h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p>​    如果需要存储一系列的整数，可以选取一个大小为M的素数(素数可以尽量避免冲突)的散列数组，对于任意整数k，采用k % M的方式可以将任意一个整数映射到0~M - 1的索引中，数据量不大的情况下可以考虑这种hash函数。</p>
<h3 id="Java对象的HashCode"><a href="#Java对象的HashCode" class="headerlink" title="Java对象的HashCode"></a>Java对象的HashCode</h3><h4 id="普通的Java对象"><a href="#普通的Java对象" class="headerlink" title="普通的Java对象"></a>普通的Java对象</h4><p>使用的本地的hashcode方法，是使用c++实现的，返回一个唯一的32位int值，但不是对象的内存地址。</p>
<h4 id="基本类型的包装类-wrapper"><a href="#基本类型的包装类-wrapper" class="headerlink" title="基本类型的包装类(wrapper)"></a>基本类型的包装类(wrapper)</h4><p><strong>Integer:</strong> 直接返回value值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer num = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">System.out.println(num.hashcode()); <span class="comment">// hashcode值为5</span></span><br></pre></td></tr></table></figure>
<p><strong>Long和Double:</strong> 用于这两种类型都是64位的，Java使用的是前32位与后32位的异或值来作为hashcode值</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Long source code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(value ^ (value &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Double source code</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">(<span class="keyword">double</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bits = doubleToLongBits(value);</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(bits ^ (bits &gt;&gt;&gt; <span class="number">32</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>String:</strong> Java中String的hashcode方法是将字符串看成一个字符数组，并将这个数组看成一个31进制的数，计算完hashcode之后，直接将hashcode存入成员变量中，避免重复计算。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// source code of String hashcode() method</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hash表解决冲突的两种方式"><a href="#Hash表解决冲突的两种方式" class="headerlink" title="Hash表解决冲突的两种方式"></a>Hash表解决冲突的两种方式</h2><p>​    但是在一般情况下，两个不同的数通过hash函数计算可能会指向同一个数组的索引，因此我们需要采用某些方法来处理这种情况。</p>
<h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201029/j-b-1.png" alt><br>    <strong>如上图所示，通过某一个hash函数，23, 14, 88, 64这四个数指向了同一个数组的索引，拉链法就是在冲突的地方新开一个链表用于存储这些数。当我们需要查找88时，第一步是先找到88所在的链表的位置，第二步是顺序遍历这个链表，直到找到88这个元素。</strong></p>
<p>​    <strong>假设数据量的大小为N，散列表的数组长度为M(N &gt; M)。在理想情况下（即hash函数能够随机的将每一个数指向数组中的任意位置），查找一个数的时间复杂度为O($\frac{N}{M}$)；最坏的情况下，hash表会退化成顺序查找，即hash表退化成链表，时间复杂度为O(N)。因此可以看出选取一个良好的hash函数是多么重要！</strong></p>
<h3 id="线性探测法-开放地址法"><a href="#线性探测法-开放地址法" class="headerlink" title="线性探测法(开放地址法)"></a>线性探测法(开放地址法)</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201029/j-b-2.png" alt><br>    <strong>根据图示，当要在索引为0的hash表中插入12，显然这里已经插入了38，冲突产生了。线性探测法的方式特别简单，就是检查hash表下一个位置（索引+1）是否有值；如果没有值，就插入，如果有值，就一直往后查找，直到找到第一个没有使用的hash表下标。如果一直找到hash表的数组末尾都没有找到，那就继续从下标为0的位置开始找。</strong></p>
<p>​    <strong>根据线性探测法的原理，hash表的大小一般要为数据量的两倍，这样线性探测法的效率会更高一些。</strong></p>
<h2 id="Java中的Hashtable"><a href="#Java中的Hashtable" class="headerlink" title="Java中的Hashtable"></a>Java中的Hashtable</h2><h3 id="Hash函数"><a href="#Hash函数" class="headerlink" title="Hash函数"></a>Hash函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line"><span class="comment">//0x7FFFFFFF就是Integer.MAX_VALUE</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Java的hash函数的实现：先获取key.hashcode()，再通过与运算获取32位中所有为1的bit位；用这个数对当前hashtable的大小进行取余运算，获取下标index。<code>(hash &amp; 0x7FFFFFFF)</code>可以保证值一定是非负的。</p>
</blockquote>
<h3 id="⭐put方法"><a href="#⭐put方法" class="headerlink" title="⭐put方法"></a>⭐put方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用synchronized关键字保证一个线程在添加值的时候，其他线程处于等待状态</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//key值不能为空，否则会抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">    <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">    <span class="comment">//通过hash函数获取下标index</span></span><br><span class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="comment">//获取下标为index的entry(桶)</span></span><br><span class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">       	<span class="comment">//如果key已经存在，更新value值</span></span><br><span class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">            V old = entry.value;</span><br><span class="line">            entry.value = value;</span><br><span class="line">            <span class="comment">//直接返回</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//key不存在，将key和value值存入对应的entry,value值不能为空，否在会抛异常</span></span><br><span class="line">    addEntry(hash, key, value, index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="⭐rehash方法"><a href="#⭐rehash方法" class="headerlink" title="⭐rehash方法"></a>⭐rehash方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">    Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩容后的Hashtable长度 = 原长度的2倍 + 1</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//负载因子loadFactor默认是0.75,计算threshold边界值</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">    table = newMap;</span><br><span class="line">	<span class="comment">//将hashtable中原有的元素通过hash函数放入新的hashtable中</span></span><br><span class="line">    <span class="comment">//从后往前遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = old;</span><br><span class="line">            old = old.next;</span><br><span class="line">			<span class="comment">//通过hash函数计算数组下标索引</span></span><br><span class="line">            <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">            <span class="comment">//采用头插法插入链表，所以原先在同一链表的元素，如果经过hash函数之后仍然还在同一个链表的话，他们在新的链表中的顺序就会相反</span></span><br><span class="line">            e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">            newMap[index] = e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>​    ⭐<strong>Hashtable在常用的方法声明上都加上了synchronize关键字，这就导致了当数据量特别大并在多线程并发访问的情况下，效率特别低，速度很慢，因为它一时刻只允许一个线程在操作Hashtable。但是Hashtable是线程同步的，且数据一致。现在多用ConcurrentHashMap来替代Hashtable。</strong></p>
<h2 id="Java中的HashMap"><a href="#Java中的HashMap" class="headerlink" title="Java中的HashMap"></a>Java中的HashMap</h2><blockquote>
<p>HashMap可以说是Java中使用的最多的键值对散列表，通过Java源码（JDK1.8）我们可以了解到它继承了<code>AbstractMap类</code>并实现了<code>Map, Cloneable, Serializable接口</code>；Hashtable和它不同的是他们继承的父类不同，Hashtable继承的是<code>Dictionary类</code>（Dictionary抽象类已被弃用）。HashMap虽然性能比Hashtable要好，但是HashMap是线程不安全的！</p>
</blockquote>
<h3 id="几个关键的成员变量"><a href="#几个关键的成员变量" class="headerlink" title="几个关键的成员变量"></a>几个关键的成员变量</h3><h4 id="⭐DEFAULT-INITIAL-CAPACITY"><a href="#⭐DEFAULT-INITIAL-CAPACITY" class="headerlink" title="⭐DEFAULT_INITIAL_CAPACITY"></a>⭐<code>DEFAULT_INITIAL_CAPACITY</code></h4><p><strong>HashMap的默认大小，如果不指定，默认为16，源码使用的是<code>1 &lt;&lt; 4</code>来表示16</strong></p>
<h4 id="⭐DEFAULT-LOAD-FACTOR"><a href="#⭐DEFAULT-LOAD-FACTOR" class="headerlink" title="⭐DEFAULT_LOAD_FACTOR"></a>⭐<code>DEFAULT_LOAD_FACTOR</code></h4><p><strong>HashMap的默认负载因子，当元素的个数超过<code>HashMap的大小*factor</code>时，会进行hash表扩容，默认大小为0.75</strong></p>
<h4 id="⭐MIN-TREEIFY-CAPACITY"><a href="#⭐MIN-TREEIFY-CAPACITY" class="headerlink" title="⭐MIN_TREEIFY_CAPACITY"></a>⭐<code>MIN_TREEIFY_CAPACITY</code></h4><p><strong>最小树形化容量，当HashMap的一个bin(桶)中的节点个数太多时，即链表元素太多时，Java8的一个优化是将这个链表转换为红黑树。但是，如果HashMap的容量小于<code>MIN_TREEIFY_CAPACITY</code>时，HashMap的做法是扩容，而不是转换为红黑树，默认大小为64。</strong></p>
<h4 id="TREEIFY-THRESHOLD"><a href="#TREEIFY-THRESHOLD" class="headerlink" title="TREEIFY_THRESHOLD"></a><code>TREEIFY_THRESHOLD</code></h4><p><strong>树形化阈值，当一个桶中的节点数目达到该阈值时，节点会由链表存储改为使用红黑树存储，默认大小为8。</strong></p>
<h4 id="UNTREEIFY-THRESHOLD"><a href="#UNTREEIFY-THRESHOLD" class="headerlink" title="UNTREEIFY_THRESHOLD"></a><code>UNTREEIFY_THRESHOLD</code></h4><p><strong>还原成链表的阈值，当桶中的节点树小于该值时，节点会由红黑树存储改为使用链表存储，默认大小为6。</strong></p>
<h3 id="⭐Hash函数"><a href="#⭐Hash函数" class="headerlink" title="⭐Hash函数"></a>⭐Hash函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 如果key不为空，将hashcode值的高16位与低16位进行异或运算；</span></span><br><span class="line"><span class="comment">	* 这样可以尽可能多的保留高16位和低16位的特征，减小冲突发生的概率</span></span><br><span class="line"><span class="comment">	* 同时也说明HashMap允许key值为空</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="⭐putVal方法"><a href="#⭐putVal方法" class="headerlink" title="⭐putVal方法"></a>⭐putVal方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * tab表示HashMap用于存储节点的数组</span></span><br><span class="line"><span class="comment">    * p是Node指针</span></span><br><span class="line"><span class="comment">    * n表示HashMap的长度</span></span><br><span class="line"><span class="comment">    * i表示即将要插入的key,value的桶(bin)的下标</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果当前HashMap未初始化，先初始化HashMap</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//使用 (n - 1) &amp; hash相当于之前提到的除留余数法中的取模运算，使用位运算效率更高</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//表示索引为i的下标的桶未被占用，可以插入新的元素</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//hash相同，且对应的桶不为空，说明冲突产生了！</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * e表示Node指针(有可能是红黑树的node，也有可能是链表的node)</span></span><br><span class="line"><span class="comment">        * k表示key值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//这一个判断表示桶的头部和key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//将e指向p</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//桶的头部与key不相等，判断这个桶是否是用红黑树来存储节点的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//将key和value放到红黑树中，如果存在相同的key，将对应的node返回，如果不存在，则返回null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//进入这个判断说明是使用链表来存储节点的，循环遍历列表</span></span><br><span class="line">            <span class="comment">//binCount用于记录链表中节点的个数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//表示遍历到链表结尾仍然没有找到key，说明可以插入key和value</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//当插入完这个节点后，节点的个数如果达到树形化的阈值，考虑是否需要树形化</span></span><br><span class="line">                    <span class="comment">//因为此时如果HashMap的长度如果小于最小树形化容量的话，需要扩容而不是使用红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表中找到了这个key直接终止循环</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//更新p指针(因为下一次循环要使用p.next)</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果e不为空说明找到了对应的key</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//key对应的旧值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//put方法中onlyIfAbsent置为false，说明如果对应的key中存在值，就将旧值更新为新值</span></span><br><span class="line">            <span class="comment">//同时如果oldValue为空，也需要更新，说明HashMap中允许value值为空</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//如果此时HashMap的长度大于临界值，需要扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="⭐resize方法"><a href="#⭐resize方法" class="headerlink" title="⭐resize方法"></a>⭐resize方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">//使用oldTab表示扩容之前的HashMap数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="comment">//如果HashMap未初始化，将oldCap置为0，否则为oldTab的长度</span></span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="comment">//oldThr表示扩容之前的阈值(数组内元素个数达到阈值将会扩容)</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="comment">//初始化新的容量和新的阈值</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">   	<span class="comment">//表示原HashMap数组中有元素</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//检查原HashMap数组的元素个数是否达到数组的最大上限(2的31次方)</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//将阈值设为32位int的最大整数值，无法进行扩容了</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将newCap扩容成oldCap的两倍，判断是否大于最大上限，同时判断oldCap是否大于默认长度</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">//符合上述扩容规则，新的阈值也扩容成oldThr的两倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断执行到这里，说明HashMap的oldCap为0或者扩容之后的newCap已经大于了数组最大上限</span></span><br><span class="line">    <span class="comment">//或者扩容前的数组容量小于默认容量值(16)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//将newCap的容量置为oldThr阈值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//表示连扩容之前的阈值也0，将newCap和newThr初始化为默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">//比如默认负载因子为0.75，默认容量为16，那么newThr为12</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//newThr还未被初始化，但从上述判断语句中可以肯定newCap已经扩容完成</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果newCap合法，且根据newCap计算的阈值也合法，就将值赋给newThr</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新阈值</span></span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">//开始将扩容前数组内的元素加到新的数组中去</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从头开始遍历桶数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">//e为遍历数组元素的node指针</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">//表示桶的头部有值，要将这个桶加到新的数组中去</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//释放空间</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//表示桶内只有一个元素</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//直接将该元素通过hash值映射到新的数组中去</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//如果这个桶采用红黑树存储节点，将这个红黑树切分</span></span><br><span class="line">                <span class="comment">//切分可以将红黑树退化回链表并将红黑树中的元素加到新的数组中去</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明桶采用的是链表存储节点</span></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * loHead和loTail一组指针存取的是e.hash &amp; oldCap为0的链表的元素</span></span><br><span class="line"><span class="comment">                    * hiHead和hiTail一组指针存取这是与运算不为0的链表元素</span></span><br><span class="line"><span class="comment">                    * 同时被这两组指针拆分的链表是保序的</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//这两个链表分别存在下标为j和j + oldCap的桶的位置</span></span><br><span class="line">                    <span class="comment">//这么做的目的我认为是要分散数据存储，减少冲突</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Java中的ConcurrentHashMap"><a href="#Java中的ConcurrentHashMap" class="headerlink" title="Java中的ConcurrentHashMap"></a>Java中的ConcurrentHashMap</h2><p>​    <strong>由于本人使用的ConcurrentHashMap的次数不多，具体源码分析可以直接看开头推荐的第二篇博文，以后经常使用了再补充有关于ConcurrentHashMap的笔记！😁</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>从Hash表的存储原理到Hash表处理冲突的方式，再到Java源码的理解，我认为最难理解的还是如何选取合适的hash函数，使得hash函数的映射到每一个位置的概率相等，还有一点就是ConcurrentHashMap如何保证在多线程的情况下还能保证一定的效率。随着自己的理解深入，要记得回来补充一下笔记！</strong></p>
<blockquote id="fn_理想情况">
<sup>理想情况</sup>. 即任何两个数经过hash函数的索引得到的值都是唯一的，但往往这种状况很难实现。<a href="#reffn_理想情况" title="Jump back to footnote [理想情况] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>使用管程实现生产者消费者问题（Java实现）</title>
    <url>/2020/11/19/MutipleThread-2/</url>
    <content><![CDATA[<h2 id="生产者消费者问题（管程实现版本）"><a href="#生产者消费者问题（管程实现版本）" class="headerlink" title="生产者消费者问题（管程实现版本）"></a>生产者消费者问题（管程实现版本）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition full;</span><br><span class="line">    <span class="keyword">private</span> Condition empty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Monitor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">        full = lock.newCondition();</span><br><span class="line">        empty = lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实现互斥</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//如果缓冲区已满，生产者线程开始等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == SIZE)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                full.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产者生产了一个1个产品，当前有 &quot;</span> + count +<span class="string">&quot;个产品。&quot;</span>);</span><br><span class="line">        <span class="comment">//表示之前缓冲区为空，唤醒一个消费者线程</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">1</span>)</span><br><span class="line">            empty.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实现互斥</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//如果当前没有产品，消费者线程开始等待</span></span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                empty.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count--;</span><br><span class="line">        System.out.println(<span class="string">&quot;消费者消费了一个1个产品，当前有 &quot;</span> + count +<span class="string">&quot;个产品。&quot;</span>);</span><br><span class="line">        <span class="comment">//表示之前缓冲区满了，唤醒一个生产者线程</span></span><br><span class="line">        <span class="keyword">if</span>(count == SIZE - <span class="number">1</span>)</span><br><span class="line">            full.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            monitor.insert();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            monitor.remove();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>同步与互斥</tag>
        <tag>管程</tag>
      </tags>
  </entry>
  <entry>
    <title>关于生活的一些看法</title>
    <url>/2020/11/21/life-1/</url>
    <content><![CDATA[<p>最近两天从早到晚总是在无所事事，每次照镜子都能从镜子中看到那个令自己讨厌的自己。之前也总有无所事事的时候，看一看鸡汤仿佛又能充满动力，可是这样日复一日的重复，自己始终陷在里面。生活并没有变好，每天从早到晚坐在同样的位置，漫无目标，感觉自己就是局外人。</p>
<p>今天下午看完了《超脱》，才发现一些我一直以来想要寻找的答案。无论此刻的生活有多么不如意，保持现状情况只会变差不会变好。将自己对生活的期待依赖在别人身上，情况只会变得更差。当生活特别颓废的时候，选择阅读会比无意义的娱乐要好太多。阅读的太少，会限制自己的想象力。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>第一行代码——Android书学习踩坑记录</title>
    <url>/2020/11/24/Android-1/</url>
    <content><![CDATA[<blockquote>
<p>最近一直在看《第一行代码——Android》这一本书，由于我使用的SDK是30 version，而书上的代码还是Android 7.0版本的，有一些API已经无法使用，写一篇博客记录一下需要改变的地方，持续更新~</p>
</blockquote>
<h2 id="第三章——UI开发"><a href="#第三章——UI开发" class="headerlink" title="第三章——UI开发"></a>第三章——UI开发</h2><ol>
<li><p><strong>PercentFrameLayout引入依赖报错</strong></p>
<p><em>原文：在app目录下的build.gradle文件的dependencies加入</em></p>
<p><code>complie &#39;com.android.support:percent:24.2.1&#39;</code></p>
<p><strong>Andriod X中推荐使用implementation进行引包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.percentlayout:percentlayout:1.0.0&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>不幸的是，PercentFrameLayout和PercentRelativeLayout已经过时，源码中给出了这样的解释</strong></p>
<blockquote>
<p>@deprecated consider using ConstraintLayout and associated layouts instead. The following shows<br> how to replicate the functionality of percentage layouts with a ConstraintLayout.</p>
</blockquote>
<p><em>官方推荐使用ConstraintLayout 来代替百分比布局</em></p>
</li>
<li><p><strong>RecyclerView引入依赖出错</strong></p>
<p><em>原文：在app目录下的build.gradle文件的dependencies加入</em></p>
<p><code>complie &#39;com.android.support:recyclerview-v7:24.2.1&#39;</code></p>
<p><strong>Andriod X中推荐使用implementation进行引包</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.recyclerview:recyclerview:1.2.0-alpha06&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>制作Nine-Patch 图片时在SDK/tools目录下找不到draw9patch.bat文件</strong></p>
<p>解决方案：目前Android studio已经内置了这个功能，只需要选中图片，右键<code>create 9-Patch file..</code>即可。</p>
</li>
</ol>
<h2 id="第四章——探究碎片"><a href="#第四章——探究碎片" class="headerlink" title="第四章——探究碎片"></a>第四章——探究碎片</h2><ol>
<li><p><strong>无法引入android:support.v4.app.Fragment</strong></p>
<p><strong>Androidx中使用</strong><code>import androidx.fragment.app.Fragment</code><strong>代替！</strong></p>
</li>
</ol>
<h2 id="第五章——详解广播机制"><a href="#第五章——详解广播机制" class="headerlink" title="第五章——详解广播机制"></a>第五章——详解广播机制</h2><ol>
<li><p><code>connectionManager.getActiveNetworkInfo()</code><strong>方法过时问题</strong></p>
<p><strong>将NetworkChangeReceiver中的onReceive方法替换成</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    ConnectivityManager connectivityManager =</span><br><span class="line">        (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    Network network = connectivityManager.getActiveNetwork();</span><br><span class="line">    <span class="keyword">if</span> (network != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;network is available&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">&quot;network is unavailable&quot;</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送静态广播失败</strong></p>
<p><em>原因：Android8.0以上的高版本对静态(隐式)广播做了一些限制</em></p>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201130/Android1-1.png" alt></p>
<p><strong>解决方案</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">&quot;com.nicklaus.broadcasttest.MY_BROADCAST&quot;</span>);</span><br><span class="line"><span class="comment">//在发送广播前要使用setComponent方法指定包名和接收器的全限定名</span></span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(getPackageName(), <span class="string">&quot;com.nicklaus.broadcasttest.MyBroadcastReceiver&quot;</span>));</span><br><span class="line">sendBroadcast(intent);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LocalBroadcastManager找不到（使用本地广播）</strong></p>
<p><em>原因：最新的Androidx中已经将LocalBroadcastManager废弃，需要重新引入依赖</em></p>
<p><strong>解决方案</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&#x27;androidx.localbroadcastmanager:localbroadcastmanager:1.0.0&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>bug踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>数学知识常用模板</title>
    <url>/2020/11/26/algorithmTemplate-4/</url>
    <content><![CDATA[<blockquote>
<p>写在前面：本篇总结自<a href="https://www.acwing.com">Acwing算法学习网站</a>，通过自己总结和参考Acwing算法基础课的讲解的方式，写下这篇笔记，供复习使用，主要包括质数（质数判定，分解质因数，筛素数）、约数（约数个数，最大公约数）、快速幂等等。</p>
</blockquote>
<h2 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title="试除法判定质数"></a>试除法判定质数</h2><p><strong>算法思路：</strong>比如有一个数$n$，暴力解法就是$i$从$2$到$n-1$枚举，判断$n$ % $i$ == $0$，如果等式成立，说明$n$不是质数。但是很明显$n$的因数是成对存在的。比如$10$的因数有$2$和$5$，所以实际上只需要枚举$\sqrt{n}$个数即可。这时的计算时间复杂度$O(n)$下降到$O(\sqrt{n})$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断边界</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++ )&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;No&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="试除法分解质因数"><a href="#试除法分解质因数" class="headerlink" title="试除法分解质因数"></a>试除法分解质因数</h2><p><strong>算法思路：</strong>首先要明确一个事，一个数$n$不会同时有两个质因子$i, j$均大于$\sqrt{n}$，所以分解质因数也可以用试除法来实现，时间复杂度为$O(\sqrt{n})$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDivisor</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++ )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(i +<span class="string">&quot; &quot;</span>+cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明x还有一个很大的质因子</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(x + <span class="string">&quot; &quot;</span> + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="筛质数（线性筛法）"><a href="#筛质数（线性筛法）" class="headerlink" title="筛质数（线性筛法）"></a>筛质数（线性筛法）</h2><p><strong>算法思路：</strong>每次使用一个数的最小质因子将这个数$x$筛除掉。时间复杂度为$O(n)$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="comment">//存储质数的数组</span></span><br><span class="line"><span class="keyword">int</span>[] primes = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//表示这个数有没有被筛掉的st状态数组</span></span><br><span class="line"><span class="keyword">boolean</span>[] st = <span class="keyword">new</span> <span class="keyword">boolean</span>[N];</span><br><span class="line"><span class="comment">//记录素数的个数</span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPrimes</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">         <span class="comment">//埃式筛法，将质数的倍数筛掉</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + i; j &lt;= n; j += i )&#123;</span><br><span class="line">                st[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线性筛法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++ ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最多只需要筛到sqrt(i)就可以</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j++ )&#123;</span><br><span class="line">            <span class="comment">//primes[j]是primes[j] * j的最小质因子</span></span><br><span class="line">            st[primes[j] * i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//如果primes[j]是i的最小质因子，直接break</span></span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h2><p><strong>算法思路：</strong>一个数$n$的约数总是成对存在的，比如数$24$的约数$3$和$8$是一对。所以也只需要枚举到$\sqrt{n}$即可。算法时间复杂度是$O(\sqrt{n})$。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">getDivisor</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x / i; i++ )&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i != x / i)</span><br><span class="line">                res.add(x / i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将所有约数进行排序</span></span><br><span class="line">    Collections.sort(res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求最大公约数（欧几里得算法）"><a href="#求最大公约数（欧几里得算法）" class="headerlink" title="求最大公约数（欧几里得算法）"></a>求最大公约数（欧几里得算法）</h2><p><strong>算法思路：</strong>假设$x$是$a$和$b$的约数，那么$x$也是$(a + mb)$的约数，$a$ % $b$ = $a - mb$。所以$x$也是$a$ % $b$的约数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归版本    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b != <span class="number">0</span> ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp % b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="约数个数与约数之和的计算公式"><a href="#约数个数与约数之和的计算公式" class="headerlink" title="约数个数与约数之和的计算公式"></a>约数个数与约数之和的计算公式</h2><p>假设一个数$N$可以被分解成$N = p_1^{c1}<em>p_2^{c2}</em>p_3^{c3}…p_k^{ck},$其中$p_i$是一个质因子，$ci$为$pi$的质数。</p>
<ol>
<li><strong>约数的个数=</strong>$(c1 + 1)(c2 + 1)…(ck + 1)$</li>
<li><strong>约数之和=</strong>$(p_1^0 + p_1^1 + …+p1^{c1})…(p_k^0+p_k^1 +…+p_k^{ck})$</li>
</ol>
<hr>
<h2 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h2><p><strong>使用场景：求一个数$a$的$k$次幂mod$p$的结果</strong></p>
<p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201128/at4-1.png" alt></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">qmi</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">int</span> k, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k != <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//表示k的二进制表示的某一位是否是1</span></span><br><span class="line">        <span class="keyword">if</span>((k &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            res = res * a % p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//a表示的是如果k的下一位为1的数</span></span><br><span class="line">        a = a * a % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法模板</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>质数</tag>
        <tag>约数</tag>
        <tag>欧拉函数</tag>
        <tag>快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析Android的RecyclerView中使用的适配器模式</title>
    <url>/2020/11/29/Android-2/</url>
    <content><![CDATA[<h2 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h2><p><strong>通俗一点说就是使用一个包装类，让原本不能兼容的两个接口能够一起工作，这就是适配器模式的基本原理。</strong></p>
<h3 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h3><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><h2 id="看一看RecyclerView平常都是如何使用的"><a href="#看一看RecyclerView平常都是如何使用的" class="headerlink" title="看一看RecyclerView平常都是如何使用的"></a>看一看RecyclerView平常都是如何使用的</h2><h2 id="RecyclerView中的Adapter分析"><a href="#RecyclerView中的Adapter分析" class="headerlink" title="RecyclerView中的Adapter分析"></a>RecyclerView中的Adapter分析</h2>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Android</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
