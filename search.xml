<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>软件测试复习笔记-Testing Management</title>
      <link href="2020/10/22/software-testing-notes-8/"/>
      <url>2020/10/22/software-testing-notes-8/</url>
      
        <content type="html"><![CDATA[<h1 id="Software-QA-and-Test-Management"><a href="#Software-QA-and-Test-Management" class="headerlink" title="Software QA and Test Management"></a>Software QA and Test Management</h1><h2 id="Why-do-we-test-software"><a href="#Why-do-we-test-software" class="headerlink" title="Why do we test software ?"></a>Why do we test software ?</h2><ul><li>The purpose is to find errors</li><li>To have confidence that the system meets its requirements</li><li>To produce a high-quality product</li><li>• To reduce (minimize) the risk that we fail to achieve the above</li></ul><h2 id="Quality-Assurance-Quality-Control"><a href="#Quality-Assurance-Quality-Control" class="headerlink" title="Quality Assurance, Quality Control"></a>Quality Assurance, Quality Control</h2><h3 id="Manage-the-process-QA"><a href="#Manage-the-process-QA" class="headerlink" title="Manage the process (QA)"></a>Manage the process (QA)</h3><ul><li>For example, detailed quality audit that checks if the specified processes are being followed</li><li>Focus on the process and not the product</li><li>Aiming to prevent issues</li></ul><h3 id="Manage-the-product-QC"><a href="#Manage-the-product-QC" class="headerlink" title="Manage the product (QC)"></a>Manage the product (QC)</h3><ul><li>For example, testing and code reviews</li><li>Focus on product, identifying deficiencies and suggesting improvements</li><li>Aiming to detect issues</li></ul><h2 id="The-benefits-of-standards"><a href="#The-benefits-of-standards" class="headerlink" title="The benefits of standards"></a>The benefits of standards</h2><ul><li>Standards capture wisdom that is of value to the organization</li><li>Standards provide a framework for defining what quality means in a particular setting</li><li>Standards assist continuity when work carried out by one person is taken up and continued by another</li></ul><h2 id="Test-Metrics"><a href="#Test-Metrics" class="headerlink" title="Test Metrics"></a>Test Metrics</h2><blockquote><ol><li>Measure the progress of testing in an organization and on projects </li><li>Help to understand issues about project progress and testing </li><li>Testability – how easy is it to specify and perform tests</li></ol></blockquote><h3 id="Good-use-of-test-metrics"><a href="#Good-use-of-test-metrics" class="headerlink" title="Good use of test metrics"></a>Good use of test metrics</h3><ul><li>Early detection of issues</li><li>Setting goals</li></ul><h2 id="Test-Planning-and-Test-case-Recording"><a href="#Test-Planning-and-Test-case-Recording" class="headerlink" title="Test Planning and Test case Recording"></a>Test Planning and Test case Recording</h2>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习笔记-Performance Testing</title>
      <link href="2020/10/22/software-testing-notes-7/"/>
      <url>2020/10/22/software-testing-notes-7/</url>
      
        <content type="html"><![CDATA[<h1 id="A-type-of-system-testing-—-performance-testing"><a href="#A-type-of-system-testing-—-performance-testing" class="headerlink" title="A type of system testing — performance testing"></a>A type of system testing — performance testing</h1><h2 id="Where-does-performance-testing-fit"><a href="#Where-does-performance-testing-fit" class="headerlink" title="Where does performance testing fit ?"></a>Where does performance testing fit ?</h2><ul><li>Functional - for detail requirements or use cases</li><li><strong>Non-functional</strong> - the performance will be affected if there are larger amounts of data</li></ul><h2 id="Smart-test"><a href="#Smart-test" class="headerlink" title="Smart test"></a>Smart test</h2><ul><li>Specific</li><li>Measurable</li><li>Achievable</li><li>Relevant</li><li>Time-based</li></ul><h2 id="When-do-performance-testing"><a href="#When-do-performance-testing" class="headerlink" title="When do performance testing ?"></a>When do performance testing ?</h2><blockquote><p>Later in the development life-cycle(when there is a system test)</p></blockquote><h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><ul><li><strong>stable code base</strong> (The code will not change so the performance testing is meaningful)</li><li>Code should have been <strong>tested</strong>(not easily identify a bug or performance issues)</li></ul><h2 id="Key-Performance-Targets"><a href="#Key-Performance-Targets" class="headerlink" title="Key Performance Targets"></a>Key Performance Targets</h2><ul><li>Available or uptime </li><li>Concurrency</li><li>Response time</li><li>Computer usage (CPU, Memory, File I/O Disk )</li><li>Network usage (Data Volume / Throughput)</li></ul><h2 id="Example-types-of-performance-testing"><a href="#Example-types-of-performance-testing" class="headerlink" title="Example types of performance testing"></a>Example types of performance testing</h2><ul><li><strong>Pipe clean tests</strong>(validate different performances)</li><li><strong>Volume tests</strong>(expected loads)</li><li><strong>Stress tests</strong>(what will happen if the application is given more work to do)</li><li><strong>Soak / Stability</strong>(extended use tests)</li><li><strong>Smoke tests</strong>(focus on the area of change)</li><li><strong>Isolation</strong>(focus on specific areas)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习笔记-System Testing</title>
      <link href="2020/10/22/software-testing-notes-6/"/>
      <url>2020/10/22/software-testing-notes-6/</url>
      
        <content type="html"><![CDATA[<h2 id="Some-concepts-of-System-testing"><a href="#Some-concepts-of-System-testing" class="headerlink" title="Some concepts of System testing"></a>Some concepts of System testing</h2><ul><li><p>System testing is testing conducted on a complete, integrated system to evaluate the system’s compliance with its requirements specifications.</p></li><li><p>System testing falls within(属于) the scope of black box testing, and as such, should require no knowledge of the inner design of the code or logic.</p></li></ul><h2 id="Why-system-testing-is-necessary"><a href="#Why-system-testing-is-necessary" class="headerlink" title="Why system testing is necessary?"></a>Why system testing is necessary?</h2><ul><li>Some properties only verifiable at system level( Installation, usability, compatibility )</li><li>We may involve users at this level</li><li>The environment of system is taken to account</li></ul><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201022/notes-6-1.png" alt="system testing"></p><h2 id="System-testing-methods"><a href="#System-testing-methods" class="headerlink" title="System testing methods"></a>System testing methods</h2><h3 id="System-functionality-testing"><a href="#System-functionality-testing" class="headerlink" title="System functionality testing"></a>System functionality testing</h3><ul><li>Automate tests where possible</li><li>Create test scripts for other areas where a user will perform manual testing</li></ul><h3 id="GUI-Testing"><a href="#GUI-Testing" class="headerlink" title="GUI Testing"></a>GUI Testing</h3><blockquote><p>The diffculties of GUI software testing:</p></blockquote><ul><li>Possible interface test space is massive</li><li>Event-driven characteristics</li><li>Bad design mixes the interface with the ‘logic’ of the application. This can be harder to test</li></ul><h3 id="Usability-Testing-and-Accessibility-Testing"><a href="#Usability-Testing-and-Accessibility-Testing" class="headerlink" title="Usability Testing and Accessibility Testing"></a>Usability Testing and Accessibility Testing</h3><h3 id="Performance-Testing"><a href="#Performance-Testing" class="headerlink" title="Performance Testing"></a>Performance Testing</h3><ul><li>Performance testing is used to determine the speed or effectiveness of a computer, network, software program or device</li><li>Goals: eliminate bottlenecks and improve system reliability</li></ul><h3 id="Compatibility-Testing"><a href="#Compatibility-Testing" class="headerlink" title="Compatibility Testing"></a>Compatibility Testing</h3><ul><li>Compatibility testing is part of software non-functional tests</li><li>Conducted on the application to evaluate the application’s compatibility with the computing environment</li></ul><h3 id="Recovery-Testing"><a href="#Recovery-Testing" class="headerlink" title="Recovery Testing"></a>Recovery Testing</h3><h3 id="Installation-Testing"><a href="#Installation-Testing" class="headerlink" title="Installation Testing"></a>Installation Testing</h3>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉搜索树的创建以及遍历方式（Java实现）</title>
      <link href="2020/10/18/algorithm-3/"/>
      <url>2020/10/18/algorithm-3/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉搜索树是什么？"><a href="#二叉搜索树是什么？" class="headerlink" title="二叉搜索树是什么？"></a>二叉搜索树是什么？</h2><p><strong>通俗一点说就是，对于一颗二叉树所有的非叶子节点，满足它的左儿子节点（如果有的话）一定小于它，它的右儿子节点（如果有的话）一定大于它。</strong></p><h2 id="二叉树搜索树的创建"><a href="#二叉树搜索树的创建" class="headerlink" title="二叉树搜索树的创建"></a>二叉树搜索树的创建</h2><h3 id="二叉树的结构"><a href="#二叉树的结构" class="headerlink" title="二叉树的结构"></a>二叉树的结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义一个根节点</span></span><br><span class="line">    TreeNode root;</span><br><span class="line">    <span class="comment">//定义树的结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode leftChild;</span><br><span class="line">        TreeNode rightChild;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意一下，如果建立了一个BinarySearchTree的测试类，我们要在外部初始化一个TreeNode对象需要如何做呢？</p><blockquote><p>1.假如该内部类是常规的内部类，那么这个类的对象就是属于它外部那个类的对象的，因此如果我们想要实例化内部类的话，就需要先创建一个外部类的对象，再通过外部类的对象来初始化内部类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchTree.TreeNode node = <span class="keyword">new</span> BinarySearchTree().<span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><blockquote><p>2.假如该内部类是静态内部类，那么这个内部类的对象显然就是属于外部类的了，可以不用实例化外部类了，代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinarySearchTree.TreeNode node = <span class="keyword">new</span> BinarySearchTree.<span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="二叉树的插入"><a href="#二叉树的插入" class="headerlink" title="二叉树的插入"></a>二叉树的插入</h3><p>依次插入：45、32、64、14、40、50、80</p></blockquote><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-1.jpg" alt="二叉搜索树插入图解"></p><blockquote><p>从图解中我们不难发现，二叉树的插入的思想就是从根节点开始往下找，直到找到一个叶子节点，满足这个点只比这个叶子节点大或者小，直接把该点插入到该叶子节点的左儿子或者右儿子节点，那么代码就可以写成：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义树的迭代器</span></span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//如果值小于node</span></span><br><span class="line">        <span class="keyword">if</span>(value &lt; node.val)&#123;</span><br><span class="line">            <span class="comment">//如果node的左儿子节点存在，就继续循环</span></span><br><span class="line">            <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)</span><br><span class="line">                node = node.leftChild;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//说明该点已经是叶子节点，可以插入了</span></span><br><span class="line">                TreeNode newNode = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                node.leftChild = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//如果node的右儿子节点存在，就继续循环</span></span><br><span class="line">            <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)</span><br><span class="line">                node = node.rightChild;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TreeNode newNode = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">                node.rightChild = newNode;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>开始之前：前序、中序和后序遍历都是相对于根节点而言的。即前序遍历是先遍历根节点、再遍历左子树、再遍历右子树；中序遍历是先遍历左子树、再遍历根节点、再遍历右子树；后序遍历是先遍历左子树、再遍历右子树、再遍历根节点。算法题中后序遍历用得相对较多。</p></blockquote><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-2.jpg" alt="二叉搜索树的前序遍历图解"></p><ul><li>看完图解可以很快想出一种递归的写法，就是每次递归的搜索左子树时，先打印一下:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.print(root.val + <span class="string">" "</span>);</span><br><span class="line">    preOrder(root.leftChild);</span><br><span class="line">    preOrder(root.rightChild);</span><br><span class="line">&#125;</span><br><span class="line">&gt; <span class="number">45</span> <span class="number">32</span> <span class="number">14</span> <span class="number">40</span> <span class="number">64</span> <span class="number">50</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-3.jpg" alt="二叉搜索树前序遍历栈模拟"></p><blockquote><p>非递归思路：就是用一个栈来存储节点，每次抛出栈顶元素，并将栈顶元素的右儿子和左儿子依次加入栈中，直到栈为空。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        <span class="comment">//打印值</span></span><br><span class="line">        System.out.print(node.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.rightChild);</span><br><span class="line">        <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.leftChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-4.jpg" alt="二叉搜索树的中序遍历图解"></p><blockquote><p>从图解中我们可以发现，如果要用递归来实现的话，我们需要先用dfs穷尽左子树，然后再回溯到根节点，再回溯到右子树。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.leftChild);</span><br><span class="line">    Systemn.out.print(root.val + <span class="string">" "</span>);</span><br><span class="line">    inOrder(root.rightChild);</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">14</span> <span class="number">32</span> <span class="number">40</span> <span class="number">45</span> <span class="number">50</span> <span class="number">64</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><blockquote><p>用栈实现的非递归做法就不能像前序遍历那种实现了，因为我们需要用到左子树。那么我们就可以利用递归的思路，先穷尽左子树，再将栈顶弹出，再回溯右子树。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//node是穷尽左子树的指针</span></span><br><span class="line">    TreeNode node = root;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || node != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            <span class="comment">//穷尽左子树</span></span><br><span class="line">            node = node.leftChild;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//执行到这里说明左子树已经被穷尽了，我们就需要弹出栈顶元素，回溯根节点和右子树</span></span><br><span class="line">            TreeNode top = stack.pop();</span><br><span class="line">            <span class="comment">//打印结果</span></span><br><span class="line">            System.out.print(top.val + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">//回溯右子树</span></span><br><span class="line">            node = top.rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201018/at3-5.jpg" alt="二叉搜索树后序遍历图解"></p><blockquote><p>后序遍历其实就是先穷尽左子树，再穷尽右子树，最后将结果打印再回溯！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.leftChild);</span><br><span class="line">    postOrder(root.rightChild);</span><br><span class="line">    System.out.print(root.val + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">14</span> <span class="number">40</span> <span class="number">32</span> <span class="number">50</span> <span class="number">80</span> <span class="number">64</span> <span class="number">45</span></span><br></pre></td></tr></table></figure><blockquote><p>在前序遍历中我们使用了栈先存储右子节点，再存储左子节点的方式来实现递归的模拟。其实如果我们将栈顶元素抛出，再加入栈顶元素的左儿子和右儿子，会有什么状况发生呢？</p><p>遍历的顺序就会变为：根节点-&gt;右子树-&gt;左子树</p><p>如果将结果逆序我们会发现：左子树-&gt;右子树-&gt;根节点，正好是后序遍历！所以我们只需要用一个辅助栈来存储每次弹出的栈顶元素即可！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; favor = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        TreeNode node = stack.pop();</span><br><span class="line">        favor.push(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.leftChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.leftChild);</span><br><span class="line">        <span class="keyword">if</span>(node.rightChild != <span class="keyword">null</span>)</span><br><span class="line">            stack.push(node.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印辅助栈即可</span></span><br><span class="line">    <span class="keyword">while</span>(!favor.isEmpty())</span><br><span class="line">        System.out.print(favor.pop() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><blockquote><p>层序遍历较上面三种排序就更好理解，就是从左到右一次打印每一层的节点，只需要一个队列来模拟广度优先搜索即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode top = queue.poll();</span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        System.out.print(top.val + <span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(top.leftChild != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(top.leftChild);</span><br><span class="line">        <span class="keyword">if</span>(top.rightChild != <span class="keyword">null</span>)</span><br><span class="line">            queue.offer(top.rightChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&gt;<span class="number">45</span> <span class="number">32</span> <span class="number">64</span> <span class="number">14</span> <span class="number">40</span> <span class="number">50</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>有关二叉搜索树的难点主要在于后序遍历的非递归写法怎么建模更简单，同时要深入理解递归和回溯的顺序才行，不能知其然而不知其所以然。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构常用模板</title>
      <link href="2020/10/16/algroithmTemplate-2/"/>
      <url>2020/10/16/algroithmTemplate-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本篇文章总结自AcWing算法基础课学习模板，主要有链表、栈、队列、单调栈、单调队列、KMP、字典树、并查集、堆、哈希散列的实现。</p></blockquote><h2 id="单链表（数组实现）"><a href="#单链表（数组实现）" class="headerlink" title="单链表（数组实现）"></a>单链表（数组实现）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head; <span class="comment">//链表的头指针</span></span><br><span class="line"><span class="keyword">int</span> idx; <span class="comment">//记录当前用到了数组的第几个下标</span></span><br><span class="line"><span class="comment">//假设N是一个很大的常数</span></span><br><span class="line"><span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的值</span></span><br><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的next指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = -<span class="number">1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往链表头部插入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    next[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表的头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = next[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双链表（数组实现）"><a href="#双链表（数组实现）" class="headerlink" title="双链表（数组实现）"></a>双链表（数组实现）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> head;</span><br><span class="line"><span class="keyword">int</span> idx;</span><br><span class="line"><span class="keyword">int</span>[] value = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的左指针</span></span><br><span class="line"><span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//存储链表节点的右指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">    left[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//0表示右端点</span></span><br><span class="line">    right[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//1表示左端点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在某个节点的右侧插入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    right[idx] = right[a];</span><br><span class="line">    left[idx] = a;</span><br><span class="line">    left[right[a]] = idx;</span><br><span class="line">    right[a] = idx;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除某个节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    right[left[a]] = right[a];</span><br><span class="line">    left[right[a]] = left[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈（数组实现）"><a href="#栈（数组实现）" class="headerlink" title="栈（数组实现）"></a>栈（数组实现）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>; <span class="comment">//栈顶指针</span></span><br><span class="line"><span class="keyword">int</span>[] stk = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//使用数组存储栈的元素</span></span><br><span class="line">stk[++tt] = x; <span class="comment">//往栈中push一个元素</span></span><br><span class="line">tt--; <span class="comment">//从栈中pop一个元素</span></span><br><span class="line">stk[tt]; <span class="comment">//栈顶的元素</span></span><br><span class="line">tt &gt; <span class="number">0</span>; <span class="comment">//判断栈顶的值是否为空</span></span><br></pre></td></tr></table></figure><h2 id="队列（数组实现）"><a href="#队列（数组实现）" class="headerlink" title="队列（数组实现）"></a>队列（数组实现）</h2><h3 id="普通队列（双端队列）"><a href="#普通队列（双端队列）" class="headerlink" title="普通队列（双端队列）"></a>普通队列（双端队列）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>; <span class="comment">//队首指针</span></span><br><span class="line"><span class="keyword">int</span> tt = -<span class="number">1</span>; <span class="comment">//队尾指针</span></span><br><span class="line"><span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N]； <span class="comment">//用于存放队列中的元素</span></span><br><span class="line">q[++tt] = x; <span class="comment">//往队列中offer一个元素</span></span><br><span class="line">hh++; <span class="comment">//从队列中poll一个元素</span></span><br><span class="line">q[hh]; <span class="comment">//队首元素</span></span><br><span class="line">hh &lt;= tt; <span class="comment">//判断队列是否为空</span></span><br></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由于用数组实现队列，经过多次插入和弹出之后，队列走到了数组的末端，但是数组的前半部分仍然有剩余</span></span><br><span class="line"><span class="comment">//所以可以用循环队列，来保证在大部分情况下，可以存储较多的元素</span></span><br><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//循环队列最多存N-1个元素</span></span><br><span class="line">q[tt++] = x; <span class="comment">//往队尾插入一个元素</span></span><br><span class="line"><span class="comment">//从队首弹出一个元素</span></span><br><span class="line">hh ++;</span><br><span class="line"><span class="keyword">if</span>(hh==N) hh = <span class="number">0</span>;</span><br><span class="line">q[hh]; <span class="comment">//队首元素</span></span><br><span class="line">hh != tt <span class="comment">//判断队列是否为空</span></span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><blockquote><p>常见题型：找出每个数左边离他最近比他大（或小）的数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tt = <span class="number">0</span>; <span class="keyword">int</span>[] stk = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>...&#125; <span class="comment">//假定a为输入数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(tt &gt; <span class="number">0</span> &amp;&amp; check(stk[tt], a[i])) tt--;</span><br><span class="line">    stk[++tt] = a[i];</span><br><span class="line">    <span class="comment">//具体逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><blockquote><p>经典题型：滑动窗口的最大值/最小值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hh = <span class="number">0</span>; <span class="keyword">int</span> tt = -<span class="number">1</span>; <span class="keyword">int</span>[] q = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">8</span>...&#125; <span class="comment">//假定a数组为输入数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//checkOut函数判断队首是否在窗口外</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; checkOut()) hh++;</span><br><span class="line">    <span class="comment">//check函数为具体算法的判断函数</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; check(q[tt], a[i])) tt--;</span><br><span class="line">    q[++tt] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP字符串匹配"><a href="#KMP字符串匹配" class="headerlink" title="KMP字符串匹配"></a>KMP字符串匹配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] s = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>]; <span class="comment">//长文本（下标从1开始）</span></span><br><span class="line"><span class="keyword">char</span>[] p = <span class="keyword">new</span> <span class="keyword">char</span>[m+<span class="number">1</span>]; <span class="comment">//模式串（下标从1开始）</span></span><br><span class="line"><span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m+<span class="number">1</span>]; <span class="comment">//模式串的next数组</span></span><br><span class="line"><span class="comment">//求next数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果前缀和后缀字符串不匹配，就向前看一步</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(p[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//更新next数组</span></span><br><span class="line">    next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//匹配过程</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//和构建next数组的过程类似</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != p[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line">    <span class="keyword">if</span>(s[i] == p[j+<span class="number">1</span>]) j++;</span><br><span class="line">    <span class="comment">//找到了之后</span></span><br><span class="line">    <span class="keyword">if</span>(j==m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//匹配成功的具体逻辑</span></span><br><span class="line">        System.out.println(i);</span><br><span class="line">        j = next[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trie树（字典树）"><a href="#Trie树（字典树）" class="headerlink" title="Trie树（字典树）"></a>Trie树（字典树）</h2><blockquote><p>常见题型：给一个字符串数组，问某个字符串出现的次数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] son = <span class="keyword">new</span> <span class="keyword">int</span>[N][<span class="number">26</span>]; <span class="comment">//假设字符串是26个小写字母,son存放每个节点的子节点</span></span><br><span class="line"><span class="comment">//下标为0的点是根节点</span></span><br><span class="line"><span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[N]; <span class="comment">//记录以某个下标结尾的字符串出现的次数</span></span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>; <span class="comment">//记录当前用到了数组的哪一个下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>; <span class="comment">//根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//如果这个字母之前没有出现</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>) son[p][u] = idx++;</span><br><span class="line">        <span class="comment">//重新定位根节点</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//记录该字符串出现的次数</span></span><br><span class="line">    count[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个字符串出现的次数（和插入有些类似）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;str.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="comment">//如果当前字母没有出现过，说明该字符串不在该数组中，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span>(son[p][u] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//重新定位根节点</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><blockquote><p>有两个集合，想要查看数a,b是否在同一个集合中，想要合并两个集合，如果在题目中出现这样的情况，想一想这个问题能否用并查集来解决！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>)朴素并查集：</span><br><span class="line"><span class="comment">//p数组存放的每个节点的祖宗节点</span></span><br><span class="line"><span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集的核心，find函数，返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//路径压缩</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集，假设节点的编号为1~n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=nl i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将集合a合并到集合b中去</span></span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"><span class="comment">//size数组存放的每个节点所在的集合的大小，注意只有祖宗节点的size才有意义</span></span><br><span class="line"><span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N], size = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化并查集和size数组，假设节点的编号为1~n</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    size[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//首先判断a,b是否在同一个集合中</span></span><br><span class="line"><span class="keyword">if</span>(find(a) != find(b))</span><br><span class="line">&#123;</span><br><span class="line">    size[find(b)] += size[find(a)];</span><br><span class="line">    p[find(a)] = find(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>)维护到祖宗节点距离的并查集</span><br><span class="line"><span class="comment">//d[x]存储x到p[x]的距离</span></span><br><span class="line"><span class="keyword">int</span>[] p = <span class="keyword">new</span> <span class="keyword">int</span>[N], d = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//find函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = find(p[x]);</span><br><span class="line">        <span class="comment">//由于p[x]都要指向祖宗节点，所以要更新d[x]</span></span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将a集合合并到b集合中</span></span><br><span class="line">p[find(a)] = find(b);</span><br><span class="line"><span class="comment">//根据具体问题计算distance</span></span><br><span class="line">d[find(a)] = distance;</span><br></pre></td></tr></table></figure><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h存储堆中的值，h[1]为堆顶，x的左儿子是2x，x的右儿子是2x+1</span></span><br><span class="line"><span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">//hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="keyword">int</span>[] ph = <span class="keyword">new</span> <span class="keyword">int</span>[N], hp = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="comment">//表示堆的大小</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个节点的值及其映射关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//交换ph映射</span></span><br><span class="line">    <span class="keyword">int</span> tempIndex = ph[hp[a]];</span><br><span class="line">    ph[hp[a]] = ph[hp[b]];</span><br><span class="line">    ph[hp[b]] = tempOrder;</span><br><span class="line">    <span class="comment">//交换hp映射</span></span><br><span class="line">    <span class="keyword">int</span> tempK = hp[a];</span><br><span class="line">    hp[a] = hp[b];</span><br><span class="line">    hp[b] = tempK;</span><br><span class="line">    <span class="comment">//交换值</span></span><br><span class="line">    <span class="keyword">int</span> temp = h[a];</span><br><span class="line">    h[a] = h[b];</span><br><span class="line">    h[b] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tempIndex = index;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*index &lt;= size &amp;&amp; h[<span class="number">2</span>*index] &lt; h[tempIndex]) tempIndex = <span class="number">2</span>*index;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span>*index+<span class="number">1</span> &lt;= size &amp;&amp; h[<span class="number">2</span>*index+<span class="number">1</span>] &lt; h[tempIndex]) tempIndex = <span class="number">2</span>*index+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//如果儿子节点比节点小则互换</span></span><br><span class="line">    <span class="keyword">if</span>(tempIndex != index)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(index, tempIndex);</span><br><span class="line">        <span class="comment">//递归下沉</span></span><br><span class="line">        down(tempIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="comment">//节点上浮的条件</span></span><br><span class="line">    <span class="keyword">while</span>(index/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; h[index] &lt; h[index/<span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        swap(index, index/<span class="number">2</span>);</span><br><span class="line">        index &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一般哈希"><a href="#一般哈希" class="headerlink" title="一般哈希"></a>一般哈希</h2><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//h数组中所有的初始值为-1</span></span><br><span class="line"><span class="keyword">int</span>[] h = <span class="keyword">new</span> <span class="keyword">int</span>[N], value = <span class="keyword">new</span> <span class="keyword">int</span>[N], next = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向哈希表中插入一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//哈希函数</span></span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    next[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在哈希表中查找某个数是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=h[k]; i!=-<span class="number">1</span>; i=next[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(value[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> h = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果x在哈希表中，则返回x的下标，如果不在则返回x应该插入的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x%N+N)%N;</span><br><span class="line">    <span class="keyword">while</span>(h[k] != <span class="keyword">null</span> &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">        <span class="keyword">if</span>( k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h2><p><strong>核心思想：将字符串看成P进制的数，P的经验值是131或1331，取这两个值的冲突概率较低</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span>[] h = <span class="keyword">new</span> <span class="keyword">long</span>[N]; <span class="comment">//h[k]存储字符串前k个字母的哈希值</span></span><br><span class="line"><span class="keyword">long</span>[] p = <span class="keyword">new</span> <span class="keyword">long</span>[N]; <span class="comment">//p[k]存储P^k mod 2^64(Java中会溢出成负数，暂时不考虑字符串很长的情况)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i-<span class="number">1</span>]*P + str[i]; <span class="comment">//暂时不考虑取模的情况</span></span><br><span class="line">    p[i] = pp[i-<span class="number">1</span>]*P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算字串str[l~r]的哈希值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l-<span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 堆 </tag>
            
            <tag> 哈希散列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习笔记-Integration Testing</title>
      <link href="2020/10/15/software-testing-notes-5/"/>
      <url>2020/10/15/software-testing-notes-5/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Integration-Testing"><a href="#What-is-Integration-Testing" class="headerlink" title="What is Integration Testing"></a>What is Integration Testing</h2><ul><li><strong>Integration testing</strong> is the phase of software testing in which individual software modules are combined and tested as a group.</li><li>When should this happen?<ul><li>Integration testing follows unit testing and precedes system testing.</li></ul></li></ul><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201015/notes-5-1.png" alt="V-model"></p><h2 id="Integration-Testing-Cycle"><a href="#Integration-Testing-Cycle" class="headerlink" title="Integration Testing Cycle"></a>Integration Testing Cycle</h2><ul><li>Integration is conducted incrementally as a series of test cycles</li><li>Additional modules are integrated in each cycle</li><li>Continues until all modules are integrated</li></ul><h2 id="Integration-Testing-Strategy"><a href="#Integration-Testing-Strategy" class="headerlink" title="Integration Testing Strategy"></a>Integration Testing Strategy</h2><ul><li>Big Bang</li><li>Top-Down</li><li>Bottom-Up</li></ul><h3 id="Big-bang-Integration"><a href="#Big-bang-Integration" class="headerlink" title="Big-bang Integration"></a>Big-bang Integration</h3><ul><li>Link all of the modules together as a system</li><li>Limited need for test doubles and drivers</li><li>Difficult to isolate errors and identify where the problem occurs</li><li>Do not verify the interfaces across the module boundaries</li><li>Risk of late identification of problems</li></ul><h3 id="Top-down-Integration"><a href="#Top-down-Integration" class="headerlink" title="Top-down Integration"></a>Top-down Integration</h3><ul><li>As the system is constructed, test the interactions of modules from the ‘top’ down to the lower level modules</li><li>‘top’ is the module that calls other modules</li><li>Breadth-first and Depth-first approaches</li><li>Test doubles can be used for some tests</li></ul><h3 id="Bottom-up-Inegration"><a href="#Bottom-up-Inegration" class="headerlink" title="Bottom-up Inegration"></a>Bottom-up Inegration</h3><ul><li>Start with bottom-level components, which have no, or minimal, dependencies</li><li>Move up through connectons, verifying the interactions of modules</li><li>Driver modules used to test the integrated modules</li><li>It is likely that there is less need for Test Doubles because the lower levels will already exist(But, we maybe use test doubles for other reasons)</li></ul><h2 id="How-often-should-we-run-integration-tests"><a href="#How-often-should-we-run-integration-tests" class="headerlink" title="How often  should we run integration tests?"></a>How often  should we run integration tests?</h2><ul><li>Regular integration<ul><li>Daily</li><li>In an iteration (e.g. two weeks)</li></ul></li><li>Automated tests</li><li>A popular modern approach is to run a set of tests regularly as code is checked in<ul><li>idea of Continuous Integration (CI)</li></ul></li></ul><blockquote><p>Focus is on data that will be passed through the interface to other module</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做算法题中常用的Java的Collections API</title>
      <link href="2020/10/15/algorithm-2/"/>
      <url>2020/10/15/algorithm-2/</url>
      
        <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote><p>Java中的ArrayList本质上就是一个动态数组，当你写如下代码时：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(); <span class="comment">//ArrayList此时的默认容量为10</span></span><br><span class="line">ArrayList&lt;Integer&gt; arr1 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(<span class="number">5</span>); <span class="comment">//ArrayList的容量为5</span></span><br><span class="line"><span class="comment">//当已经经过了很多次插入和删除操作，此时你写了如下代码</span></span><br><span class="line">arr.add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//ArrayList会先去判断插入当前元素是否会超过当前数组大小;</span></span><br><span class="line"><span class="comment">//如果超过了，就将自身的容量扩容成当前的150%，(扩容的过程中会将当前数组的所有元素移动到扩容后的数组中去，这个操作十分耗时！)</span></span><br><span class="line">arr.add(<span class="number">10</span>,<span class="number">5</span>); <span class="comment">//在下标是10的位置插入5;</span></span><br><span class="line"><span class="comment">//ArrayList先判断下标是否合法，再看是否需要扩容；</span></span><br><span class="line"><span class="comment">//将[index, currentSize-1]的元素复制到[index+1, currentSize]中，即index后的所有元素整体后移，这个操作也十分耗时！)</span></span><br><span class="line"><span class="comment">//再将值赋给arr[index]</span></span><br></pre></td></tr></table></figure><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201015/a-2.png" alt="ArrayList扩容源码"></p><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201015/a-2.png" alt="ArrayList.add(int index, E element)"></p><blockquote><p>E remove(int index) 和 boolean remove(Object O)和ArrayList中的add源码类似，ArrayList会将要删除元素下标index后面的元素整体往前移动1步，操作十分耗时！</p></blockquote><h3 id="什么情况下使用ArrayList"><a href="#什么情况下使用ArrayList" class="headerlink" title="什么情况下使用ArrayList"></a>什么情况下使用ArrayList</h3><ul><li>根据以上分析，当算法题涉及到的删除和插入操作不多，且要多次随机访问某给节点时，可以使用</li><li>ArrayList的优势就是随机访问某个节点的时间复杂度是O(1)</li></ul><h3 id="ArrayList的常用方法"><a href="#ArrayList的常用方法" class="headerlink" title="ArrayList的常用方法"></a>ArrayList的常用方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; demo1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">demo1.add(<span class="number">1</span>); <span class="comment">// 1. 添加一个元素</span></span><br><span class="line">ArrayList&lt;Integer&gt; demo1 = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">new</span> HashSet&lt;&gt;()); <span class="comment">// 2. 将其他Collections转换成一个ArrayList</span></span><br><span class="line">demo1.remove(<span class="number">0</span>); <span class="comment">// 3. 删除某个下标的元素，e.g. 删除下标为0的元素</span></span><br><span class="line">demo1.size(); <span class="comment">// 4. 返回当前ArrayList的长度</span></span><br><span class="line">demo1.clear(); <span class="comment">// 5.  清空ArrayList中的所有元素</span></span><br><span class="line">Collections.sort(demo1); <span class="comment">// 6. 将数组升序排序</span></span><br></pre></td></tr></table></figure><h3 id="ArrayList的遍历方式"><a href="#ArrayList的遍历方式" class="headerlink" title="ArrayList的遍历方式"></a>ArrayList的遍历方式</h3><ul><li>普通for循环</li><li>增强for循环</li><li>迭代器iterator循环</li></ul><blockquote><p>顺序删除ArrayList中所有元素的两种方式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList(<span class="number">10</span>);<span class="comment">//假设array中已经存在10个元素</span></span><br><span class="line"><span class="comment">//普通for循环，从后往前删除(结合remove源码的特点)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = array.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">    array.remove(i);</span><br><span class="line"><span class="comment">//迭代器删除，只能调用迭代器的remove方法，用ArrayList中的remove方法会抛异常</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = array.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    iterator.next();</span><br><span class="line">    iterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将一个List转换成一个数组的两种方式，以整型Integer为例，假设已经有个变量名为list的ArrayList</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.就是直接开辟一个新的数组，通过遍历取值的方式来转换</span></span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    arr[i] = list.get(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.使用stream流的方式直接一行代码搞定</span></span><br><span class="line"><span class="keyword">int</span>[] arr = list.stream().mapToInt(number -&gt; number.intValue()).toArray();</span><br></pre></td></tr></table></figure><ul><li>方法一的代码执行速度要比方法二更快，因为方法二stream流操作需要额外的时间更多。</li></ul><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><blockquote><p>LinkedList和ArrayList的使用场景恰好相反，LinkedList是链表，所以删除和插入操作的时间复杂度是O(1)，但是查找的时间复杂度却是O(n)。LinkedList同时还实现了Deque(双端队列)和Queue(队列)，所以LinkedList实际上是一个双向链表</p></blockquote><h3 id="作为链表使用"><a href="#作为链表使用" class="headerlink" title="作为链表使用"></a>作为链表使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">5</span>); <span class="comment">// 1.插入一个元素</span></span><br><span class="line">list.addFirst(<span class="number">3</span>); <span class="comment">// 2.在链表头部插入一个元素</span></span><br><span class="line">list.addLast(<span class="number">4</span>); <span class="comment">// 3.在链表的尾部插入一个元素</span></span><br></pre></td></tr></table></figure><h3 id="作为队列-Queue-使用"><a href="#作为队列-Queue-使用" class="headerlink" title="作为队列(Queue)使用"></a>作为队列(Queue)使用</h3><blockquote><p>队列特点：先进先出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">queue.offer(<span class="number">1</span>); <span class="comment">// 1.从队尾插入一个元素</span></span><br><span class="line">queue.poll(); <span class="comment">// 2.返回并从队首弹出一个元素</span></span><br><span class="line">queue.peek(); <span class="comment">// 3.返回队首元素</span></span><br><span class="line">queue.isEmpty(); <span class="comment">// 4.判断队列是否为空</span></span><br><span class="line">queue.size(); <span class="comment">// 5.返回队列元素的个数</span></span><br></pre></td></tr></table></figure><blockquote><p>补充：使用数组队列ArrayDeque的速度要比LinkedList快！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;Deque&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="作为双端队列-Deque-使用"><a href="#作为双端队列-Deque-使用" class="headerlink" title="作为双端队列(Deque)使用"></a>作为双端队列(Deque)使用</h3><p>双端队列特点：队首和队尾均可插入和弹出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">deque.offer(<span class="number">1</span>); <span class="comment">// 1.从队尾插入一个元素 &gt;&gt; 1</span></span><br><span class="line">deque.offerFirst(<span class="number">2</span>); <span class="comment">//2.从队首插入一个元素 &gt;&gt; 2 1</span></span><br><span class="line">deque.offerLast(<span class="number">3</span>); <span class="comment">//3.从队尾插入一个元素 &gt;&gt; 2 1 3</span></span><br><span class="line">deque.peekFirst(); <span class="comment">//4.返回队首元素</span></span><br><span class="line">deque.peekLast(); <span class="comment">//5.返回队尾元素</span></span><br><span class="line">deque.pollFirst(); <span class="comment">//6.返回并弹出队首元素 &gt;&gt; 1 3</span></span><br><span class="line">deque.pollLast(); <span class="comment">//7.返回并弹出队尾元素 &gt;&gt; 1</span></span><br><span class="line">deque.isEmpty();</span><br><span class="line">deque.size();</span><br></pre></td></tr></table></figure><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><blockquote><p>Java中LinkedList是用链表实现的堆栈，Stack类是用数组实现的堆栈</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">stack.push(<span class="number">1</span>);stack.push(<span class="number">3</span>); <span class="comment">// 1.往栈顶插入一个元素</span></span><br><span class="line">stack.peek(); <span class="comment">// 2.返回栈顶元素</span></span><br><span class="line">stack.pop(); <span class="comment">// 3.返回并弹出栈顶元素</span></span><br><span class="line">stack.size(); <span class="comment">// 4.返回栈的元素个数</span></span><br><span class="line">stack.empty(); <span class="comment">// 5.true 栈为空， false 栈非空</span></span><br></pre></td></tr></table></figure><h2 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h2><blockquote><p>Java中的优先队列是用堆实现的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化时传入一个比较器，则按照比较器的规则进行排序</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue1 = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;&gt;());</span><br><span class="line"><span class="comment">//不传入比较器则按照默认规则进行排序，比如按照数字的升序进行排列</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue2 = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">queue2.add(<span class="number">1</span>); <span class="comment">// 1.插入一个元素</span></span><br><span class="line">queue2.peek(); <span class="comment">// 2.返回堆顶元素</span></span><br><span class="line">queue2.poll(); <span class="comment">// 3.返回并删除堆顶元素</span></span><br><span class="line">queue2.size(); queue2.isEmpty();</span><br></pre></td></tr></table></figure><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote><p>目前算法中常用到HashSet，TreeSet在后续题目中用到再回来记录</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet常用于去重</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="keyword">new</span>  HashSet&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">int</span>[] numgbers = &#123;<span class="number">1</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">23</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;numbers.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(set.contains(numbers[i]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//write the code for target logic of algorithm</span></span><br><span class="line">    &#125;</span><br><span class="line">   set.add(numbers[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><blockquote><p>这里的map也只介绍HashMap，Java中的HashMap解决冲突的方式使用的是链寻址法，在冲突位置使用的是一颗平衡树(红黑树)来存储冲突元素，即最坏的时间复杂度为O(log n)。同时HashMap还有第二种解决冲突的方式，名为开放寻址法，即在发生冲突时，不断地往后找，直到找到一个没有存过值的位置来存储元素，一般开放寻址法的hash表的大小是原数组的2~3倍。（具体的hash散列的描述会单独写一篇笔记进行记录）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//HashMap初始化</span></span><br><span class="line">        HashMap&lt;String, Integer&gt; personMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加一个键值对</span></span><br><span class="line">        personMap.put(<span class="string">"zhangsan"</span>,<span class="number">18</span>);</span><br><span class="line">        <span class="comment">//判断HashMap中是否含有某一个键</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = personMap.containsKey(<span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="comment">//根据key获取value</span></span><br><span class="line">        <span class="keyword">int</span> age = personMap.get(<span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="comment">//根据键删除一个entry</span></span><br><span class="line">        personMap.remove(<span class="string">"zhangsan"</span>);</span><br><span class="line">        <span class="comment">//根据keyset来遍历values</span></span><br><span class="line">        Set&lt;String&gt; keyset = personMap.keySet();</span><br><span class="line">        <span class="keyword">for</span>(String key : keyset)&#123;</span><br><span class="line">            System.out.println(personMap.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习笔记-Black-Box Testing</title>
      <link href="2020/10/14/software-testing-notes-2/"/>
      <url>2020/10/14/software-testing-notes-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Black-box testing –testing based on a specification</p></blockquote><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-2-1.png" alt></p><h2 id="Advantages-of-Black-box-Testing"><a href="#Advantages-of-Black-box-Testing" class="headerlink" title="Advantages of Black-box Testing"></a>Advantages of Black-box Testing</h2><blockquote><p>You don’t need to know how it is implemented</p></blockquote><ul><li>You can plan tests earlier</li><li>You can write tests earlier</li><li>You do not need to be the person who implements the code</li><li>When the implementation changes, the tests should still work</li></ul><h2 id="Different-techniques-for-Black-box-Testing"><a href="#Different-techniques-for-Black-box-Testing" class="headerlink" title="Different techniques for Black-box Testing"></a>Different techniques for Black-box Testing</h2><ul><li>Equivalence Partitioning</li><li>Boundary Value Analysis</li><li>Decision Tables</li><li>Cause-Effect Graphing</li><li>Error guessing</li></ul><h3 id="Equivalence-Partitioning"><a href="#Equivalence-Partitioning" class="headerlink" title="Equivalence Partitioning"></a>Equivalence Partitioning</h3><ul><li>Input data and output results often fall into different classes, where all members of the class are related</li><li>Each of these classes is an <strong>equivalence partition</strong> or <strong>domain</strong> where the program behaves in an equivalent way for each class member</li><li>techniques of equivalence partitioning<ul><li>valid &amp; invalid equivalence classes</li><li>guidelines for variables (integer, string, enum, array)</li></ul></li></ul><h2 id="Design-Reasonable-Test-Cases"><a href="#Design-Reasonable-Test-Cases" class="headerlink" title="Design Reasonable Test Cases"></a>Design Reasonable Test Cases</h2><ul><li><p>Step 1: Identify equivalence classes</p></li><li><p>Step 2: Design a new test case that covers a valid equivalence class which has not yet been tested (Repeat)</p></li><li><p>Step 3: Design a new test case that covers a invalid equivalence class which has not yet been tested (Repeat)</p></li></ul><h2 id="Weak-Normal-Strong-Robust"><a href="#Weak-Normal-Strong-Robust" class="headerlink" title="Weak, Normal, Strong, Robust"></a>Weak, Normal, Strong, Robust</h2><h3 id="Weak-vs-Strong"><a href="#Weak-vs-Strong" class="headerlink" title="Weak vs Strong"></a>Weak <em>vs</em> Strong</h3><ul><li>Weak: Assuming a single fault</li><li>Strong: Assuming multiple faults</li></ul><h3 id="Normal-vs-Robust"><a href="#Normal-vs-Robust" class="headerlink" title="Normal vs Robust"></a>Normal <em>vs</em> Robust</h3><ul><li>Normal: select values from the ‘valid’ range</li><li>Robust: select values from the ‘invalid’ range</li></ul><h2 id="Boundary-Value-Analysis"><a href="#Boundary-Value-Analysis" class="headerlink" title="Boundary Value Analysis"></a>Boundary Value Analysis</h2><blockquote><p>Boundary Value Analysis works well when the variables are independent and represent bounded physical quantities</p></blockquote><p>For any input variable, create tests cases with values that are:</p><ul><li>At the minimum (min)</li><li>Just above the minimum (min + 1)</li><li>At a nominal value</li><li>Just below the maximum (max –1)</li><li>At the maximum (max) 16</li></ul><h3 id="Some-descriptions-of-boundary-value-analysis"><a href="#Some-descriptions-of-boundary-value-analysis" class="headerlink" title="Some descriptions of boundary value analysis"></a>Some descriptions of boundary value analysis</h3><ul><li>The reason for focusing on the boundary value testing is that errors do occur near the extreme values of an input variable</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第六章|| 复化求积公式</title>
      <link href="2020/10/11/mathAnalysis-6-4/"/>
      <url>2020/10/11/mathAnalysis-6-4/</url>
      
        <content type="html"><![CDATA[<h1 id="复化求积公式"><a href="#复化求积公式" class="headerlink" title="复化求积公式"></a>复化求积公式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li>和分段插值多项式的原理类似</li></ul><h2 id="复化梯形公式"><a href="#复化梯形公式" class="headerlink" title="复化梯形公式"></a>复化梯形公式</h2><script type="math/tex; mode=display">\int_a^bf(x)dx \approx \frac{h}{2}[f(a) + 2\sum_{k=1}^{n-1}f(x_k)+f(b)] = T_n \\R[f]=I-T_n\le \frac{(b-a)^3}{12n^2}M_2</script><h2 id="复化Simpson公式"><a href="#复化Simpson公式" class="headerlink" title="复化Simpson公式"></a>复化Simpson公式</h2><script type="math/tex; mode=display">\int_a^bf(x)dx\approx \frac{h}{6}[f(a)+4\sum_{k=1}^nf(x_{k-\frac{1}{2}})+2\sum_{k=1}^{n-1}f(x_k)+f(b)]\\|I-S_n|\le \frac{(b-a)^5}{2880n^4}M_4</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第六章|| Gauss型求积公式</title>
      <link href="2020/10/11/mathAnalysis-6-5/"/>
      <url>2020/10/11/mathAnalysis-6-5/</url>
      
        <content type="html"><![CDATA[<h1 id="Gauss型求积公式"><a href="#Gauss型求积公式" class="headerlink" title="Gauss型求积公式"></a>Gauss型求积公式</h1><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul><li>区间$[a,b]$上权函数为$\rho(x)$的具有n个节点的求积公式的代数精度不超过$2n-1$.</li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>对于给定区间$[a,b]$及权函数$\rho(x)$,由$Schemite$正交化过程构造正交多项式$p_0(x),p_1(x),…,p_n(x)$;</p></li><li><p>求出$p_n(x)$的$n$个零点,即$Gauss$点</p></li><li><p>计算求积系数$A_i=\int_a^bl_i(x)\rho(x)dx,i=1,2,…,n$.</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ul><li>求计算积分$f_{-1}^1x^2f(x)dx的两点Gauss公式$</li></ul><script type="math/tex; mode=display">1.首先进行Schemite正交化\\</script><script type="math/tex; mode=display">p_0(x) = 1\\p_1(x) = x - \frac{(x,p_0(x))}{(p_0(x),p_0(x))}p_0(x)=x\\</script><script type="math/tex; mode=display">p_2(x) = x^2-\frac{(x^2,p_0(x))}{(p_0(x),p_0(x))}p_0(x) - \frac{(x^2,p_1(x))}{(p_1(x),p_1(x))}p_1(x)=x^2-\frac{3}{5}\\</script><script type="math/tex; mode=display">2.令p_2(x) = 0,求出Gauss点\\</script><script type="math/tex; mode=display">x_1=-\sqrt{\frac{3}{5}},x_2=\sqrt{\frac{3}{5}}\\</script><script type="math/tex; mode=display">3.计算求积系数A_k \\</script><script type="math/tex; mode=display">A_1 = \int_{-1}^1x^2\frac{x-x_2}{x_1-x_2}dx=\frac{1}{3}\\A_2 = \int_{-1}^1x^2\frac{x-x_1}{x_2-x_1}dx=\frac{1}{3}</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第六章|| 插值型数值求积公式</title>
      <link href="2020/10/11/mathAnalysis-6-3/"/>
      <url>2020/10/11/mathAnalysis-6-3/</url>
      
        <content type="html"><![CDATA[<h1 id="插值型数值求积公式"><a href="#插值型数值求积公式" class="headerlink" title="插值型数值求积公式"></a>插值型数值求积公式</h1><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><script type="math/tex; mode=display">\int_a^bf(x)dx\approx\int_a^bL_n(x)dx=\sum_{k=0}^n[\int_a^bl_k(x)dx]f(x_k)\\A_k=\int_a^bl_k(x)dx\\R[f] = \frac{1}{(n+1)!}\int_a^bf^{n+1}(\xi_x)\omega_{n+1}(x)dx</script><h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul><li>求积公式至少具有n次代数精度的充分必要条件是其是插值型求积公式</li></ul><h2 id="Newton-Cotes-求积公式"><a href="#Newton-Cotes-求积公式" class="headerlink" title="Newton-Cotes 求积公式"></a>Newton-Cotes 求积公式</h2><h3 id="公式-1"><a href="#公式-1" class="headerlink" title="公式"></a>公式</h3><script type="math/tex; mode=display">\int_a^bf(x)dx\approx(b-a)\sum_{k=0}^nC_k^{(n)}f(a+kh)</script><h3 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h3><ul><li>当n为偶数时，Newton-Cotes求积公式至少具有n+1次代数精度。</li></ul><h3 id="常用公式"><a href="#常用公式" class="headerlink" title="常用公式"></a>常用公式</h3><h4 id="梯形公式"><a href="#梯形公式" class="headerlink" title="梯形公式"></a>梯形公式</h4><script type="math/tex; mode=display">\int_a^bf(x)dx=\frac{(b-a)}{2}(f(a)+f(b))\\R[f] \le \frac{M_2}{12}(b-a)^3</script><h4 id="Simpson公式-具有三次代数精度"><a href="#Simpson公式-具有三次代数精度" class="headerlink" title="Simpson公式(具有三次代数精度)"></a>Simpson公式(具有三次代数精度)</h4><script type="math/tex; mode=display">\int_a^bf(x)dx=\frac{(b-a)}{6}(f(a)+4f(\frac{a+b}{2})+f(b)) \\R[f] \le \frac{M_4}{2880}(b-a)^5</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第六章|| 数值积分的代数精度</title>
      <link href="2020/10/11/mathAnalysis-6-2/"/>
      <url>2020/10/11/mathAnalysis-6-2/</url>
      
        <content type="html"><![CDATA[<h1 id="数值积分的代数精度"><a href="#数值积分的代数精度" class="headerlink" title="数值积分的代数精度"></a>数值积分的代数精度</h1><h2 id="代数精度的定义"><a href="#代数精度的定义" class="headerlink" title="代数精度的定义"></a>代数精度的定义</h2><ul><li><p>若求积公式 $\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k)$对于$f(x)=x^j(j=0,1,2…m)$都精确成立，但对$f(x)=x^{m+1}$不精确成立，则称该求积公式有$m$次的代数精度。</p></li><li><p>如果一个求积公式的代数精度为$m$，则该求积公式对于任何次数不超过$m$的函数都是精确成立的。</p></li><li><p>一般来说，代数精度越高，求积公式的精度也越高。</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>已知一个求积公式，和一些离散的节点，让你求求积公式的代数精度：</p><p>这类题，有几个未知数就列几个方程求解即可，同时还要带入更高阶的多项式函数来验证求积公式是否具有更高阶的代数精度。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第六章|| 数值积分的基本概念</title>
      <link href="2020/10/11/mathAnalysis-6-1/"/>
      <url>2020/10/11/mathAnalysis-6-1/</url>
      
        <content type="html"><![CDATA[<h1 id="数值积分的基本概念"><a href="#数值积分的基本概念" class="headerlink" title="数值积分的基本概念"></a>数值积分的基本概念</h1><ul><li><p>牛顿-莱布尼兹公式</p><p>  $\int_b^af(x)dx=F(b)-F(a)$</p></li><li><p>定积分的定义</p><p>  $I=\int_a^bf(x)dx=lim_{\Delta x\rightarrow0}\sum_{i=0}^nf(x_i)\Delta x_i$</p></li><li><p>求积公式的一般形式</p><p>  $\int_a^bf(x)dx\approx\sum_{k=0}^nA_kf(x_k).A_k为求积系数，x_k为求积节点$</p></li><li><p>积分中值定理</p><p>  在$[a,b]$内存在一点$\xi$,有$\int_a^bf(x)dx=(b-a)f(\xi)$成立</p></li><li><p>由积分中值定理可得三个数值积分公式</p><p>  左矩形公式：$f_a^bf(x)dx=(b-a)f(a)$</p><p>  中矩形公式：$f_a^bf(x)dx=(b-a)f(\frac{b+a}{2})$</p><p>  右矩形公式：$f_a^bf(x)dx=(b-a)f(b)$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习笔记-Unit Testing</title>
      <link href="2020/10/11/software-testing-notes-4/"/>
      <url>2020/10/11/software-testing-notes-4/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Unit-Testing"><a href="#What-is-Unit-Testing" class="headerlink" title="What is Unit Testing?"></a>What is Unit Testing?</h2><h3 id="Software-Units"><a href="#Software-Units" class="headerlink" title="Software Units:"></a>Software Units:</h3><p>A unit is the smallest unit of the design in a software project</p><ul><li>In Java, a unit is a class or a method</li><li>In C, a unit is a function or .h/.c files</li></ul><h3 id="Unit-Testing"><a href="#Unit-Testing" class="headerlink" title="Unit Testing:"></a>Unit Testing:</h3><p>A process to check that each unit is working correctly, according to the requirements and design</p><ul><li>Test each unit independently of other units</li><li>We can use tools to help us, e.g. JUnit, but the tools aren’t required.</li></ul><h2 id="Something-should-be-concerned-when-doing-unit-testing"><a href="#Something-should-be-concerned-when-doing-unit-testing" class="headerlink" title="Something should be concerned when doing unit testing"></a>Something should be concerned when doing unit testing</h2><ul><li>Focus on single SUT at a time</li><li>Don’t test multiple units at once</li></ul><h2 id="Purpose-of-Unit-Testing"><a href="#Purpose-of-Unit-Testing" class="headerlink" title="Purpose of Unit Testing"></a>Purpose of Unit Testing</h2><ul><li>Validate whether code is consistent with the design and requirements.</li><li>Discover the errors between requirements , design and implementation.<ul><li>Error of omission(what is required, but not implemented)</li><li>Error of commission (an incorrect implementation)</li></ul></li></ul><h2 id="Aims-of-Unit-Tests"><a href="#Aims-of-Unit-Tests" class="headerlink" title="Aims of Unit Tests"></a>Aims of Unit Tests</h2><ul><li><strong>Aim:</strong> ensure that module was implemented correctly</li><li><strong>Input: </strong>detailed specification</li><li><strong>Process: </strong>design and implement tests and analyse results</li><li><strong>Personnal: </strong>Developers and Testers</li><li><strong>Test Approaches: </strong>black-box and white-box methods</li><li><strong>Evaluation: </strong>determine if the tests reveal errors</li></ul><h2 id="Some-benefits-of-Unit-Testing"><a href="#Some-benefits-of-Unit-Testing" class="headerlink" title="Some benefits of Unit Testing"></a>Some benefits of Unit Testing</h2><ul><li>The goal of unit testing is to isolate each part of the program and show that the individual parts are correct.</li><li>A unit test provides a strict, written contract that the piece of code must satisfy.</li><li>Easier to find issues when a test fails.</li><li>Unit tests find problems early in the development cycle. Reduce the costs.</li><li>Run the tests many times during development –easier to help with regression issues.</li></ul><h2 id="Aspects-of-unit-tests"><a href="#Aspects-of-unit-tests" class="headerlink" title="Aspects of unit tests"></a>Aspects of unit tests</h2><ul><li>Unit interface (need to be tested)</li><li>Functional tests - black box</li><li>Structural tests - white box</li><li>Error handling</li><li>Incorrect input</li></ul><h2 id="Unit-Testing-with-a-Framework"><a href="#Unit-Testing-with-a-Framework" class="headerlink" title="Unit Testing with a Framework"></a>Unit Testing with a Framework</h2><h3 id="Desirable-features-of-a-unit-test-framework"><a href="#Desirable-features-of-a-unit-test-framework" class="headerlink" title="Desirable features of a unit test framework"></a>Desirable features of a unit test framework</h3><ul><li>easy to write</li><li>easy to learn to write</li><li>quick to execute</li><li>easy to execute</li><li>isolated</li><li>composable</li></ul><h3 id="Test-Fixtures-Setup-Teardown"><a href="#Test-Fixtures-Setup-Teardown" class="headerlink" title="Test Fixtures: Setup - Teardown"></a>Test Fixtures: Setup - Teardown</h3><ul><li>Setup (might use common setup, e.g. @Before)</li><li>Exercise- call methods on the SUT</li><li>Verify(Assertions…)</li><li>Teardown (optional, e.g. @AfterEach, @AfterAll)</li></ul><p>(steps: Setup fixtures -&gt; Setup test -&gt; execute test -&gt; check result -&gt; teardown fixtures)</p><h2 id="Traditional-unit-testing-strategies"><a href="#Traditional-unit-testing-strategies" class="headerlink" title="Traditional unit testing strategies"></a>Traditional unit testing strategies</h2><h3 id="Top-down-unit-testing-strategy"><a href="#Top-down-unit-testing-strategy" class="headerlink" title="Top-down unit testing strategy"></a>Top-down unit testing strategy</h3><ul><li>Test the top level first. Create test-doubles for units called by the top-level. Create driver for top-level. Then, use the tested unit as the driver for next level.</li></ul><h3 id="Bottom-up-unit-testing-strategy"><a href="#Bottom-up-unit-testing-strategy" class="headerlink" title="Bottom-up unit testing strategy"></a>Bottom-up unit testing strategy</h3><ul><li>Test the bottom modules first. Create a driver module for it. When tested, move to next module up, creating a new driver. The tested lower-level module can be used instead of a stub.</li></ul><h3 id="Isolation-testing"><a href="#Isolation-testing" class="headerlink" title="Isolation testing"></a>Isolation testing</h3><ul><li>Do not consider the relationship between modules. Design test doubles and driver for every unit.</li></ul><h2 id="Test-Doubles"><a href="#Test-Doubles" class="headerlink" title="Test Doubles"></a>Test Doubles</h2><h3 id="Why-we-need-use-test-doubles"><a href="#Why-we-need-use-test-doubles" class="headerlink" title="Why we need use test doubles?"></a>Why we need use test doubles?</h3><p>There are times in testing when we need to use <strong>test doubles,</strong>  which are units that are used to replace a real part of the system for test purposes. Some examples:</p><ul><li>Databases</li><li>Code that is not ready yet</li><li>External hardware</li><li>Components that do not return values</li></ul><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-4-1.png" alt="testing workflow"></p><h3 id="Types-pf-Test-Double"><a href="#Types-pf-Test-Double" class="headerlink" title="Types pf Test Double"></a>Types pf Test Double</h3><ul><li>Dummy Object</li><li>Test Stub</li><li>Mock Object</li><li>Fake Object</li></ul><h3 id="Dummy-Object"><a href="#Dummy-Object" class="headerlink" title="Dummy Object"></a>Dummy Object</h3><ul><li>An SUT requires a data value as a part of test<ul><li>It does not matter what value is actually in the data value, it just needs to exist</li></ul></li><li>In some situations, the value null might be used. It depends on what the SUT will do with the value.<ul><li>e.g. service.getOne(new QueryWrapper()); // it just need a wraaper</li></ul></li></ul><h3 id="Test-Stub"><a href="#Test-Stub" class="headerlink" title="Test Stub"></a>Test Stub</h3><ul><li>it just need a value (a correct value, error value, log value)</li><li>e.g. Data logging software</li></ul><h3 id="Mock-Object"><a href="#Mock-Object" class="headerlink" title="Mock Object"></a>Mock Object</h3><ul><li>A Mock Object is setup with information about what calls it should expect. It might also be setup with details of the data it should expect.</li><li>Mock Objects are testing the behaviour of the interaction between the SUT and DOC</li><li>A number of values in one unit testing(interaction)</li></ul><h3 id="Fake-Object"><a href="#Fake-Object" class="headerlink" title="Fake Object"></a>Fake Object</h3><ul><li>An object that replaces the functionality of the DOC</li></ul><h2 id="Some-tips-of-Unit-testing"><a href="#Some-tips-of-Unit-testing" class="headerlink" title="Some tips of Unit testing"></a>Some tips of Unit testing</h2><ul><li>Print statements are useful for debugging!</li><li>Unit test cases can detect logic errors</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习笔记-White-Box Testing</title>
      <link href="2020/10/11/software-testing-notes-3/"/>
      <url>2020/10/11/software-testing-notes-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>White-box testing –testing based on the logic in a program</p></blockquote><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-3-1.png" alt></p><h2 id="Some-descriptions-about-White-box-Testing"><a href="#Some-descriptions-about-White-box-Testing" class="headerlink" title="Some descriptions about White-box Testing"></a>Some descriptions about White-box Testing</h2><ul><li>White-box is based on the implementation</li><li>For high confidence, e.g. in safety critical software, need to look at the code and make sure every possibility is covered(<strong>Not all software</strong>)</li><li>Still worth doing black-box testing then look at EXTRA tests based on white-box approaches</li></ul><h2 id="White-box-Testing-types"><a href="#White-box-Testing-types" class="headerlink" title="White-box Testing types"></a>White-box Testing types</h2><ul><li>Static Analysis</li><li>Dynamic Testing with path coverage of code</li></ul><h2 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h2><ul><li>Discussed during the Software Lifecycle course</li><li>Code Inspection(代码检查)</li><li>The analysis cannot be automated</li><li>BUT, code inspections are an effective way to detect potential problems</li></ul><h2 id="Dynamic-Testing-Path-Coverage"><a href="#Dynamic-Testing-Path-Coverage" class="headerlink" title="Dynamic Testing: Path Coverage"></a>Dynamic Testing: Path Coverage</h2><ul><li>Write tests so that every path through the program is tested</li><li>The tests can be automated and repeated</li></ul><h2 id="Baic-principles-of-path-coverage"><a href="#Baic-principles-of-path-coverage" class="headerlink" title="Baic principles of path coverage"></a>Baic principles of path coverage</h2><ul><li>All independent path must be traversed at least once</li><li>All conditions(e.g. if statements) are tested for the true and false outcome</li><li>Review whether the test cover the internal data structure used</li><li>Test that loops work for their operational range(Not All)</li></ul><blockquote><p>e.g. if (name == null || name.equals(“”))</p><p>You need create two test cases for this if statement</p></blockquote><h2 id="Path-coverage-with-IDEA"><a href="#Path-coverage-with-IDEA" class="headerlink" title="Path coverage with IDEA"></a>Path coverage with IDEA</h2><h3 id="Step-1-Create-a-normal-class-with-some-methods"><a href="#Step-1-Create-a-normal-class-with-some-methods" class="headerlink" title="Step 1: Create a normal class with some methods"></a>Step 1: Create a normal class with some methods</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-2.png" alt></p><h3 id="Step-2-Using-Alt-Enter-to-create-a-test-class-with-this-normal-class"><a href="#Step-2-Using-Alt-Enter-to-create-a-test-class-with-this-normal-class" class="headerlink" title="Step 2:  Using Alt + Enter to create a test class with this normal class"></a>Step 2:  Using Alt + Enter to create a test class with this normal class</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-3.png" alt></p><h3 id="Step-3-Write-some-codes-to-test-path-coverage"><a href="#Step-3-Write-some-codes-to-test-path-coverage" class="headerlink" title="Step 3:  Write some codes to test path coverage"></a>Step 3:  Write some codes to test path coverage</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-4.png" alt></p><h3 id="Step-4-Run-with-code-coverage"><a href="#Step-4-Run-with-code-coverage" class="headerlink" title="Step 4: Run with code coverage"></a>Step 4: Run with code coverage</h3><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201014/notes-3-5.png" alt></p><blockquote><p>One useful tip: You could draw a decision tree to find how many test cases you need create when you analyse combination of if statements!</p></blockquote><h2 id="How-to-calculate-Cyclomatic-Complexity"><a href="#How-to-calculate-Cyclomatic-Complexity" class="headerlink" title="How to calculate Cyclomatic Complexity"></a>How to calculate Cyclomatic Complexity</h2><ul><li>Draw a Control flow graph already</li><li>cc = Numbers of Edges - Numbers of  Node + 2</li><li>or cc = Number of condition clause + 1</li></ul><h2 id="Basis-Path"><a href="#Basis-Path" class="headerlink" title="Basis Path"></a>Basis Path</h2><ul><li>Independent path through the code</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习笔记-introduction</title>
      <link href="2020/10/11/softeware-testing-notes-1/"/>
      <url>2020/10/11/softeware-testing-notes-1/</url>
      
        <content type="html"><![CDATA[<h2 id="Errors-Faults-and-Failures"><a href="#Errors-Faults-and-Failures" class="headerlink" title="Errors, Faults and Failures"></a>Errors, Faults and Failures</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201011/notes-1-1.png" alt></p><ul><li>Error - A problem that is introduced into a system during development.</li><li>Faults - A result of error.(maybe something is missing, or incorrect execution)</li><li>Failures - The result when a fault executes.</li><li>Incidents - The symptoms(症状) that indicates that there is a fault.</li></ul><h2 id="Some-correct-descriptions-of-Test-Cases"><a href="#Some-correct-descriptions-of-Test-Cases" class="headerlink" title="Some correct descriptions of Test Cases"></a>Some correct descriptions of Test Cases</h2><ul><li>A test case is requires a description of the inputs to a system.</li><li>A test case is requires a description of the outputs from a system.</li><li>Each test case should be identifiable, e.g. assigned a Test ID.</li></ul><h2 id="Some-topics-which-are-considered-‘good-enough’-for-Testing"><a href="#Some-topics-which-are-considered-‘good-enough’-for-Testing" class="headerlink" title="Some topics which are considered ‘good enough’ for Testing"></a>Some topics which are considered ‘good enough’ for Testing</h2><ul><li>Test early and test often</li><li>Integrate development and testing lifecycles</li><li>Formalize the testing methodology</li><li>Develop a comprehensive test plan</li><li>Use static and dynamic testing</li><li>Balancing time, money and quality</li></ul>]]></content>
      
      
      <categories>
          
          <category> Software Testing notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Software Testing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做算法题的小技巧</title>
      <link href="2020/10/10/algorithm-1/"/>
      <url>2020/10/10/algorithm-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在写算法题的过程中总结的一些经验和技巧，</p><p>希望有一天leet coin可以5000+！</p></blockquote><h2 id="java输入输出问题"><a href="#java输入输出问题" class="headerlink" title="java输入输出问题"></a>java输入输出问题</h2><h3 id="BufferedReader和Scanner"><a href="#BufferedReader和Scanner" class="headerlink" title="BufferedReader和Scanner"></a>BufferedReader和Scanner</h3><ul><li><p>首先明确一点BufferedReader的读取速度是要快于Scanner的，因为BufferedReader有缓冲区，默认大小为8kb，足够算法题的输入使用。</p></li><li><p>BufferedReader的缺点就是只能读入字符，如果要读取数字需要进行转换，readLine()根据enter键读取下一个输入。</p></li><li><p>Scanner的优点就是可以读入数字和字符，不需要转换(nextInt() | nextLine() | nextLong() …)，next()根据enter、空格、Tab键读取下一个输入。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入：hello world</span></span><br><span class="line">BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">System.out.print(br.readLine()); <span class="comment">// print&gt; hello world</span></span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">System.out.print(in.next()); <span class="comment">// print&gt; hello</span></span><br><span class="line">System.out.print(in.nextLine()); <span class="comment">// print&gt; hello world</span></span><br></pre></td></tr></table></figure><h3 id="BufferedWriter和System-out"><a href="#BufferedWriter和System-out" class="headerlink" title="BufferedWriter和System.out"></a>BufferedWriter和System.out</h3><ul><li>和BufferedReader一样，BufferedWriter也是缓冲流，将字符先写入缓冲区，调用flush方法之后，将字符输出。</li><li>System.out是标准的字符输出流，可以直接将字符输出，并自动flush</li><li>BufferedWriter比System.out的写速度要快<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出hello world</span></span><br><span class="line">System.out.print(<span class="string">"hello world"</span>); <span class="comment">// &gt;&gt; hello world</span></span><br><span class="line">BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">bw.write(<span class="string">"hello world"</span>); <span class="comment">// &gt;&gt; </span></span><br><span class="line">bw.flush(); <span class="comment">// &gt;&gt; hello world</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>BufferedWriter.write(int c) 输出乱码问题解决方案：</p><p>API中对于BufferedWriter的write(int c)解释为“Writes a single character”，所以其实写入的数据类型为char，内存长度只有2个字节，而且是以Unicode编码，所以会出现乱码。</p><p>故需要先将int强转为Integer, 再wirte(c.toString())即可。</p></blockquote><h3 id="写算法题的输入输出范例"><a href="#写算法题的输入输出范例" class="headerlink" title="写算法题的输入输出范例"></a>写算法题的输入输出范例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//输入</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">        String input = br.readLine();</span><br><span class="line">        String output = operate(input); <span class="comment">//operate看作是解决算法问题的方法</span></span><br><span class="line">        <span class="comment">//打印结果</span></span><br><span class="line">        bw.write(output);</span><br><span class="line">        </span><br><span class="line">        bw.flush(); <span class="comment">//必须刷新缓冲区，否则无法打印结果</span></span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果输出是浮点数，且要保留精度，或者格式化输出，还是使用System.out.printf;</p><p>可以使用bw.newLine()输出一个换行符。</p></blockquote><h2 id="算法小技巧"><a href="#算法小技巧" class="headerlink" title="算法小技巧"></a>算法小技巧</h2><h3 id="求最大公约数-辗转相除法"><a href="#求最大公约数-辗转相除法" class="headerlink" title="求最大公约数(辗转相除法)"></a>求最大公约数(辗转相除法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = n, b = m; <span class="comment">//n和m是实际问题中的两个整数</span></span><br><span class="line"><span class="keyword">while</span>(b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> r = a % b;</span><br><span class="line">    a = b;</span><br><span class="line">    b = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a; <span class="comment">//此时a就是n,m的最大公约数</span></span><br></pre></td></tr></table></figure><h3 id="求最小公倍数"><a href="#求最小公倍数" class="headerlink" title="求最小公倍数"></a>求最小公倍数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a和b的最小公倍数 = a*b / a和b的最大公约数</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||最小二乘法</title>
      <link href="2020/10/09/mathAnalysis-5-4/"/>
      <url>2020/10/09/mathAnalysis-5-4/</url>
      
        <content type="html"><![CDATA[<h1 id="最小二乘法-多项式拟合曲线"><a href="#最小二乘法-多项式拟合曲线" class="headerlink" title="最小二乘法(多项式拟合曲线)"></a>最小二乘法(多项式拟合曲线)</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在函数类$\Phi=span [\phi_0(x),\phi_1(x),\cdots,\phi_n(x)]$中找到一个函数,使得拟合函数和原函数的误差向量的二范数达到最小.</p><h2 id="多项式拟合函数-1-x-x-2-cdots-x-n"><a href="#多项式拟合函数-1-x-x-2-cdots-x-n" class="headerlink" title="多项式拟合函数($1,x,x^2,\cdots,x^n$)"></a>多项式拟合函数($1,x,x^2,\cdots,x^n$)</h2><script type="math/tex; mode=display">\phi(x)=a_0\phi_0(x)+a_1\phi_1(x)+\cdots+a_n\phi_n(x)</script><p>只需要求出系数$a_0,a_1,\cdots,a_n$即可求出拟合曲线</p><h2 id="正则方程组"><a href="#正则方程组" class="headerlink" title="正则方程组"></a>正则方程组</h2><p><img src="https://nicklaus-edu.oss-cn-beijing.aliyuncs.com/blog/20201009/image-20200611221402561.png" alt="image-20200611221402561"></p><p>$(\phi_0,\phi_1)=\rho\phi_0\phi_1$</p><h2 id="构造最小二乘法的一些思路"><a href="#构造最小二乘法的一些思路" class="headerlink" title="构造最小二乘法的一些思路"></a>构造最小二乘法的一些思路</h2><ul><li>如果离散节点构成的函数图像不是多项式函数,而是指数函数,可以采用取对数的方式来化成多项式函数求值!</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||牛顿插值多项式</title>
      <link href="2020/10/09/mathAnalysis-5-3/"/>
      <url>2020/10/09/mathAnalysis-5-3/</url>
      
        <content type="html"><![CDATA[<h1 id="牛顿插值多项式"><a href="#牛顿插值多项式" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h1><h2 id="差商"><a href="#差商" class="headerlink" title="差商"></a>差商</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>一阶差商：$f[x_i,x_j]=\frac{f(x_j)-f(x_i)}{x_j-x_i}$</li><li>二阶差商：$f[x_i,x_j,x_k]=\frac{f[x_j,x_k]-f[x_i,x_j]}{x_k-x_i}$</li><li>k阶差商以此类推</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ol><li>$f[x_0,x_1,\cdots,x_k]=\sum_{j=0}^k\frac{1}{\omega’_{k+1}(x_j)}f(x_j)$</li><li>差商对节点具有对称性</li><li>n次多项式$f(x)$的k阶差商$f[x_0,x_1,\cdots,x_{k-1},x]$,当$k\le n$时，是一个关于x的n-k次多项式，当$k&gt;n$时，恒等于0.</li><li>若$f(x)$具有k阶连续导数，则：$f[x_0,x_1,\cdots,x_k]=\frac{f^{(k)}(\xi)}{k!}$</li></ol><h2 id="牛顿插值多项式-1"><a href="#牛顿插值多项式-1" class="headerlink" title="牛顿插值多项式"></a>牛顿插值多项式</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p>$N_n(x)=f(x_0)+f[x_0,x_1]\omega_1(x)+f[x_0,x_1,x_2]\omega_2(x)+\cdots+f[x_0,x_1,\cdots,x_n]\omega_n(x)$</p><h3 id="余项"><a href="#余项" class="headerlink" title="余项"></a>余项</h3><p>$R_n(x)=f[x,x_0,x_1,\cdots,x_n]\omega_{n+1}(x)=\frac{f^{(n+1)}(\zeta)}{(n+1)!}\omega_{n+1}(x)$</p>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||分段插值多项式</title>
      <link href="2020/10/09/mathAnalysis-5-2/"/>
      <url>2020/10/09/mathAnalysis-5-2/</url>
      
        <content type="html"><![CDATA[<h1 id="分段插值多项式"><a href="#分段插值多项式" class="headerlink" title="分段插值多项式"></a>分段插值多项式</h1><h2 id="Runge现象"><a href="#Runge现象" class="headerlink" title="Runge现象"></a>Runge现象</h2><ul><li>高次的插值函数的近似效果越差,以致完全失真,这个现象称为Runge现象.(高次插值数值不稳定)</li></ul><h2 id="分段线性插值"><a href="#分段线性插值" class="headerlink" title="分段线性插值"></a>分段线性插值</h2><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><script type="math/tex; mode=display">S_1(x)=\frac{x_i-x}{h_i}y_{i-1}+\frac{x-x_{i-1}}{h_i}y_i, x \in [x_{i-1},x_i]</script><h3 id="插值余项"><a href="#插值余项" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">f(x)-S_1(x)=\frac{f''(\xi)}{2!}(x-x_{i-1})(x-x_i)\le\frac{M_2}{8}h^2</script><h2 id="分段二次插值"><a href="#分段二次插值" class="headerlink" title="分段二次插值"></a>分段二次插值</h2><h3 id="插值余项-1"><a href="#插值余项-1" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">f(x)-S_2(x)=\frac{f'''(\xi)}{3!}(x-x_{i-1})(x-x_{i-\frac{1}{2}})(x-x_i)\le \frac{M_3}{72\sqrt3}h^3</script><h2 id="分段Hermite插值"><a href="#分段Hermite插值" class="headerlink" title="分段Hermite插值"></a>分段Hermite插值</h2><h3 id="插值余项-2"><a href="#插值余项-2" class="headerlink" title="插值余项"></a>插值余项</h3><script type="math/tex; mode=display">f(x)-H_3(x)=\frac{f^{(4)}(\xi)}{4!}(x-x_{i-1})^2(x-x_i)^2\le \frac{M_4}{384}h^2(h^4?)</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第五章||插值的定义</title>
      <link href="2020/10/09/mathAnalysis-5-1/"/>
      <url>2020/10/09/mathAnalysis-5-1/</url>
      
        <content type="html"><![CDATA[<h1 id="插值的定义"><a href="#插值的定义" class="headerlink" title="插值的定义"></a>插值的定义</h1><h2 id="插值条件"><a href="#插值条件" class="headerlink" title="插值条件"></a>插值条件</h2><ul><li><p>设函数$f(x)$在区间$[a,b]$上连续，给定$n+1$个节点，$a\le x_0&lt;x_1…&lt;x_n\le b$。</p></li><li><p>已知$f(x_k)=y_k(k=0,1,…n)$,在函数类P中寻找一函数$\phi(x)$作为$f(x)$的近似表达式，使满足：</p><p>$\phi(x_k)=f(x_k)=y_k,k=0,1,…,n$</p><p>注：$\phi(x)$为插值函数，函数类P为多项式函数类</p></li></ul><h2 id="插值定理"><a href="#插值定理" class="headerlink" title="插值定理"></a>插值定理</h2><ul><li>如果$n+1$个节点互不相等，则存在唯一的一个插值函数$p_n(x)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第四章||牛顿迭代法</title>
      <link href="2020/10/09/mathAnalysis-4-3/"/>
      <url>2020/10/09/mathAnalysis-4-3/</url>
      
        <content type="html"><![CDATA[<h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><h2 id="Newton-迭代格式"><a href="#Newton-迭代格式" class="headerlink" title="Newton 迭代格式"></a>Newton 迭代格式</h2><ul><li>迭代格式（切线法）：$x_{k+1}=x_k-\frac{f(x_k)}{f^{‘}(x_k)}$</li><li>$\phi’(x)=\frac{f(x)f’’(x)}{(f’(x))^2}$</li></ul><h2 id="Newton-迭代法的收敛性"><a href="#Newton-迭代法的收敛性" class="headerlink" title="Newton 迭代法的收敛性"></a>Newton 迭代法的收敛性</h2><ul><li><p><strong>收敛阶：</strong>Newton 迭代法对于单根$\alpha$至少是平方阶收敛，Newton 迭代法对初值$x_0$的选取较为严格。</p></li><li><p><strong>定理：</strong>$\lim_{k\to\infty}\frac{x_{k+1}-\alpha}{(x_k-\alpha)^2}=\frac{f^{‘’}(\alpha)}{2f^{‘}(\alpha)}$</p></li></ul><h2 id="Newton-迭代法的变形"><a href="#Newton-迭代法的变形" class="headerlink" title="Newton 迭代法的变形"></a>Newton 迭代法的变形</h2><h3 id="简化-Newton-迭代法（线性收敛）"><a href="#简化-Newton-迭代法（线性收敛）" class="headerlink" title="简化 Newton 迭代法（线性收敛）"></a>简化 Newton 迭代法（线性收敛）</h3><ul><li>迭代格式：$x_{k+1}=x_k-\frac{f(x_k)}{M}\ ,k=0,1,2,\cdots$</li><li>$M通常取f^{‘}(x_o)$</li></ul><h3 id="割线法（该迭代法的收敛阶介于1和2之间）"><a href="#割线法（该迭代法的收敛阶介于1和2之间）" class="headerlink" title="割线法（该迭代法的收敛阶介于1和2之间）"></a>割线法（该迭代法的收敛阶介于1和2之间）</h3><ul><li>用<strong>函数$f(x)$的差商</strong>近似 Newton 迭代格式中的导数$f’（x）,即$</li><li>$f’(x)\approx\frac{f(x_k)-f(x_{k-1})}{x_k-x_{k-1}}$</li><li>Newton 迭代法可以修改为：$x_{k+1}=x_k-\frac{f(x_k)}{f(x_k)-f(x_{k-1})}(x_k-x_{k-1}),\ k=1,2,3,\cdots$</li></ul><h3 id="求方程重根的-Newton-迭代法（往往具有平方阶收敛）"><a href="#求方程重根的-Newton-迭代法（往往具有平方阶收敛）" class="headerlink" title="求方程重根的 Newton 迭代法（往往具有平方阶收敛）"></a>求方程重根的 Newton 迭代法（往往具有平方阶收敛）</h3><ul><li><strong>带参数m的迭代格式：</strong>$x_{k+1}=x_k-m\frac{f(x_k)}{f’(x_k)},\ k=0,1,2,\cdots$</li><li><strong>不带参数m的迭代格式：</strong>$x_{k+1}=x_k-\frac{u(x_k)}{u’(x_k)},\ k=0,1,2,\cdots \ ;u(x)=\frac{f(x)}{f’(x)}$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第四章||二分法</title>
      <link href="2020/10/09/mathAnalysis-4-1/"/>
      <url>2020/10/09/mathAnalysis-4-1/</url>
      
        <content type="html"><![CDATA[<h1 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h1><ul><li><p><strong>定义：</strong>设$[a,b]$为方程$f(x)=0$的有根区间。所谓二分法就是<strong>对有根区间</strong>$[a,b]$<strong>逐次分半</strong>，使得有根区间长度逐次缩小，从而得到根的近似值。</p></li><li><p><strong>步骤：</strong></p><script type="math/tex; mode=display">①记a_0=a,\ b=b_0,\ 计算\ x_1=\frac{a+b}{2} \\</script><script type="math/tex; mode=display">②若f(a_0)f(x_1)<0,\ 取\ a_1=a_0,\ b_1=x_1; \\</script><script type="math/tex; mode=display">③若f(a_0)f(x_1)>0,\ 取\ a_1=x_1,\ b_1=b_0; \\</script><script type="math/tex; mode=display">④则得到新的有根区间\ [a_1,b_1],\ 其区间长度恰好是\ [a_0,b_0]\ 长度的一半; \\</script><script type="math/tex; mode=display">⑤重复上述操作，直至根的近似值达到精度要求结束二分法。</script></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析||第四章||简单迭代法</title>
      <link href="2020/10/09/mathAnalysis-4-2/"/>
      <url>2020/10/09/mathAnalysis-4-2/</url>
      
        <content type="html"><![CDATA[<h1 id="简单迭代法"><a href="#简单迭代法" class="headerlink" title="简单迭代法"></a>简单迭代法</h1><h2 id="简单迭代法的一般形式"><a href="#简单迭代法的一般形式" class="headerlink" title="简单迭代法的一般形式"></a>简单迭代法的一般形式</h2><ul><li><strong>迭代格式：</strong>$x_{k+1}=\phi(x_k),\ \phi(x)称为迭代函数$</li></ul><h2 id="简单迭代法的收敛条件"><a href="#简单迭代法的收敛条件" class="headerlink" title="简单迭代法的收敛条件"></a>简单迭代法的收敛条件</h2><ul><li><p>收敛定理：</p><p>① 假设迭代函数$\phi(x)$在区间$[a,b]$上可导，且满足条件：</p><p>② $a\le \phi(x) \le b,\ x\in[a,b]$</p><p>③ 存在正数$L &lt; 1,$使对任意 $x \in [a,b]$ 有 $|\phi^{‘}(x)|\le L &lt; 1$</p></li></ul><h2 id="简单迭代法的收敛阶"><a href="#简单迭代法的收敛阶" class="headerlink" title="简单迭代法的收敛阶"></a>简单迭代法的收敛阶</h2><ul><li><strong>一般格式：</strong>$\lim_{k\to \infty} \tfrac{|e_{k+1}|}{|e_k|^p}=C$</li><li>$p$为<strong>收敛阶</strong>，$C$为<strong>渐近误差常数</strong>。</li><li><strong>收敛阶的求法：</strong>$\phi^{‘}(\alpha)=\phi^{‘’}(\alpha)=\cdots=\phi^{(p-1)}(\alpha)=0,\ \phi^{(P)}(\alpha)\neq0,\ p\ge2$,则迭代法<strong>p阶收敛</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础算法常用模板</title>
      <link href="2020/10/06/algorithmTemplate-1/"/>
      <url>2020/10/06/algorithmTemplate-1/</url>
      
        <content type="html"><![CDATA[<ul><li>常用排序、二分、高精度、前缀和、差分、位运算、双指针、离散化、区间合并<a id="more"></a></li></ul><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left-<span class="number">1</span>, j=right+<span class="number">1</span>, x=arr[(left+right)&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(arr[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(arr[j] &gt; x);</span><br><span class="line">        <span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[j];</span><br><span class="line">            arr[j] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    quickSort(arr, left, j);</span><br><span class="line">    quickSort(arr, j+<span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="comment">//终止</span></span><br><span class="line">    <span class="keyword">if</span>(left == right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(arr, left, mid);</span><br><span class="line">    mergeSort(arr, mid+<span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">int</span> i=left, j=mid+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;</span><br><span class="line">        <span class="comment">//temp数组用于临时存放left到right的有序数列</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt;= arr[j]) temp[k++] = arr[i++]; </span><br><span class="line">        <span class="keyword">else</span> temp[k++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将剩余的数依次放到temp数组</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid) temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=right) temp[k++] = arr[j++];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//归位</span></span><br><span class="line">    <span class="keyword">for</span>(i=left, j=<span class="number">0</span>; i &lt;= right; i++, j++) arr[i] = temp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[i]; <span class="comment">//找出第i小的元素，并放到数组的下标i中</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;min)&#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                minIndex = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">       <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = min;</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i]; <span class="comment">//将元素i插入到有序数列0,1,2...i-1中</span></span><br><span class="line">        <span class="keyword">for</span>(j=i-<span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j]; j--)&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//换位</span></span><br><span class="line">        arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找-两种情况"><a href="#二分查找-两种情况" class="headerlink" title="二分查找(两种情况)"></a>二分查找(两种情况)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_1</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) right = mid; <span class="comment">//满足区间在左半边</span></span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bSearch_2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初值,n为arr的长度</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; <span class="comment">//两者的区别</span></span><br><span class="line">        <span class="comment">//check()为判断边界条件是否满足，满足返回true</span></span><br><span class="line">        <span class="keyword">if</span>(check()) left = mid; <span class="comment">//满足区间在右半边</span></span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意：浮点数二分可以用于开n次方，也不用判断边界条件</span></span><br></pre></td></tr></table></figure><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">add</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A + B 数字均为逆序存储，例：12345被存储为54321</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//假设A&gt;B</span></span><br><span class="line">    <span class="keyword">if</span>(A.size() &lt; B.size())</span><br><span class="line">        <span class="keyword">return</span> add(B, A);</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果就是t%10的余数</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最后一次加法如果还有进位就把t加到结果中</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">sub</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B)</span></span>&#123;</span><br><span class="line">  <span class="comment">//假设A&gt;B,C = A - B</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t = A.get(i) - t;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t -= B.get(i);</span><br><span class="line">        <span class="comment">//第i位的结果有两种情况，一种是需要借位，一种是不需要</span></span><br><span class="line">        C.add((t+<span class="number">10</span>)%<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//计算借位</span></span><br><span class="line">        <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//结果可能为000123的情况，所以要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.get(C.size()-<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘低精度"><a href="#高精度乘低精度" class="headerlink" title="高精度乘低精度"></a>高精度乘低精度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">mul</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//A为高精度，b为低精度，C = Axb</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;A.size(); i++)&#123;</span><br><span class="line">        t += A.get(i)*b;</span><br><span class="line">        <span class="comment">//第i位的结果t % 10</span></span><br><span class="line">        C.add(t % <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//计算进位</span></span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断最后一次计算是否有进位</span></span><br><span class="line">    <span class="keyword">if</span>(t != <span class="number">0</span>) C.add(t);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果b为0，计算结果可能为00000，故需要去掉前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除低精度"><a href="#高精度除低精度" class="headerlink" title="高精度除低精度"></a>高精度除低精度</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> r; <span class="comment">//余数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">div</span><span class="params">(List&lt;Integer&gt; A, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//C = A / b</span></span><br><span class="line">    List&lt;Integer&gt; C = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=A.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r*<span class="number">10</span>+A.get(i);</span><br><span class="line">       <span class="comment">//第i位结果</span></span><br><span class="line">        C.add(r/b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆序存储</span></span><br><span class="line">    Collections.reverse(C);</span><br><span class="line">    <span class="comment">//结果可能为011，去除前导零</span></span><br><span class="line">    <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size()-<span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size()-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S[i] = a[<span class="number">1</span>]+a[<span class="number">2</span>]+...+a[i];</span><br><span class="line">a[l]~a[r]的和=S[r] - S[l-<span class="number">1</span>]; <span class="comment">//a[0] = 0; S[0] = 0</span></span><br></pre></td></tr></table></figure><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S[i][j]为第i行j列左上部分所有元素的和</span><br><span class="line">求左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的和：</span><br><span class="line">A = S[x2][y2] - S[x1-<span class="number">1</span>][y2] - S[x2][y1-<span class="number">1</span>] + S[x1-<span class="number">1</span>][y1-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h2 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">已知a[], b[],b[]为a[]的差分数组，即a[i] = b[<span class="number">0</span>]+b[<span class="number">1</span>]+...+b[i];</span><br><span class="line">给下标区间为[l,r]的a[]都加上常数c &lt;=&gt; b[l] += c, b[r+<span class="number">1</span>] -= c;</span><br></pre></td></tr></table></figure><h2 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给左上角坐标为x1,y1,右下角坐标为x2,y2的子矩阵的每一个元素加上c(先构造差分矩阵再插入)</span><br><span class="line">&lt;=&gt; </span><br><span class="line">b[x1][y1] += c,</span><br><span class="line">b[x1][y2+<span class="number">1</span>] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y1] -= c,</span><br><span class="line">b[x2+<span class="number">1</span>][y2+<span class="number">1</span>] += c;</span><br></pre></td></tr></table></figure><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求n的第k位数字（n为二进制表示形式）</span></span><br><span class="line">n &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"><span class="comment">//返回n的最后一位1（n为二进制表示形式）</span></span><br><span class="line">lowbit(n) <span class="keyword">return</span> n &amp; -n;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">    <span class="comment">// check(i, j) 表示根据题意设定的维护双指针的条件</span></span><br><span class="line">    <span class="keyword">while</span>(check(i, j)) j++;</span><br><span class="line">    <span class="comment">// 根据题意具体的逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>常见的问题有两类：<ul><li>对于一个序列，用两个指针维护一段区间</li><li>对于两个序列，维护某种次序，比如归并排序中合并两个子序列</li></ul></li></ul><h2 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Integer&gt; alls; <span class="comment">//存储所有待离散化的值（已去重）</span></span><br><span class="line">List&lt;Integer&gt; allList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">allList.addAll(alls);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(allList, (a1, a2) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (Integer)a1 - (Integer)a2;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果要使用前缀和，返回值+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=allList.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + right &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(allList.get(mid) &gt;= x) right = mid;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left+<span class="number">1</span>; <span class="comment">//映射到1,2,...,n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先将区间序列按照左端点排好序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">int</span> second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = a;</span><br><span class="line">        <span class="keyword">this</span>.second = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设list已经排好序,list.size() &gt;= 2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Pair&gt; <span class="title">merge</span><span class="params">(List&lt;Pair&gt; list)</span></span>&#123;</span><br><span class="line">    List&lt;Pair&gt; res = <span class="keyword">new</span> ArrayList&lt;Pair&gt;();</span><br><span class="line">    <span class="comment">//先将第一个区间加到res中</span></span><br><span class="line">    res.add(list.get(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//判断两个区间是否有交集</span></span><br><span class="line">        <span class="keyword">if</span>(res.get(res.size()-<span class="number">1</span>).second &lt; list.get(i).first)&#123;</span><br><span class="line">            <span class="comment">//没有，直接加</span></span><br><span class="line">            res.add(list.get(i));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//有，判断区间左端点是谁</span></span><br><span class="line">            <span class="keyword">int</span> second = res.get(res.size()-<span class="number">1</span>).second;</span><br><span class="line">            <span class="keyword">int</span> nSecond = list.get(i).second;</span><br><span class="line">            res.get(res.size()-<span class="number">1</span>).second = (second &gt; nSecond) ? second : nSecond;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 高精度 </tag>
            
            <tag> 前缀和与差分 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 离散化 </tag>
            
            <tag> 区间合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;三种迭代法的矩阵表示形式</title>
      <link href="2020/10/05/mathAnalysis-3-4/"/>
      <url>2020/10/05/mathAnalysis-3-4/</url>
      
        <content type="html"><![CDATA[<h1 id="三种迭代法的矩阵表示形式（-Ax-b-）"><a href="#三种迭代法的矩阵表示形式（-Ax-b-）" class="headerlink" title="三种迭代法的矩阵表示形式（$Ax= b$）"></a>三种迭代法的矩阵表示形式（$Ax= b$）</h1><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">假设A=D-L-U,D为对角矩阵， \\</script><script type="math/tex; mode=display">-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">(D-L-U)x = b \\\Rightarrow Dx = (L+U)x+b \\</script><script type="math/tex; mode=display">\Rightarrow x = D^{-1}(L+U)x+D^{-1}b \\\Rightarrow x^{(k+1)} = D^{-1}(L+U)x^{k}+D^{-1}b</script><a id="more"></a><ul><li><strong>迭代矩阵：</strong>$B=D^{-1}(L+U)$</li></ul><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><script type="math/tex; mode=display">假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">-L为缺少对角线元素的下三角矩阵，-U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">(D-L-U)x = b \\\Rightarrow Dx = Lx + Ux + b \\</script><script type="math/tex; mode=display">\Rightarrow Dx^{(k+1)} = Lx^{(k+1)}+Ux^k+b \\\Rightarrow (D-L)x^{(k+1)} = Ux^k+b \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = (D-L)^{-1}Ux^k+(D-L)^{-1}b</script><ul><li><strong>迭代矩阵：</strong>$G=(D-L)^{-1}U$</li></ul><h2 id="SOR迭代法"><a href="#SOR迭代法" class="headerlink" title="SOR迭代法"></a>SOR迭代法</h2><script type="math/tex; mode=display">假设A=D-L-U,D为对角矩阵，</script><script type="math/tex; mode=display">L为缺少对角线元素的下三角矩阵，U为缺少对角线元素的上三角矩阵 \\</script><script type="math/tex; mode=display">(D-L-U)x = b\\</script><script type="math/tex; mode=display">\Rightarrow x = x +[b-(D-L-U)x] \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = x^{k} + D^{-1}[b-(D-L-U)x^{k}],J迭代格式 \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = x^k + D^{-1}[b+(U-D)x^k+Lx^{(k+1)}],G-S迭代格式 \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = x^k + \omega D^{-1}[b+(U-D)x^k+Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">\Rightarrow Dx^{(k+1)} = Dx^k+[\omega b+ \omega(U-D)x^k+\omega Lx^{(k+1)}] \\</script><script type="math/tex; mode=display">\Rightarrow (D-\omega L)x^{(k+1)} = [D(1-\omega)+\omega U]x^k + \omega b \\</script><script type="math/tex; mode=display">\Rightarrow x^{(k+1)} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]x^k + \omega(D-\omega L)^{-1}b</script><ul><li><strong>迭代矩阵：</strong>$L_{\omega} = (D-\omega L)^{-1}[D(1-\omega)+\omega U]$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;SOR迭代法</title>
      <link href="2020/10/05/mathAnalysis-3-3/"/>
      <url>2020/10/05/mathAnalysis-3-3/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li>Jacobi迭代法的实质是用当前的迭代值加上一个修正量来得到一个新的迭代值，结合J迭代法和GS迭代法以及修正量的思想引入<strong>SOR迭代法</strong>。<a id="more"></a></li></ul><h2 id="SOR迭代法的表达式"><a href="#SOR迭代法的表达式" class="headerlink" title="SOR迭代法的表达式"></a>SOR迭代法的表达式</h2><ul><li><p>$x^{(k+1)}_i=x_i^{(k)}+\frac{\omega}{a_{ii}}(b_i - \sum^{i-1}_{j=1}a_{ij}x_j^{(k+1)}-\sum^n_{j=i}a_{ij}x_j^{(k)})$</p><p>$i=1,2,\cdots,n,\quad k=0,1,\cdots$</p></li><li><p>$\omega$称作<strong>松弛因子</strong>，当$\omega &lt; 1$时，此迭代称为<strong>欠松弛迭代</strong>，$\omega&gt;1$时，称为<strong>超松弛迭代</strong>。</p></li></ul><h2 id="SOR迭代法的判定定理"><a href="#SOR迭代法的判定定理" class="headerlink" title="SOR迭代法的判定定理"></a>SOR迭代法的判定定理</h2><ul><li><strong>定理一</strong>：SOR方法收敛的<strong>充分必要条件</strong>是 $\rho(M_\omega)&lt;1$；收敛的<strong>充分</strong>条件为 $||M_\omega||&lt;1$。（$M_\omega$为迭代矩阵）</li><li><strong>定理二</strong>：SOR方法收敛的<strong>必要条件</strong>是：$0&lt;\omega&lt;2$。</li><li><strong>定理三</strong>：设系数矩阵$A$是对称正定的，且 $0&lt;\omega&lt;2$，则SOR方法收敛。</li><li><strong>定理四</strong>：当系数矩阵$A$是$\alpha-$严格对角占优矩阵，且 $0&lt;w \le1$，SOR方法收敛。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;Jacobi迭代法和Gauss-Seidel迭代法</title>
      <link href="2020/10/05/mathAnalysis-3-2/"/>
      <url>2020/10/05/mathAnalysis-3-2/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul><li>以该线性方程组为例，介绍几种线性方程组的数值解法</li><li><script type="math/tex; mode=display">\left\{  \begin{array}{c}    a_{11}x_1+a_{12}x_2+a_{13}x_3=b_1 \\     a_{21}x_1+a_{22}x_2+a_{23}x_3=b_2 \\     a_{31}x_1+a_{32}x_2+a_{33}x_3=b_3 \end{array} \right.</script></li></ul><a id="more"></a><h2 id="Jacobi迭代法"><a href="#Jacobi迭代法" class="headerlink" title="Jacobi迭代法"></a>Jacobi迭代法</h2><script type="math/tex; mode=display">\left\{\begin{array}{c}x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k)}-a_{23}x_3^{(k)}) \\x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k)}-a_{32}x_3^{(k)})\end{array}\right.</script><h2 id="Gauss-Seidel迭代法"><a href="#Gauss-Seidel迭代法" class="headerlink" title="Gauss-Seidel迭代法"></a>Gauss-Seidel迭代法</h2><ul><li>由Jacobi迭代公式我们可知，在计算$x_2^{(k+1)}$时，此时$x_1^{(k+1)}$已经计算出；在计算$x_3^{(k+1)}$时，$x_1^{(k+1)},x_2^{(k+1)}$也已经计算出。为了充分利用这些数据便有了Gauss-Seidel迭代法：</li></ul><script type="math/tex; mode=display">\left\{\begin{array}{c}x_1^{(k+1)} = \frac{1}{a_{11}}(b_1-a_{12}x_2^{(k)}-a_{13}x_3^{(k)}) \\x_2^{(k+1)} = \frac{1}{a_{22}}(b_2-a_{21}x_1^{(k+1)}-a_{23}x_3^{(k)}) \\x_3^{(k+1)} = \frac{1}{a_{33}}(b_3-a_{31}x_1^{(k+1)}-a_{32}x_3^{(k+1)})\end{array}\right.</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第三章&gt;&gt;迭代法的收敛性</title>
      <link href="2020/10/05/mathAnalysis-3-1/"/>
      <url>2020/10/05/mathAnalysis-3-1/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代法的一般形式"><a href="#迭代法的一般形式" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h2><h3 id="线性方程组的等价形式"><a href="#线性方程组的等价形式" class="headerlink" title="线性方程组的等价形式"></a>线性方程组的等价形式</h3><ul><li>$Ax=b \Leftrightarrow x = Mx+g$<ul><li>$M$成为迭代矩阵，$g$为某一向量<a id="more"></a></li></ul></li></ul><h3 id="迭代法的一般形式-1"><a href="#迭代法的一般形式-1" class="headerlink" title="迭代法的一般形式"></a>迭代法的一般形式</h3><ul><li>$x^{(k+1)}=Mx^{(k)}+g$</li></ul><h2 id="迭代法收敛的判定定理"><a href="#迭代法收敛的判定定理" class="headerlink" title="迭代法收敛的判定定理"></a>迭代法收敛的判定定理</h2><ul><li><strong>定理一</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分必要条件</strong>是迭代矩阵$M$的谱半径 $\rho(M)&lt;1$。</li><li><strong>定理二</strong>：对于任意初始向量$x^{(0)}$，迭代法收敛的<strong>充分条件</strong>是 $||M||&lt;1$。</li><li><strong>补充：</strong>当迭代方法的迭代矩阵谱半径$\rho(M)&lt;1$时，谱半径越小，迭代方法的收敛速度越快。</li></ul><h2 id="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"><a href="#Jacobi迭代法和Gauss-Seidel迭代法的收敛性" class="headerlink" title="Jacobi迭代法和Gauss-Seidel迭代法的收敛性"></a>Jacobi迭代法和Gauss-Seidel迭代法的收敛性</h2><h3 id="严格对角占优矩阵"><a href="#严格对角占优矩阵" class="headerlink" title="严格对角占优矩阵"></a>严格对角占优矩阵</h3><script type="math/tex; mode=display">设n阶A=(a_{ij})，如果A的元素满足:</script><script type="math/tex; mode=display">\sum^n_{j=1 \\ j\neq i}|a_{ij}| < |a_{ii}|,\ i=1,2,\cdots,n \\则称A是严格对角占优矩阵</script><h3 id="判定定理"><a href="#判定定理" class="headerlink" title="判定定理"></a>判定定理</h3><ul><li><p><strong>定理一</strong>：设$A$是严格对角占优矩阵，则解方程组$Ax=b$的$J$迭代法和$GS$迭代法均收敛。</p></li><li><p><strong>定理二</strong>：设$A$是对称正定矩阵，则解方程组$Ax=b$的$GS$迭代法是收敛的。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;线性方程组的固有性态</title>
      <link href="2020/10/05/mathAnalysis-2-6/"/>
      <url>2020/10/05/mathAnalysis-2-6/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>由于原始数据微小变化而导致解严重失真的方程组称为<strong>病态方程组</strong>，相应的系数矩阵称为<strong>病态矩阵</strong>。</li><li>使用<strong>条件数</strong>来判定线性方程组是否<strong>病态</strong>。<a id="more"></a></li></ul><h2 id="条件数"><a href="#条件数" class="headerlink" title="条件数"></a>条件数</h2><ul><li>$Cond(A)=||A||\  ||A^{-1}||$</li><li>经常使用的条件数: $Cond_p(A)=||A||_p \  ||A^{-1}||_p,\  p=1,2,\infty$</li><li>当$A$为<strong>对称矩阵</strong>时, 可有</li></ul><script type="math/tex; mode=display">Cond_2(A)=\frac{|\lambda|_{max}}{|\lambda|_{min}}</script><ul><li>通常用<strong>条件数过大</strong>来判定方程组是病态方程组</li></ul><h2 id="逆矩阵的求法"><a href="#逆矩阵的求法" class="headerlink" title="逆矩阵的求法"></a>逆矩阵的求法</h2><ul><li>$(A,E) \Rightarrow 经过初等行变换得 (E, A^{-1})$</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;范数</title>
      <link href="2020/10/05/mathAnalysis-2-5/"/>
      <url>2020/10/05/mathAnalysis-2-5/</url>
      
        <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><ul><li>为了对线性方程组的性态和其数值解进行分析，故引入范数来表示。<a id="more"></a></li></ul><h2 id="向量范数"><a href="#向量范数" class="headerlink" title="向量范数"></a>向量范数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>假设$||\cdot||$为向量空间$R^n$的实值函数，且满足以下三个条件：</li><li><strong>非负性：</strong>对于任何向量$x\in R^n$，$||x||\ge 0$，且$||x||=0$当且仅当$x=0$</li><li><strong>齐次性：</strong>对于任何实数$\alpha$和向量$x\in R^n$，$||\alpha x||=|\alpha|||x||$</li><li><strong>三角不等式：</strong>对于任何向量$x,y\in R^n$，$||x+y||\le||x||+||y||$</li></ul><p>则称$||\cdot||$为向量空间$R^n$上的范数，$||x||$为向量$x$的范数</p><h3 id="常用的三个向量范数"><a href="#常用的三个向量范数" class="headerlink" title="常用的三个向量范数"></a>常用的三个向量范数</h3><ul><li>向量1-范数：$||x||_1=\sum^n_{i=1}|x_i|$</li><li>向量2-范数：$||x||_2=(\sum^n_{i=1}x_i^2)^{\frac{1}{2}}$(向量的模)</li><li>向量$\infty$-范数：$||x||_\infty=max_{1\le i\le n}|x_i|$</li></ul><h3 id="范数的等价性以及常用的等价公式"><a href="#范数的等价性以及常用的等价公式" class="headerlink" title="范数的等价性以及常用的等价公式"></a>范数的等价性以及常用的等价公式</h3><ul><li><p><strong>范数的等价性：</strong>对于$R^n$空间上的任意两个范数$||\cdot||_\alpha$和$||\cdot||_\beta$，存在正常数$m,M$，使得：</p><p>$m||x||_\beta \le ||x||_\alpha \le M||x||_\beta, \forall x \in R^n$</p></li><li><p><strong>常用的等价公式：</strong></p><p>$||x||_\infty \le ||x||_1 \le n||x||_\infty$</p><p>$||x||_\infty \le ||x||_2 \le \sqrt n||x||_\infty$</p><p>$||x||_2 \le ||x||_1 \le \sqrt n||x||_2$</p></li></ul><h2 id="矩阵范数"><a href="#矩阵范数" class="headerlink" title="矩阵范数"></a>矩阵范数</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>与向量范数定义类似，除去向量范数满足的三个条件以外，还要满足第四个条件：</li><li>$||AB|| \le ||A||||B||$</li><li>满足四个条件则称$||A||$为$A$的范数</li></ul><h3 id="四个常用的矩阵范数"><a href="#四个常用的矩阵范数" class="headerlink" title="四个常用的矩阵范数"></a>四个常用的矩阵范数</h3><ul><li>矩阵的1-范数（列范数）：$||A||_1=max_{1\le j\le n}\sum_{i=1}^n|a_{ij}|$</li><li>矩阵的2-范数（谱范数）：$||A||_2=(A^TA的最大特征值)^{\frac{1}{2}}$</li><li>矩阵的$\infty$-范数（行范数）：$||A||_\infty=max_{1\le i \le n}\sum_{j=1}^n|a_{ij}|$</li><li>矩阵的F-范数：$||A||_F=(\sum_{i,j=1}^n|a_{ij}|^2)^{\frac{1}{2}}$</li></ul><p>识记：1是竖着的所以一范数是列范数，$\infty$范数是横着的所以是行范数。</p><h3 id="矩阵相容范数的判定"><a href="#矩阵相容范数的判定" class="headerlink" title="矩阵相容范数的判定"></a>矩阵相容范数的判定</h3><ul><li>$||Ax||\le ||A||\  ||x||,\  \forall x \in R^n$</li></ul><h3 id="谱半径"><a href="#谱半径" class="headerlink" title="谱半径"></a>谱半径</h3><ul><li>$\rho(A)=max_{1\le i \le n}|\lambda|$</li></ul><h3 id="特征值-lambda-的求法"><a href="#特征值-lambda-的求法" class="headerlink" title="特征值$\lambda$的求法"></a>特征值$\lambda$的求法</h3><ul><li>计算行列式: $|\lambda E - A| = 0$</li><li>特征值得和等于矩阵主对角线元素之和</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;追赶法</title>
      <link href="2020/10/05/mathAnalysis-2-4/"/>
      <url>2020/10/05/mathAnalysis-2-4/</url>
      
        <content type="html"><![CDATA[<h2 id="使用范围"><a href="#使用范围" class="headerlink" title="使用范围"></a>使用范围</h2><ul><li>追赶法是求三对角线性方程组的三角分解法。<a id="more"></a></li></ul><h2 id="矩阵：-A-TM"><a href="#矩阵：-A-TM" class="headerlink" title="矩阵：$A=TM$"></a>矩阵：$A=TM$</h2><script type="math/tex; mode=display">A=\left[\begin{matrix}a_1 & c_1 \\d_2 & a_2    & c_2 \\    & \ddots & \ddots & \ddots \\    &        & d_{n-1}& a_{n-1} & c_{n-1} \\    &        &        & d_n     & a_n      \\\end{matrix}\right]</script><h2 id="三对角矩阵-A-的各阶顺序主子式不为零的充要条件"><a href="#三对角矩阵-A-的各阶顺序主子式不为零的充要条件" class="headerlink" title="三对角矩阵$A$的各阶顺序主子式不为零的充要条件"></a>三对角矩阵$A$的各阶顺序主子式不为零的充要条件</h2><ul><li>$|a_1|&gt;|c_1|;|a_n|&gt;|d_n|;$</li><li>$|a_i|\ge |c_i|+|d_i|,c_id_i\neq0,i=2,3,…n-1$</li></ul><h2 id="追赶法的具体步骤"><a href="#追赶法的具体步骤" class="headerlink" title="追赶法的具体步骤"></a>追赶法的具体步骤</h2><ul><li>先求第一行，再求第二行，依次类推</li><li>每一行都是从左到右开始求解</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;平方根法</title>
      <link href="2020/10/05/mathAnyalsis-2-3/"/>
      <url>2020/10/05/mathAnyalsis-2-3/</url>
      
        <content type="html"><![CDATA[<h2 id="引入：对称正定矩阵"><a href="#引入：对称正定矩阵" class="headerlink" title="引入：对称正定矩阵"></a>引入：对称正定矩阵</h2><ul><li>矩阵各元素的各元素沿主对角线对称</li><li>矩阵的所有特征值均大于零</li></ul><a id="more"></a><h2 id="平方根法的使用条件"><a href="#平方根法的使用条件" class="headerlink" title="平方根法的使用条件"></a>平方根法的使用条件</h2><ul><li>$A$为对称正定矩阵，且$U_{kk}&gt;0$。</li></ul><h2 id="平方根法的步骤"><a href="#平方根法的步骤" class="headerlink" title="平方根法的步骤"></a>平方根法的步骤</h2><ul><li>$A=UU^T$,只需要计算$U$即可。</li><li>计算顺序：计算下三角矩阵$U$的第一列、第二列……依此类推。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;直接三角分解法</title>
      <link href="2020/10/05/mathAnalysis-2-2/"/>
      <url>2020/10/05/mathAnalysis-2-2/</url>
      
        <content type="html"><![CDATA[<h2 id="定义（顺序Gauss消去法的矩阵形式）"><a href="#定义（顺序Gauss消去法的矩阵形式）" class="headerlink" title="定义（顺序Gauss消去法的矩阵形式）"></a>定义（顺序Gauss消去法的矩阵形式）</h2><ul><li>将系数矩阵$A$分解成$A=LU$（单位下三角矩阵$L$和上三角矩阵$U$）</li></ul><script type="math/tex; mode=display">Ax=b\Rightarrow\begin{cases}Ux=y \\Ly=b\end{cases}</script><a id="more"></a><ul><li>充要条件$A$的各阶顺序主子式不为零</li></ul><h2 id="获取-L-矩阵和-U-矩阵的方法"><a href="#获取-L-矩阵和-U-矩阵的方法" class="headerlink" title="获取$L$矩阵和$U$矩阵的方法"></a>获取$L$矩阵和$U$矩阵的方法</h2><ul><li>先求$U$矩阵的第一行，再求$L$矩阵的第一列，以此类推。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第二章&gt;&gt;顺序Gauss消去法</title>
      <link href="2020/03/11/mathAnalysis-2-1/"/>
      <url>2020/03/11/mathAnalysis-2-1/</url>
      
        <content type="html"><![CDATA[<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li>将线性方程组的增广矩阵，只通过行变换，将增广矩阵化简成一个上三角矩阵。再从增广矩阵的最后一行开始依次回代，求出解向量。<a id="more"></a></li></ul><h2 id="算法成立的充要条件"><a href="#算法成立的充要条件" class="headerlink" title="算法成立的充要条件"></a>算法成立的充要条件</h2><ul><li>主元素不为零$\Leftrightarrow$系数矩阵的各阶主子式都不为零</li><li>主元素：顺序Gauss消去法中的$a_{kk}^{(k)},(k=1,2,…n)$。</li></ul><h2 id="列主元Gauss消去法"><a href="#列主元Gauss消去法" class="headerlink" title="列主元Gauss消去法"></a>列主元Gauss消去法</h2><ul><li>在顺序Gauss消去法的基础上，在每一步消元之前，在主元所在的列选取绝对值最大的元素作为主元素。</li><li>充要条件：$|A|\neq0$ </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值分析&gt;&gt;第一章&gt;&gt;误差分析</title>
      <link href="2020/03/11/mathAnalysis-1-1/"/>
      <url>2020/03/11/mathAnalysis-1-1/</url>
      
        <content type="html"><![CDATA[<h2 id="误差的来源与分类"><a href="#误差的来源与分类" class="headerlink" title="误差的来源与分类"></a>误差的来源与分类</h2><ul><li>观测误差</li><li>模型误差</li><li>截断误差：近似计算出现的误差<a id="more"></a></li><li>舍入误差：由于计算级只能进行有限位的运算而产生的误差</li><li>绝对误差:  $e=x^{*}-x$ 其中e为绝对误差<br>如果$\epsilon$满足：<br>  $|e|\leq\epsilon$, 则$\epsilon$为$x$的绝对误差限</li><li>相对误差：<br>  $e_r = \frac{x^* - x}{x} = \frac{e}{x}$, $e_r$为相对误差</li><li>相对误差限：<br>  $\epsilon_r=\frac{\epsilon}{|x|}$, $\epsilon_r$为相对误差限，同时$|e_r|\le\epsilon_r$</li></ul><h2 id="有效数字"><a href="#有效数字" class="headerlink" title="有效数字"></a>有效数字</h2><ul><li>有效数字与绝对误差限的关系：<script type="math/tex; mode=display">|x^*-x|\leq\frac{1}{2}\times10^{m-n},其中n为有效数字的位数。</script><script type="math/tex; mode=display">m为x^*化为标准浮点数形式下的10m次幂。</script>注：精确值的有效数字有无穷多位！</li><li><p>有效数字和相对误差限的关系(其中$a_1$为$x$化为标准浮点数下小数点后第一个非零的数)：</p><ul><li><p>已知有效位数$n$:<br>  $\epsilon_r\le\frac{1}{2a_1}\times10^{-n+1}$</p></li><li><p>已知$x$的相对误差限:<br>  $\epsilon_r\le\frac{1}{2(a_1+1)}\times10^{-n+1}$</p></li></ul></li></ul><h2 id="数值计算中的若干原则"><a href="#数值计算中的若干原则" class="headerlink" title="数值计算中的若干原则"></a>数值计算中的若干原则</h2><ul><li>避免两个相近的数相减（使用其他算法，公式？乘除？）<script type="math/tex; mode=display">假设z=x-y,z^*=x^*-y^*,那么：</script><script type="math/tex; mode=display">e_r(z)=|\frac{x}{x-y}||e_r(x)|+|\frac{y}{x-y}||e_r(x)|</script><script type="math/tex; mode=display">从该式中我们可以看出z的相对误差会特别大</script></li><li><p>防止“大数”吃掉小数（改变运算顺序？）</p></li><li><p>绝对值太小的数不宜做除数</p><script type="math/tex; mode=display">  假设z=x \div y,z^* = x^* \div y^*,那么：</script><script type="math/tex; mode=display">  e(z)=|z^*-z|=|\frac{y(x^*-x)+x(y-y^*)}{yy*}|\approx \frac{|y||e(x)|+|x||e(y)|}{y^2}​</script><p>  则如果$y$的绝对值太小，那么$z$的绝对误差较大</p></li><li><p>注意简化计算程序，减少计算次数（舍入误差的积累和计算的时间）</p></li><li><p>选用数值稳定性好的算法</p></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><ol><li><p>将下列表达式进行等价变形，使其数值计算结果较为精确。</p><p>(1) $\frac{1}{1-2x}-\frac{1+x}{1-x},|x|&lt;&lt;1$</p><p>解：$原式=\frac{2x^2}{(1-2x)(1-x)}$</p><p>(2)$\frac{1-e^x}{x},|x|&lt;&lt;1$</p><p>解：由$e^x$在x=0处的泰勒展开式可得：</p><p>$e^x= 1+x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2+R_n(x)$</p><p>所以</p><p>$\frac{1-e^x}{x}=\frac{x+\frac{1}{2!}x^2+…+\frac{1}{n!}x^2}{x}=1+\frac{1}{2!}x+\frac{1}{3!}x^2+…+\frac{1}{n!}x^{n-1}$</p></li><li><p>假设$f=(\sqrt{2}-1)^6,\sqrt{2}$取1.4，下列哪种计算方式的精确度最高。</p><p>(1)$\frac{1}{(\sqrt{2}+1)^6}\Rightarrow f(x)=\frac{1}{x^6}$</p><p>(2)$(3-2\sqrt2)^3 \Rightarrow f(x)=x^3$</p><p>(3)$\frac{1}{(3-2\sqrt2)^3} \Rightarrow f(x)=\frac{1}{x^3}$</p><p>(4)$99-70\sqrt2 \Rightarrow f(x)=99-70x$</p><p>解：使用函数的条件数$cond=|\frac{f^{‘}(x)x}{f(x)}|$</p><p>将$x=1.4$带入其中，可得(3)式的精确度最高。</p><p>注：条件数低为良态，条件数高为病态。   </p><h2 id="补充：-x-1x-2-的绝对误差限"><a href="#补充：-x-1x-2-的绝对误差限" class="headerlink" title="补充：$x_1x_2$的绝对误差限"></a>补充：$x_1x_2$的绝对误差限</h2></li></ol><p>$x_1\approx x_1,x_2\approx x_2$</p><script type="math/tex; mode=display">|x_1x_2-x_1^*x_2^*|=|x_1x_2-x_1x_2^*+x_1x_2^*-x_1^*x_2^*|</script><script type="math/tex; mode=display">\le|x_1||x_2-x_2^*|+|x_2^*||x_1-x_1^*|</script><script type="math/tex; mode=display">    =|x_1||e(x_2)|+|x_2||e(x_1)|</script>]]></content>
      
      
      <categories>
          
          <category> 数值分析笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
